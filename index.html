<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
    <meta name="theme-color" content="#0b0b0f" />
  <link rel="manifest" href="manifest.json" />

  <!-- iOS PWA -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="BotiDefense" />
  <link rel="apple-touch-icon" href="icons/icon-192.png" />
<title>Botic√°rio Defense V7</title>
  <style>
    :root{
      --bg:#070a16;
      --ink:#eef2ff;
      --muted:#b7c3ff;
      --line:rgba(255,255,255,.14);
      --good:#7CFFB2;
      --warn:#FFD36A;
      --bad:#FF6A6A;
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --uiPad:12px;
      --uiPad2:24px;
      --sideBaseW:240;
      --sideW:240px;
      --seedColW:198;
      --seedGap:18;
   
      --shellBaseW:1180;
      --shellW:1180px;
      --playTargetW:940;
      --playMinW:860;
      --sidePadW:0px;
    }
    html,body{
      height:100%;
      margin:0;
      background:
        radial-gradient(1200px 600px at 50% 0%, rgba(124,255,178,.08), transparent 60%),
        radial-gradient(900px 520px at 85% 80%, rgba(183,195,255,.10), transparent 55%),
        radial-gradient(800px 520px at 20% 90%, rgba(255,211,106,.08), transparent 55%),
        var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      overflow:hidden;
    }

    .wrap{
  height:100%;
  min-height:100%;
  display:flex;
  align-items:stretch;
  justify-content:center;
  box-sizing:border-box;
  padding-top: calc(var(--uiPad) + env(safe-area-inset-top));
  padding-right: calc(var(--uiPad) + env(safe-area-inset-right));
  padding-bottom: calc(var(--uiPad) + env(safe-area-inset-bottom));
  padding-left: calc(var(--uiPad) + env(safe-area-inset-left));
}
    .shell{
  width:var(--shellW);
  max-width:100%;
  height: calc((var(--vh, 1vh) * 100) - (var(--uiPad2) + env(safe-area-inset-top) + env(safe-area-inset-bottom)));
  max-height: calc((var(--vh, 1vh) * 100) - (var(--uiPad2) + env(safe-area-inset-top) + env(safe-area-inset-bottom)));
  border-radius:18px;
  border:1px solid var(--line);
  background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
  box-shadow:var(--shadow);
  overflow:hidden;
  position:relative;
  display:flex;
  flex-direction:column;
}

    .top{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:10px 12px;
      background:rgba(0,0,0,.24);
      border-bottom:1px solid var(--line);
      flex-wrap:wrap;
    }
    .brand{display:flex; align-items:baseline; gap:10px; flex-wrap:wrap;}
    .brand b{letter-spacing:.2px;}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      font-size:13px;
      white-space:nowrap;
    }
    .dot{width:9px;height:9px;border-radius:50%;}
    .btns{display:flex; gap:8px; flex-wrap:wrap;}
    button{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:var(--ink);
      border-radius:12px;
      padding:8px 10px;
      font-weight:1000;
    }
    button:hover{background:rgba(255,255,255,.12)}
    button:active{transform:translateY(1px)}
    button:disabled{
      cursor:not-allowed;
      opacity:.55;
      filter:saturate(.6);
    }
    .btnSmall{
      padding:6px 9px;
      border-radius:10px;
      font-weight:1000;
      font-size:12px;
    }

    .main{
  flex:1 1 auto;
  min-height:0;
  display:flex;
  gap:16px;
  padding:12px;
  background:rgba(0,0,0,.10);
  position:relative;
  overflow:hidden;
}
    .main::after{
      content:"";
      flex:0 0 var(--sidePadW);
      width:var(--sidePadW);
      max-width:var(--sidePadW);
      pointer-events:none;
    }
    .side{
      width:var(--sideW);
      flex:0 0 var(--sideW);
      min-width:var(--sideW);
      max-width:var(--sideW);
      overflow:hidden;
      background:linear-gradient(180deg, rgba(16,26,58,.78), rgba(14,22,50,.55));
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      padding:10px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
      position:relative;
      min-height:0;
    }
    .sideHeader{
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      padding:6px 8px;
      border-radius:12px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
    }
    .sideHeader b{font-size:13px}
    .sideHeader .hintTiny{font-size:12px; opacity:.8; font-weight:800}
    .seedbank{
  display:flex;
  flex-direction:column;
  gap:8px;
  flex:1 1 auto;
  min-height:0;
  max-height:none;
  overflow:auto;
  padding-right:2px;
}
/* Multicol: >8 itens => grid em colunas (sem scroll e sem mexer no DOM) */
/* Multicol: >8 itens => grid em colunas (sem reordenar, sem sobrepor gameplay) */
.seedbank.multicol{
  display:grid;
  grid-auto-flow: column;
  grid-template-rows: repeat(8, auto);
  grid-auto-columns: calc(var(--seedColW) * 1px);
  row-gap: 10px;
  column-gap: calc(var(--seedGap) * 1px);
  max-height:none;
  overflow-y:visible;
  overflow-x:hidden; /* pode virar auto via JS se precisar clamp */
  padding-right:0;
  padding-bottom:2px;
  align-content:start;
  justify-content:start;
}
.seedbank.multicol .seed{ width: calc(var(--seedColW) * 1px); }

.seed{
      position:relative;
      border-radius:14px;
      background:linear-gradient(180deg, rgba(52,78,172,.78), rgba(34,54,132,.68));
      border:1px solid rgba(255,255,255,.14);
      box-shadow:0 10px 22px rgba(0,0,0,.22);
      padding:8px 8px 8px 10px;
      display:flex; gap:8px; align-items:center;
      user-select:none;
      cursor:pointer;
      min-height:48px;
    }
    .seed:hover{filter:brightness(1.08)}
    .seed.selected{outline:3px solid rgba(124,255,178,.45)}
    .seed.locked{opacity:.55; cursor:not-allowed;}
    .icon{
      width:36px; height:36px; border-radius:12px;
      background:rgba(255,255,255,.10);
      display:grid; place-items:center;
      border:1px solid rgba(255,255,255,.14);
      flex:0 0 auto;
      font-size:19px;
    }
    .meta{min-width:0}
    .name{font-weight:1000; font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .seed .desc{display:none;}
    .desc{font-weight:800; font-size:12px; color:rgba(238,242,255,.75); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .cost{margin-top:6px; font-weight:1000; font-size:12px;}
    .cost.good{color:var(--warn)}
    .cost.bad{color:var(--bad)}
    .cool{
      position:absolute; inset:0;
      border-radius:16px;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:flex-end;
      justify-content:flex-end;
      padding:8px 10px;
      box-sizing:border-box;
    }
    .seed.cooling .cool{display:flex;}
    .cool span{
      font-weight:1000;
      font-size:13px;
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.18);
      padding:4px 8px;
      border-radius:999px;
    }

    .play{
      flex:1 1 auto;
      min-width:0;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:10px;
      position:relative;
      z-index:1;
    }

    .wavebar{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      background:rgba(0,0,0,.22);
    }
    .wavebar b{font-size:13px; white-space:nowrap}
    .bar{
      position:relative;
      height:12px;
      flex:1 1 auto;
      border-radius:999px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.14);
      overflow:hidden;
    }
    .barFill{
      position:absolute; inset:0;
      width:0%;
      background:linear-gradient(90deg, rgba(124,255,178,.75), rgba(255,211,106,.75));
      border-radius:999px;
    }
    .barNodes{
      position:absolute; inset:0;
      pointer-events:none;
    }
    .node{
      position:absolute;
      top:50%;
      width:8px; height:8px;
      border-radius:50%;
      transform:translate(-50%,-50%);
      background:rgba(255,255,255,.22);
      border:1px solid rgba(255,255,255,.20);
    }
    .node.active{
      background:rgba(255,211,106,.95);
      border-color:rgba(255,255,255,.25);
      box-shadow:0 0 0 6px rgba(255,211,106,.12);
    }
    .waveRight{
      font-size:12px;
      font-weight:1000;
      opacity:.9;
      white-space:nowrap;
    }

    .canvasWrap{
  position:relative;
  flex:1 1 auto;
  min-height:0;
  display:flex;
  justify-content:center;
  align-items:center;
  padding:10px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.16);
  overflow:hidden; /* evita "corte" no mobile quando houver zoom */
}

    canvas{
      display:block;
      max-width:100%;
      max-height:100%;
      width:auto;
      height:auto;
      aspect-ratio: 4 / 3;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.14);
      background:linear-gradient(180deg, rgba(12,16,34,.95), rgba(7,10,22,.95));
      transform: scale(var(--zoom, 1));
      transform-origin:center;
      cursor:default;
    
      touch-action:none;
      -webkit-user-select:none;
      user-select:none;
    }

    .zoomControls{
      position:absolute;
      right:14px;
      top:14px;
      display:flex;
      flex-direction:column;
      gap:8px;
      z-index:2;
    }
    .zoomControls .zoomPill{
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:10px;
      border-radius:14px;
      background:rgba(0,0,0,.34);
      border:1px solid rgba(255,255,255,.14);
      align-items:center;
    }
    .zoomControls .zoomPct{
      font-weight:1000;
      font-size:12px;
      opacity:.9;
    }

    .hint{
      padding:10px 12px 14px;
      border-top:1px solid var(--line);
      background:rgba(0,0,0,.18);
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
    }
    .hint kbd{
      padding:2px 6px;
      border:1px solid rgba(255,255,255,.20);
      border-bottom-width:2px;
      border-radius:7px;
      background:rgba(255,255,255,.08);
      color:var(--ink);
      font-weight:1000;
      font-size:12px;
    }

    /* Overlay / Modal */
    .overlay{
      position:fixed; inset:0;
      background:rgba(0,0,0,.62);
      display:none;
      align-items:center;
      justify-content:center;
      padding: calc(12px + env(safe-area-inset-top))
               calc(12px + env(safe-area-inset-right))
               calc(12px + env(safe-area-inset-bottom))
               calc(12px + env(safe-area-inset-left));
      box-sizing:border-box;
      z-index:10;
    }
    .overlay.show{display:flex;}
    .modal{
      width:min(980px, 100%);
      background:linear-gradient(180deg, rgba(17,26,51,.95), rgba(10,14,30,.95));
      border:1px solid rgba(255,255,255,.16);
      border-radius:18px;
      box-shadow:0 20px 55px rgba(0,0,0,.55);
      padding:16px;
      position:relative;
      display:flex;
      flex-direction:column;
      max-height: calc((var(--vh, 1vh) * 100) - (44px + env(safe-area-inset-top) + env(safe-area-inset-bottom)));
      overflow:hidden;
    }
    .modal::before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(700px 360px at 20% 10%, rgba(124,255,178,.14), transparent 60%),
        radial-gradient(700px 360px at 80% 30%, rgba(255,211,106,.12), transparent 60%),
        radial-gradient(800px 420px at 60% 100%, rgba(183,195,255,.12), transparent 60%);
      pointer-events:none;
      filter: blur(0px);
      opacity:.9;
    }
    .modal > *{position:relative;}
    #overlayBody{
      flex:1;
      overflow:auto;
      padding-right:2px;
    }

    .modalHead{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .modal h2{margin:0; font-size:22px; letter-spacing:.2px;}
    .tabs{display:flex; gap:8px; flex-wrap:wrap;}
    .tabBtn{
      padding:7px 10px;
      border-radius:999px;
      font-size:12px;
      font-weight:1000;
    }
    .tabBtn.active{
      background:rgba(124,255,178,.14);
      border-color:rgba(124,255,178,.30);
      box-shadow:0 0 0 6px rgba(124,255,178,.08);
    }
    .modal p{margin:10px 0 12px; color:rgba(238,242,255,.78); font-weight:750;}
    .rowBtns{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; margin-top:12px;}
    .small{font-size:12px; opacity:.82}
    .hr{height:1px; background:rgba(255,255,255,.12); margin:10px 0;}

    /* Menu principal */
    .menuHero{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:12px;
    }
    @media (max-width: 860px){
      .menuHero{grid-template-columns: 1fr;}
    }
    .heroCard{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.22);
      border-radius:18px;
      padding:14px;
    }
    .heroTitle{
      font-size:28px;
      font-weight:1100;
      letter-spacing:.2px;
      margin:0 0 6px;
      line-height:1.05;
    }
    .heroSub{
      margin:0;
      color:rgba(238,242,255,.80);
      font-weight:750;
      line-height:1.35;
    }
    .heroBadges{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;}
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      font-size:12px;
      font-weight:1000;
      white-space:nowrap;
    }
    .menuActions{display:flex; flex-direction:column; gap:10px;}
    .menuActions button{padding:11px 12px; border-radius:14px;}
    .menuActions .primary{
      background:linear-gradient(180deg, rgba(124,255,178,.18), rgba(124,255,178,.10));
      border-color:rgba(124,255,178,.30);
    }
    .menuActions .primary:hover{filter:brightness(1.07)}
    .menuActions .danger{
      background:linear-gradient(180deg, rgba(255,106,106,.16), rgba(255,106,106,.08));
      border-color:rgba(255,106,106,.30);
    }
    .storyCard{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.20);
      border-radius:18px;
      padding:14px;
      margin-top:12px;
    }
    .storyCard b{font-size:13px}
    .storyCard .lore{
      margin-top:8px;
      font-weight:750;
      color:rgba(238,242,255,.76);
      line-height:1.4;
    }

    
    /* Menu compacto */
    .menuCompact{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .menuHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:4px 2px;
    }
    .menuTitle{
      font-size:22px;
      font-weight:1200;
      letter-spacing:.2px;
      line-height:1.1;
      user-select:none;
    }
    .menuMeta{display:flex; flex-wrap:wrap; gap:6px; justify-content:flex-end;}
    .menuPlayBig{
      width:100%;
      padding:14px 16px;
      border-radius:16px;
      font-size:16px;
      font-weight:1200;
      letter-spacing:.6px;
      background:linear-gradient(180deg, rgba(124,255,178,.22), rgba(124,255,178,.10));
      border:1px solid rgba(124,255,178,.35);
      box-shadow: 0 14px 34px rgba(0,0,0,.28);
    }
    .menuPlayBig:hover{filter:brightness(1.06)}
    .menuGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .menuGrid button{
      padding:11px 12px;
      border-radius:14px;
    }
    @media (max-width: 720px){
      .menuHeader{flex-direction:column; align-items:flex-start;}
      .menuMeta{justify-content:flex-start;}
      .menuGrid{grid-template-columns: 1fr;}
    }
    button.danger{
      background:linear-gradient(180deg, rgba(255,106,106,.16), rgba(255,106,106,.08));
      border-color:rgba(255,106,106,.30);
    }
    button.danger:hover{filter:brightness(1.06)}
    .menuHint{
      font-size:12px;
      opacity:.82;
      padding:8px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
    }

/* Mapa */
    .campaignTabs{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;}
    .worlds{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
      gap:10px;
      margin-top:10px;
    }
    .world{
      border-radius:16px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .world .title{font-weight:1100;}
    .tag{display:inline-flex; align-items:center; gap:8px; font-weight:1000; font-size:12px; opacity:.9;}
    .tag .miniDot{width:9px;height:9px;border-radius:50%;}
    .world.locked{opacity:.55}
    .world button{width:100%;}

    /* Loadout (pr√©-fase) */
    .enemyRow{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;}
    .loadoutTop{margin-top:10px;}
    .loadoutSlots{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;}
    .slot{display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06); font-weight:1000; font-size:12px;}
    .slot.empty{opacity:.55;}
    .loadoutGrid{display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:10px; margin-top:10px;}
    .pickCard{border-radius:16px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06); padding:12px; display:flex; flex-direction:column; gap:8px; cursor:pointer; user-select:none;}
    .pickCard:hover{filter:brightness(1.06)}
    .pickCard.selected{outline:3px solid rgba(124,255,178,.38);}
    .pickHead{display:flex; align-items:center; gap:10px;}
    .pickIcon{width:42px;height:42px;border-radius:14px;display:grid;place-items:center;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.14);font-size:21px;}
    .pickMeta .pickName{font-weight:1100;}
    .pickMeta .pickDesc{font-weight:800; opacity:.78; font-size:12px;}
    .pickFoot{display:flex; align-items:center; justify-content:space-between; gap:8px;}
    .loadoutBtns{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;}

    /* Info (fichas) */
    .infoLayout{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:10px;
      margin-top:10px;
      min-height: min(62vh, 560px);
    }
    @media (max-width: 920px){
      .infoLayout{grid-template-columns: 1fr;}
    }
    .infoList{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.20);
      border-radius:16px;
      padding:10px;
      overflow:auto;
      max-height: min(62vh, 560px);
    }
    .infoItem{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);
      cursor:pointer;
      margin-bottom:8px;
      user-select:none;
    }
    .infoItem:hover{filter:brightness(1.06)}
    .infoItem.active{
      outline:3px solid rgba(124,255,178,.32);
      background:rgba(124,255,178,.10);
      border-color:rgba(124,255,178,.22);
    }
    .infoItem.locked{opacity:.55}
    .infoItem .ic{
      width:44px;height:44px;border-radius:16px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.08);
      display:grid;place-items:center;
      font-size:20px;
      flex:0 0 auto;
    }
    .infoItem .t1{font-weight:1100; font-size:13px}
    .infoItem .t2{font-weight:850; font-size:12px; opacity:.78; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .infoDetail{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
      border-radius:16px;
      padding:12px;
      overflow:auto;
      max-height: min(62vh, 560px);
    }
    .detailHead{
      display:flex; gap:12px; align-items:center; flex-wrap:wrap;
    }
    .detailIcon{
      width:58px;height:58px;border-radius:20px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
      display:grid;place-items:center;
      font-size:28px;
    }
    .detailTitle{
      font-size:18px;
      font-weight:1200;
      margin:0;
    }
    .detailSubtitle{
      margin:2px 0 0;
      font-weight:900;
      font-size:12px;
      opacity:.85;
    }
    .chips{display:flex; flex-wrap:wrap; gap:6px; margin-top:10px;}
    .chip{
      font-size:11px;
      font-weight:1100;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      opacity:.95;
      white-space:nowrap;
    }
    .chip.good{border-color:rgba(124,255,178,.30); background:rgba(124,255,178,.10)}
    .chip.warn{border-color:rgba(255,211,106,.30); background:rgba(255,211,106,.10)}
    .chip.bad{border-color:rgba(255,106,106,.30); background:rgba(255,106,106,.10)}
    .section{
      margin-top:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      border-radius:16px;
      padding:10px;
    }
    .section b{font-size:13px}
    .section p{margin:8px 0 0; font-weight:780; opacity:.85; line-height:1.4}
    .loreBox{
      margin-top:10px;
      padding:10px 12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.22);
      font-style:italic;
      color:rgba(238,242,255,.78);
      line-height:1.45;
      font-weight:760;
    }
  
    .buyRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
    .buyBtn{
      padding:10px 12px;border-radius:14px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(124,255,178,.18);
      color:rgba(255,255,255,.94);
      font-weight:900;cursor:pointer;
    }
    .buyBtn:hover{filter:brightness(1.08)}
    .buyBtn:disabled{opacity:.45;cursor:not-allowed;filter:none}
    .buyHint{font-size:12px;opacity:.78}

    /* Mobile helper: ask to rotate device to landscape */
    #rotateOverlay{
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background:rgba(0,0,0,.85);
      color:#fff;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      z-index:999999;
      text-align:center;
      padding:24px;
    }
    #rotateOverlay.show{ display:flex; }
    #rotateOverlay .box{
      max-width:520px;
      border:1px solid rgba(255,255,255,.18);
      border-radius:16px;
      padding:18px 16px;
      background:rgba(18,18,24,.55);
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    #rotateOverlay .ttl{ font-size:18px; font-weight:800; margin-bottom:6px; }
    #rotateOverlay .sub{ font-size:14px; opacity:.85; line-height:1.35; }
    

/* ================= Mobile/PWA fit ================= */
@media (max-width: 900px), (max-height: 620px){
  :root{
    --uiPad:0px;
    --uiPad2:0px;
    --shellW: 100%;
    --sideW: 100%;
  }
  .main{flex-direction:column; gap:10px;}

  /* top compacto: evita comer altura e cortar o jogo */
  .top{padding:8px 10px;}
  .brand{flex-wrap:nowrap; overflow-x:auto; -webkit-overflow-scrolling:touch; max-width:100%;}
  .brand::-webkit-scrollbar{display:none;}
  .btns{flex-wrap:nowrap; overflow-x:auto; -webkit-overflow-scrolling:touch; max-width:100%;}
  .btns::-webkit-scrollbar{display:none;}
  .pill{font-size:12px; padding:5px 8px;}
  button{font-size:12px; padding:7px 9px; border-radius:12px;}
  .btnSmall{font-size:12px; padding:7px 9px; border-radius:12px;}

  .side{
    width:100%;
    flex:0 0 auto;
    min-width:0;
    max-width:100%;
  }
  /* seedbank vira barra horizontal (melhor no celular) */
  .seedbank,
  .seedbank.multicol{
    display:flex;
    flex-direction:row;
    flex-wrap:nowrap;
    gap:10px;
    overflow-x:auto;
    overflow-y:hidden;
    max-height:150px;
    padding-right:0;
  }
  .seedbank.multicol .seed{ width:auto; }
  .seed{ min-width: 220px; }
  .side .small{display:none;}
  .zoomControls{ right:10px; top:10px; }
}

@media (max-height: 620px){
  .hint{display:none;}
  .top{padding:8px 10px;}
  .main{padding:8px; gap:10px;}
  .wavebar{padding:8px 10px;}
  .canvasWrap{padding:6px;}
}

/* melhora toque */
@media (pointer: coarse){
  button{ padding:8px 10px; }
  .btnSmall{ padding:8px 10px; font-size:13px; border-radius:12px; }
}

  </style>
</head>

<body>
<div class="wrap">
  <div class="shell">
    <div class="top">
      <div class="brand">
        <b>Botic√°rio Defense</b>
        <span class="pill"><span class="dot" id="dotStatus" style="background:var(--good)"></span><span id="statusText">Menu</span></span>
        <span class="pill"><span class="dot" style="background:var(--warn)"></span>Aromas: <span id="aromaText">0</span></span>
          <span class="pill"><span class="dot" style="background:#FFD36A"></span>Moedas: <span id="coinText">0</span></span>
        <span class="pill"><span class="dot" style="background:rgba(183,195,255,.95)"></span>Mundo: <span id="worldText">‚Äî</span></span>
      </div>
      <div class="btns">
        <button id="btnMenu">Menu</button>
        <button id="btnMap">Mapa</button>
        <button id="btnInfo">Info</button>
                <button id="btnDebug">Debug</button>
<button id="btnSound">Som: ON</button>
        <button id="btnPause">Pausar</button>
        <button id="btnRestart">Reiniciar Mundo</button>
      </div>
    </div>

    <div class="main">
      <div class="side">
        <div class="sideHeader">
          <b>Perfumes</b>
          <span class="hintTiny">Clique de novo = desmarcar</span>
        </div>
        <div class="seedbank" id="seedbank"></div>
        <div class="small" style="opacity:.85; line-height:1.3;">
          <b>Dicas:</b> segure o bot√£o esquerdo e arraste para coletar fragr√¢ncias.
          <br> <kbd>ESC</kbd> cancela sele√ß√£o ‚Ä¢ <kbd>I</kbd> abre Info
        </div>
      </div>

      <div class="play">
        <div class="wavebar">
          <b>Progress√£o</b>
          <div class="bar">
            <div class="barFill" id="barFill"></div>
            <div class="barNodes" id="barNodes"></div>
          </div>
          <div class="waveRight" id="waveText">0/0</div>
        </div>

        <div class="canvasWrap">
          <div class="zoomControls">
            <div class="zoomPill">
              <button class="btnSmall" id="zoomIn">+</button>
              <div class="zoomPct" id="zoomText">112%</div>
              <button class="btnSmall" id="zoomOut">‚àí</button>
            </div>
          </div>
          <canvas id="game" width="960" height="720"></canvas>
        </div>
      </div>
    </div>

    <div class="hint">
      <div>
        <b>Controles:</b> selecione um perfume e solte no gramado.
        <b>Coleta:</b> segure o bot√£o esquerdo e arraste por cima das fragr√¢ncias.
        <span style="margin-left:10px">
          Atalhos: <kbd>Espa√ßo</kbd> pausar, <kbd>R</kbd> reiniciar, <kbd>M</kbd> mapa, <kbd>I</kbd> info, <kbd>ESC</kbd> desmarcar.
        </span>
      </div>
    </div>

    <div class="overlay" id="overlay">
      <div class="modal">
        <div class="modalHead">
          <div>
            <h2 id="overlayTitle">Menu</h2>
            <div class="small" id="overlayDesc"></div>
          </div>
          <div class="tabs">
            <button class="tabBtn" id="tabMenu">Menu</button>
            <button class="tabBtn" id="tabMap">Mapa</button>
            <button class="tabBtn" id="tabInfo">Info</button>
          </div>
        </div>

        <div id="overlayBody"></div>

        <div class="rowBtns">
          <button id="btnCloseOverlay">Fechar</button>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
(() => {
  // ================= DOM =================
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  // iOS/Android: estabiliza altura real (evita "corte" quando a barra do navegador some/aparece)
  function setVh(){
    document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`);
  }
  setVh();
  window.addEventListener('resize', setVh, {passive:true});
  window.addEventListener('orientationchange', ()=>setTimeout(setVh, 250), {passive:true});


const errBox = document.createElement("div");
errBox.style.position = "fixed";
errBox.style.left = "12px";
errBox.style.bottom = "12px";
errBox.style.maxWidth = "calc(100% - 24px)";
errBox.style.padding = "10px 12px";
errBox.style.borderRadius = "12px";
errBox.style.background = "rgba(0,0,0,.78)";
errBox.style.border = "1px solid rgba(255,255,255,.18)";
errBox.style.color = "#fff";
errBox.style.font = "12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial";
errBox.style.zIndex = "99999";
errBox.style.display = "none";
errBox.style.whiteSpace = "pre-wrap";
document.body.appendChild(errBox);

function showFatalError(err){
  const msg = (err && (err.stack || err.message)) ? String(err.stack || err.message) : String(err);
  console.error(err);
  errBox.textContent = "‚ö†Ô∏è Erro no jogo:\n" + msg;
  errBox.style.display = "block";
  // evita congelar o loop por exceptions repetidas
  running = false;
  paused = false;
  won = false;
  lost = false;
  mode = "menu";
  try{ showOverlay("menu"); }catch(_e){}
}

window.addEventListener("error", (e)=>{ showFatalError(e.error || e.message || e); });
window.addEventListener("unhandledrejection", (e)=>{ showFatalError(e.reason || e); });


  // ================= Debug box =================
  const dbgBox = document.createElement("div");
  dbgBox.style.position = "fixed";
  dbgBox.style.right = "12px";
  dbgBox.style.bottom = "12px";
  dbgBox.style.maxWidth = "calc(100% - 24px)";
  dbgBox.style.width = "360px";
  dbgBox.style.padding = "10px 12px";
  dbgBox.style.borderRadius = "12px";
  dbgBox.style.background = "rgba(0,0,0,.80)";
  dbgBox.style.border = "1px solid rgba(255,255,255,.18)";
  dbgBox.style.color = "#fff";
  dbgBox.style.font = "12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial";
  dbgBox.style.zIndex = "99998";
  dbgBox.style.display = "none";
  dbgBox.style.whiteSpace = "pre-wrap";
  dbgBox.innerHTML = `
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:6px;">
      <b>Debug</b>
      <div style="display:flex; gap:6px;">
        <button id="dbgRefresh" style="cursor:pointer; border-radius:10px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.08); color:#fff; padding:6px 10px;">Atualizar</button>
        <button id="dbgClose" style="cursor:pointer; border-radius:10px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.08); color:#fff; padding:6px 10px;">Fechar</button>
      </div>
    </div>
    <pre id="dbgPre" style="margin:0; white-space:pre-wrap;"></pre>
  `;
  document.body.appendChild(dbgBox);
  const dbgPre = dbgBox.querySelector("#dbgPre");
  dbgBox.querySelector("#dbgClose").addEventListener("click", ()=>{ dbgBox.style.display="none"; });
  dbgBox.querySelector("#dbgRefresh").addEventListener("click", ()=>{ dbgPre.textContent = getDebugState(); });

  function getDebugState(){
    try{
      const campId = (typeof currentCampaign !== "undefined" && currentCampaign) ? currentCampaign.id : "‚Äî";
      const wId = (typeof currentWorld !== "undefined" && currentWorld) ? currentWorld.id : "‚Äî";
      const wName = (typeof currentWorld !== "undefined" && currentWorld) ? (currentWorld.name||"") : "";
      const eTotal = (typeof enemies !== "undefined" && enemies) ? enemies.length : 0;
      const eAlive = (typeof enemies !== "undefined" && enemies) ? enemies.filter(e=>e && e.alive).length : 0;
      const projN = (typeof projectiles !== "undefined" && projectiles) ? projectiles.length : 0;
      const fxN = (typeof fxs !== "undefined" && fxs) ? fxs.length : 0;
      const coins = (typeof progress !== "undefined" && progress) ? (progress.currency||0) : 0;
      const aromas = (typeof aroma !== "undefined") ? aroma : 0;
      const specialN = (typeof progress !== "undefined" && progress && progress.specialOwned && typeof progress.specialOwned.size==="number") ? progress.specialOwned.size : 0;
      const perkObj = (typeof progress !== "undefined" && progress && progress.perks) ? progress.perks : {};
      const perkStr = JSON.stringify(perkObj);
      const loadMax = (typeof getLoadoutMax==="function") ? getLoadoutMax() : "‚Äî";
      return [
        `mode=${(typeof mode!=="undefined")?mode:"?"} running=${(typeof running!=="undefined")?running:"?"} paused=${(typeof paused!=="undefined")?paused:"?"}`,
        `overlay=${(typeof overlayMode!=="undefined")?overlayMode:"?"} selected=${(typeof selectedId!=="undefined")?(selectedId||"‚Äî"):"?"}`,
        `campaign=${campId} world=${wId} ${wName}`,
        `wave=${(typeof waveIndex!=="undefined")?waveIndex:"‚Äî"} gameTime=${(typeof gameTime!=="undefined")?gameTime.toFixed(2):"‚Äî"}`,
        `enemies=${eAlive}/${eTotal} projectiles=${projN} fx=${fxN}`,
        `aromas=${aromas} coins=${coins} specialOwned=${specialN}`,
        `loadoutMax=${loadMax}`,
        `perks=${perkStr}`
      ].join("\n");
    }catch(err){
      return "Debug indispon√≠vel: " + (err && (err.stack||err.message) ? (err.stack||err.message) : String(err));
    }
  }

  function toggleDebugBox(){
    if(dbgBox.style.display==="none"){
      dbgPre.textContent = getDebugState();
      dbgBox.style.display = "block";
    }else{
      dbgBox.style.display = "none";
    }
  }


  const statusText = document.getElementById("statusText");
  const dotStatus = document.getElementById("dotStatus");
  const aromaText = document.getElementById("aromaText");
  const coinText = document.getElementById("coinText");
  const worldText = document.getElementById("worldText");
  const waveText = document.getElementById("waveText");

  const seedbank = document.getElementById("seedbank");
  const btnPause = document.getElementById("btnPause");
  const btnRestart = document.getElementById("btnRestart");
  const btnMenu = document.getElementById("btnMenu");
  const btnMap = document.getElementById("btnMap");
  const btnInfo = document.getElementById("btnInfo");
  const btnDebug = document.getElementById("btnDebug");
  if(btnDebug){ btnDebug.addEventListener("click", ()=>{ try{ toggleDebugBox(); }catch(err){ showFatalError(err); } }); }
  const btnSound = document.getElementById("btnSound");

  const overlay = document.getElementById("overlay");
  const overlayTitle = document.getElementById("overlayTitle");
  const overlayDesc = document.getElementById("overlayDesc");
  const overlayBody = document.getElementById("overlayBody");
  const btnCloseOverlay = document.getElementById("btnCloseOverlay");

  const tabMenu = document.getElementById("tabMenu");
  const tabMap = document.getElementById("tabMap");
  const tabInfo = document.getElementById("tabInfo");

  const barFill = document.getElementById("barFill");
  const barNodes = document.getElementById("barNodes");

  const zoomInBtn = document.getElementById("zoomIn");
  const zoomOutBtn = document.getElementById("zoomOut");
  const zoomText = document.getElementById("zoomText");

  // ================= Base (4:3) =================
  const BASE_W = 960, BASE_H = 720;
  const ROWS = 5, COLS = 9;

  const GRID_X = 130;
  const GRID_Y = 190;
  const CELL_W = 70;
  const CELL_H = 86;
  const GRID_W = COLS * CELL_W;
  const GRID_H = ROWS * CELL_H;

  const SPAWN_X = GRID_X + GRID_W + 120;
  const LEFT_FAIL_X = GRID_X - 90;

  // ===== Pace (Waves mais longas) =====
  const WAVE_TIME_SCALE = 1.38;  // <- principal ajuste: alonga o mundo todo
  const SPAWN_THROTTLE_EXTRA_REST = 0.20; // pequena folga depois de bursts

  // Aroma/orbs
  const ORB_R = 24;
  const ORB_HIT_R = 34;
  const ORB_CLICK_R2 = ORB_HIT_R * ORB_HIT_R;
  const MAX_ORBS_ON_SCREEN = 7;

  const COIN_R = 18;
  const COIN_HIT_R = 30;
  const COIN_CLICK_R2 = COIN_HIT_R * COIN_HIT_R;
  const MAX_COINS_ON_SCREEN = 10;

  // Helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const irand = (a,b)=>Math.floor(rand(a,b+1));
  const fract = (v)=>v - Math.floor(v);

  function rgba(hex, a){
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  function toBaseCoords(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    return {
      x: (clientX - r.left) / r.width * BASE_W,
      y: (clientY - r.top) / r.height * BASE_H
    };
  }

  function cellAt(x,y){
    if(x < GRID_X || x > GRID_X+GRID_W || y < GRID_Y || y > GRID_Y+GRID_H) return null;
    const col = Math.floor((x - GRID_X) / CELL_W);
    const row = Math.floor((y - GRID_Y) / CELL_H);
    if(row<0||row>=ROWS||col<0||col>=COLS) return null;
    return {row,col};
  }

  function cellCenter(row,col){
    return {
      x: GRID_X + col*CELL_W + CELL_W/2,
      y: GRID_Y + row*CELL_H + CELL_H/2
    };
  }

  function rr(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }


  // ================= SFX (WebAudio, sem arquivos externos) =================
  const SFX = (()=>{
    let ctx = null;
    let master = null;
    let enabled = true;
    const last = new Map();

    function ensure(){
      if(ctx) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      if(!AC) return;
      ctx = new AC();
      master = ctx.createGain();
      master.gain.value = 0.55;
      master.connect(ctx.destination);
    }

    function unlock(){
      try{
        ensure();
        if(ctx && ctx.state === 'suspended') ctx.resume();
      }catch(_e){}
    }

    function canPlay(key, minGap=0.06){
      if(!ctx) ensure();
      if(!ctx) return false;
      const t = ctx.currentTime;
      const prev = last.get(key) || -999;
      if(t - prev < minGap) return false;
      last.set(key, t);
      return true;
    }

    function tone(freq, dur, {type='sine', vol=0.12, detune=0, when=0, slideTo=null}={}){
      if(!enabled) return;
      ensure();
      if(!ctx) return;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, ctx.currentTime + when);
      if(slideTo!=null) o.frequency.exponentialRampToValueAtTime(slideTo, ctx.currentTime + when + Math.max(0.02, dur));
      o.detune.setValueAtTime(detune, ctx.currentTime + when);
      g.gain.setValueAtTime(0.0001, ctx.currentTime + when);
      g.gain.exponentialRampToValueAtTime(Math.max(0.0001, vol), ctx.currentTime + when + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + when + dur);
      o.connect(g);
      g.connect(master);
      o.start(ctx.currentTime + when);
      o.stop(ctx.currentTime + when + dur + 0.02);
    }

    function noise(dur, {vol=0.10, when=0, hp=600}={}){
      if(!enabled) return;
      ensure();
      if(!ctx) return;
      const n = Math.max(1, Math.floor(ctx.sampleRate * dur));
      const buf = ctx.createBuffer(1, n, ctx.sampleRate);
      const data = buf.getChannelData(0);
      for(let i=0;i<n;i++){
        const env = 1 - i/n;
        data[i] = (Math.random()*2-1) * env;
      }
      const src = ctx.createBufferSource();
      src.buffer = buf;
      const g = ctx.createGain();
      g.gain.setValueAtTime(vol, ctx.currentTime + when);
      const f = ctx.createBiquadFilter();
      f.type = 'highpass';
      f.frequency.setValueAtTime(hp, ctx.currentTime + when);
      src.connect(f);
      f.connect(g);
      g.connect(master);
      src.start(ctx.currentTime + when);
      src.stop(ctx.currentTime + when + dur + 0.02);
    }

    function play(name){
      if(!enabled) return;
      unlock();
      if(!ctx) return;

      switch(name){
        case 'ui':
          if(!canPlay('ui', 0.03)) return;
          tone(640, 0.045, {type:'square', vol:0.10});
          tone(920, 0.030, {type:'sine', vol:0.06, when:0.015});
          break;
        case 'select':
          if(!canPlay('select', 0.04)) return;
          tone(520, 0.055, {type:'triangle', vol:0.10});
          tone(780, 0.040, {type:'triangle', vol:0.08, when:0.02});
          break;
        case 'plant':
          if(!canPlay('plant', 0.04)) return;
          tone(260, 0.070, {type:'sine', vol:0.10, slideTo:180});
          noise(0.05, {vol:0.03, hp:900, when:0.01});
          break;
        case 'shovel':
          if(!canPlay('shovel', 0.05)) return;
          noise(0.08, {vol:0.06, hp:700});
          tone(220, 0.060, {type:'square', vol:0.06, when:0.01});
          break;
        case 'shoot':
          if(!canPlay('shoot', 0.055)) return;
          tone(820, 0.030, {type:'square', vol:0.07});
          break;
        case 'shootSlow':
          if(!canPlay('shootSlow', 0.055)) return;
          tone(720, 0.030, {type:'triangle', vol:0.07});
          tone(520, 0.030, {type:'triangle', vol:0.05, when:0.012});
          break;
        case 'spray':
          if(!canPlay('spray', 0.11)) return;
          noise(0.09, {vol:0.06, hp:1300});
          tone(540, 0.060, {type:'sine', vol:0.05, when:0.01});
          break;
        case 'beamTick':
          if(!canPlay('beamTick', 0.12)) return;
          tone(980, 0.020, {type:'sine', vol:0.045});
          break;
        case 'purify':
          if(!canPlay('purify', 0.16)) return;
          tone(1040, 0.060, {type:'triangle', vol:0.08, slideTo:720});
          noise(0.06, {vol:0.05, hp:1600, when:0.01});
          break;
        case 'heal':
          if(!canPlay('heal', 0.18)) return;
          tone(660, 0.060, {type:'sine', vol:0.08, slideTo:920});
          tone(1200, 0.040, {type:'sine', vol:0.05, when:0.02});
          break;
        case 'buff':
          if(!canPlay('buff', 0.20)) return;
          tone(420, 0.045, {type:'triangle', vol:0.08});
          tone(640, 0.060, {type:'triangle', vol:0.07, when:0.018});
          break;
        case 'shieldUp':
          if(!canPlay('shieldUp', 0.20)) return;
          tone(520, 0.055, {type:'sine', vol:0.07});
          tone(880, 0.080, {type:'sine', vol:0.06, when:0.015});
          break;
        case 'shieldHit':
          if(!canPlay('shieldHit', 0.08)) return;
          tone(760, 0.030, {type:'square', vol:0.05});
          break;
        case 'shieldBreak':
          if(!canPlay('shieldBreak', 0.18)) return;
          noise(0.11, {vol:0.06, hp:1200});
          tone(360, 0.070, {type:'sawtooth', vol:0.05, slideTo:220});
          break;
        case 'trapArm':
          if(!canPlay('trapArm', 0.25)) return;
          tone(600, 0.060, {type:'triangle', vol:0.08});
          tone(820, 0.060, {type:'triangle', vol:0.06, when:0.03});
          break;
        case 'trapBoom':
          if(!canPlay('trapBoom', 0.25)) return;
          noise(0.10, {vol:0.08, hp:900});
          tone(180, 0.080, {type:'sine', vol:0.08, slideTo:110});
          break;
        case 'boom':
          if(!canPlay('boom', 0.25)) return;
          noise(0.12, {vol:0.09, hp:700});
          tone(140, 0.090, {type:'sine', vol:0.10, slideTo:90});
          break;
        case 'enemyDie':
          if(!canPlay('enemyDie', 0.06)) return;
          tone(260, 0.045, {type:'square', vol:0.05, slideTo:200});
          noise(0.05, {vol:0.03, hp:800});
          break;
        case 'bossDie':
          if(!canPlay('bossDie', 0.40)) return;
          noise(0.18, {vol:0.10, hp:600});
          tone(120, 0.160, {type:'sawtooth', vol:0.09, slideTo:70});
          break;
        case 'count3':
          if(!canPlay('count', 0.12)) return;
          tone(500, 0.060, {type:'square', vol:0.08});
          break;
        case 'count2':
          if(!canPlay('count', 0.12)) return;
          tone(620, 0.060, {type:'square', vol:0.08});
          break;
        case 'count1':
          if(!canPlay('count', 0.12)) return;
          tone(760, 0.060, {type:'square', vol:0.08});
          break;
        case 'go':
          if(!canPlay('go', 0.40)) return;
          tone(900, 0.090, {type:'triangle', vol:0.10});
          tone(1200, 0.090, {type:'triangle', vol:0.08, when:0.06});
          break;
        case 'lastHorde':
          if(!canPlay('lastHorde', 0.80)) return;
          tone(320, 0.090, {type:'square', vol:0.10});
          tone(480, 0.090, {type:'square', vol:0.09, when:0.08});
          tone(720, 0.090, {type:'square', vol:0.08, when:0.16});
          break;
      }
    }

    function setEnabled(v){ enabled = !!v; }
    function isEnabled(){ return enabled; }

    return { unlock, play, setEnabled, isEnabled };
  })();

  // desbloqueia o √°udio no primeiro gesto do usu√°rio
  document.addEventListener('pointerdown', ()=>SFX.unlock(), {once:true});
  // som de bot√£o (qualquer <button>)
  document.addEventListener('click', (ev)=>{
    const b = ev.target.closest && ev.target.closest('button');
    if(b && !b.disabled) SFX.play('ui');
  }, true);

  // ================= Lore / Fragr√¢ncias (Orbs) =================
  const AromaTypes = {
    gold: {
      id:"gold", name:"Fragr√¢ncia Dourada", icon:"‚ú®", value:25, tint:"#FFD36A",
      how:"Moeda principal. Use para plantar perfumes.",
      lore:"Uma gota dourada que aparece quando o ambiente fica‚Ä¶ levemente mais cheirosinho do que deveria."
    },
    crystal: {
      id:"crystal", name:"Fragr√¢ncia Cristal", icon:"üíé", value:25, tint:"#9FFFD8",
      how:"Ao coletar, desacelera todos os mal cheiros por alguns segundos.",
      lore:"Reflexos frios num ar limpo. Dizem que ela ‚Äòtrava‚Äô a bruma por um instante.",
      onCollect: () => { globalBuffs.enemySlowAllT = Math.max(globalBuffs.enemySlowAllT, 2.8); }
    },
    espresso: {
      id:"espresso", name:"Fragr√¢ncia Espresso", icon:"‚òï", value:25, tint:"#D7A0FF",
      how:"Ao coletar, reduz um pouco os cooldowns (d√° aquele g√°s de planejamento).",
      lore:"Um caf√© forte em forma de aroma. A mente acelera ‚Äî e as m√£os plantam mais certeiro.",
      onCollect: () => { reduceAllCooldowns(0.9); }
    },
    botik: {
      id:"botik", name:"Fragr√¢ncia Botik", icon:"üíö", value:25, tint:"#7CFFB2",
      how:"Ao coletar, cura um pouco todas as plantas do gramado.",
      lore:"Quando um cheiro bom vira cuidado. Pequeno, mas salva composi√ß√µes inteiras.",
      onCollect: () => { healAllPlants(16); }
    },
    prism: {
      id:"prism", name:"Fragr√¢ncia Prisma", icon:"üîÆ", value:25, tint:"#A9B6FF",
      how:"Ao coletar, fortalece o Purificador por alguns segundos.",
      lore:"Um foco de luz que ‚Äòorganiza‚Äô o caos. Perfeito pra quando o miasma acha que manda.",
      onCollect: () => { globalBuffs.beamBoostT = Math.max(globalBuffs.beamBoostT, 4.0); }
    },
    crown: {
      id:"crown", name:"Fragr√¢ncia Coroa", icon:"üëë", value:50, tint:"#FF6A6A",
      how:"Uma super-fragr√¢ncia rara: vale mais e d√° um empurr√£o t√°tico (cura + mini slow).",
      lore:"S√≥ aparece quando a bruma fica arrogante demais. O ar responde com autoridade.",
      onCollect: () => { healAllPlants(12); globalBuffs.enemySlowAllT = Math.max(globalBuffs.enemySlowAllT, 2.0); }
    }
  };

  // ================= Plants =================
  const PlantDefs = [
    { id:"sun", icon:"‚ú®", name:"Ess√™ncia Lily", desc:"Gera fragr√¢ncias", cost:50, cooldown:5, hp:260, kind:"sun",
      genRate:9.0, genValue:22, tint:"#FFEFA8",
      lore:"Uma ess√™ncia delicada que ‚Äòpuxa‚Äô pequenas gotas do ar ‚Äî como se o ambiente te ajudasse a planejar." },

    { id:"shooter", icon:"üíß", name:"Floratta Splash", desc:"Tiro r√°pido", cost:100, cooldown:4, hp:230, kind:"shooter",
      fireRate:1.25, dmg:24, projSpeed:330, tint:"#8DE1FF",
      lore:"Um perfume direto, honesto e constante. Uma linha cheirosa bem colocada muda tudo." },

    { id:"cone", icon:"üå¨Ô∏è", name:"Glamour Spray", desc:"Cone curto", cost:125, cooldown:6, hp:240, kind:"cone",
      fireRate:2.1, dmg:10, range:220, hits:3, tint:"#FF79C6",
      lore:"Quando a bruma vem em grupo, o Glamour n√£o discute: ele espalha presen√ßa e organiza a rua." },

    { id:"wall", icon:"üõ°Ô∏è", name:"Malbec Guard", desc:"Barreira", cost:50, cooldown: 13, hp:1000, kind:"wall", tint:"#3A2318",
      lore:"Um guardi√£o silencioso. N√£o ataca ‚Äî mas segura a linha quando o resto ainda est√° sendo plantado." },

    { id:"slow", icon:"üßä", name:"Egeo Mint", desc:"Dano + lento", cost:125, cooldown:6, hp:230, kind:"slow",
      fireRate:1.9, dmg:12, slowMult:0.55, slowTime:2.8, projSpeed:310, tint:"#A9B6FF",
      lore:"Um frio elegante que deixa o miasma ‚Äòpensando‚Äô antes de dar o pr√≥ximo passo." },

    { id:"healer", icon:"üíö", name:"Botik Breeze", desc:"Cura adjacentes", cost:150, cooldown:9, hp:260, kind:"healer",
      healRate:3.2, healAmount:18, tint:"#7CFFB2",
      lore:"Cuidado cont√≠nuo. Ele n√£o salva uma planta por vez ‚Äî ele mant√©m a forma√ß√£o viva." },

    { id:"bomb", icon:"üí•", name:"Quasar Boom", desc:"Explode na faixa", cost:175, cooldown: 13, hp:9999, kind:"bomb",
      fuse:0.6, dmg:210, tint:"#FF9A6A",
      lore:"Um brilho curto e decisivo. Perfeito para ‚Äòresetar‚Äô uma linha que j√° estava no limite." },

    { id:"beam", icon:"üî¶", name:"Purificador", desc:"Raio (DPS)", cost:200, cooldown:12, hp:260, kind:"beam",
      tickRate:0.2, dps:40, range:480, tint:"#9FFFD8",
      batteryRegen:12, batteryDrain: 0.038, purifyAOE:78,
      batteryPulseEvery:5, batteryPulseAmount:0.25, batteryPulseAmountBoost:0.40,
      lore:"A √∫ltima palavra contra bruma reativa. Ele n√£o discute: ele limpa." },

    /* === P√ìS-HIST√ìRIA (Campanha 2) === */
    { id:"prismLens", icon:"üîÆ", name:"Elys√©e Prisma", desc:"Refrata Purificador", cost:125, cooldown:8, hp:260, kind:"lens",
      tint:"#A9B6FF",
      lore:"Um prisma de luxo: quando o Purificador atravessa, a luz se multiplica e ‚Äòacha‚Äô outras linhas." },

    { id:"coffeeTrap", icon:"‚òï", name:"Coffee Armadilha", desc:"Stun + lento", cost: 50, cooldown: 12, hp:300, kind:"trap",
      armTime:6.0,
      triggerDmg:240, splashDmg:120, stun:2.6, tint:"#D7A0FF",
      postSlowMult:0.55, postSlowTime:2.8,
      lore:"Um golpe de energia: pega o miasma no susto, para tudo ‚Äî e deixa espa√ßo para estrat√©gia." },

    { id:"arboBoost", icon:"üå≤", name:"Arbo Booster", desc:"Buff em adjacentes", cost:175, cooldown:10, hp:260, kind:"booster",
      pulse:0.7, buffTime:3.0, fireMult:0.70, dmgMult:1.15, tint:"#7CFFB2",
      lore:"Onde ele est√°, a composi√ß√£o fica ‚Äòviva‚Äô: o ataque encaixa mais r√°pido e com mais presen√ßa." },

    { id:"nativaClean", icon:"ü´ß", name:"Nativa Clean", desc:"Escudo de espuma", cost:150, cooldown:12, hp:260, kind:"cleanser",
      pulse:4.2, heal:6, shieldAdd:55, shieldCap:120, shieldTime:7.0, popKnock:26, popRange:160, tint:"#8DE1FF",
      lore:"Espuma protetora: tira o peso do ar e devolve f√¥lego pra sua forma√ß√£o." },

    { id:"kaiakSal", icon:"üßÇ", name:"Kaiak Sal", desc:"Marca (saliniza)", cost:150, cooldown:7, hp:240, kind:"shooter",
      fireRate:1.55, dmg:16, projSpeed:320, tint:"#B7F2FF",
      salt:{ time:5.0 },
      lore:"Cristais de sal no ar: n√£o derruba sozinho ‚Äî mas ‚Äòabre‚Äô o lacre do miasma para o resto finalizar." },

    { id:"zaadCat", icon:"‚öóÔ∏è", name:"Zaad Catalisador", desc:"Catalisa adjacentes", cost:175, cooldown:11, hp:255, kind:"booster",
      pulse:1.1, cataTime:4.6, tint:"#FFD36A",
      lore:"Um reagente que faz as composi√ß√µes ‚Äòpegarem‚Äô. N√£o √© for√ßa bruta ‚Äî √© qu√≠mica trabalhando a seu favor." },

    { id:"ekosResin", icon:"üü†", name:"Ekos Resina", desc:"Marca (resina)", cost:175, cooldown:8, hp:240, kind:"shooter",
      fireRate:2.10, dmg:28, projSpeed:290, tint:"#FFB36A",
      resin:{ time:6.0, mult:0.86 },
      lore:"Uma resina que gruda no miasma e quebra isolamentos. Quando pega, o campo inteiro sente a diferen√ßa." },


    // === ESPECIAIS (Loja por ü™ô moedas) ===
    { id:"cremeLily", icon:"üå∏", name:"Creme Lily", desc:"Duas fragr√¢ncias", cost:200, cooldown:10, hp:260, kind:"sun",
      genRate:10.62, twin:2, tint:"#FFE0F0",
      lore:"Um cuidado que rende em dobro: gera duas fragr√¢ncias por ciclo para acelerar sua economia." },

    { id:"lizAura", icon:"üíõ", name:"Liz Aura", desc:"Healer poderoso", cost:220, cooldown:12, hp:320, kind:"healer",
      healRate:2.2, healAmount:42, tint:"#FFD200",
      lore:"Uma aura de cuidado mais intensa: mant√©m tanques e DPS vivos quando o jogo vira caos." },


    { id:"quasarFire", icon:"üî•", name:"Quasar Fire", desc:"Tiro flamejante", cost:225, cooldown:10, hp:260, kind:"shooter",
      fireRate:1.35, dmg:26, projSpeed:340, tint:"#FF6A3D", projTint:"#FF6A3D",
      burn:{ dps:10, time:4.0 },
      lore:"Um disparo quente que ‚Äògruda‚Äô no miasma. N√£o √© s√≥ impacto ‚Äî √© fogo trabalhando depois." },

    { id:"florattaDuplo", icon:"üíû", name:"Floratta Duplo", desc:"Tiro duplo", cost:225, cooldown:8, hp:260, kind:"shooter",
      fireRate:0.9, dmg:22, projSpeed:340, tint:"#FF8AD6",
      doubleShot:true,
      lore:"Dois acordes na mesma batida. Press√£o constante e elegante." },



    { id:"malbecLegend", icon:"üß±", name:"Malbec Legend", desc:"Parede super resistente", cost:135, cooldown:22, hp:2400, kind:"wall", tint:"#1F120C",
      lore:"Um muro lend√°rio. Quando tudo aperta, ele n√£o cede ‚Äî ele imp√µe presen√ßa." },

    { id:"refil", icon:"‚ôªÔ∏è", name:"Refil", desc:"Up + cura", cost:160, cooldown:9, hp:1, kind:"refil",
      upMax:3, upMul:1.18,
      tint:"#7CFFB2",
      lore:"Uma recarga inteligente: melhora o frasco alvo (+dano, +vida m√°xima) e devolve parte do vigor instantaneamente." },

    { id:"egeoBombBlack", icon:"üí£", name:"Egeo Bomb Black", desc:"Explos√£o total + cratera", cost:260, cooldown:28, hp:9999, kind:"bomb",
      fuse:1.2, dmg:1600, blastRadius:240, lockTime:60, doom:true, tint:"#1C1C26",
      lore:"Um sil√™ncio pesado... e ent√£o o vazio. Limpa tudo num raio grande e deixa uma cratera onde nada cresce por um tempo." },


    { id:"casa214", icon:"üè†", name:"Casa 214", desc:"2s ‚Üí STUN global + SLOW curto (one-shot)", cost:170, cooldown:26, hp:220, kind:"globalTrap",
      delay:2.0, stun:2.2, postSlowTime:2.8, postSlowMult:0.55, tint:"#A9B6FF",
      lore:"Uma casa que ‚Äòfecha‚Äô o mapa por um instante: paralisa tudo e desacelera o avan√ßo antes de sumir." },

    { id:"botikMagnet", icon:"üß≤", name:"Botik Magnet", desc:"Puxa e coleta a moeda mais pr√≥xima", cost:110, cooldown:12, hp:260, kind:"magnet",
      pullCooldown:5.0, pullSpeed:150, tint:"#D7A0FF",
      lore:"Atra√ß√£o irresist√≠vel: traz a moeda at√© voc√™ e coleta automaticamente." },



    { id:"customPerfume", icon:"üß™", name:"Perfume Customizado", desc:"Voc√™ cria o seu", cost:180, cooldown:10, hp:260, kind:"shooter",
      fireRate:1.25, dmg:24, projSpeed:330, tint:"#8DE1FF",
      custom:true,
      lore:"Um frasco em branco. Voc√™ escolhe a fun√ß√£o, o visual e a for√ßa ‚Äî pagando o pre√ßo no custo e no cooldown." },

    /* === EXTRAS (P√≥s-Game / Loja futura) === */
    { id:"lunaNova", icon:"üåô", name:"Luna Nova", desc:"Atira e causa dano em √°rea", cost:225, cooldown:11, hp:250, kind:"shooter",
      fireRate:2.20, dmg:48, projSpeed:300, tint:"#D7A0FF",
      projTint:"#D7A0FF",
      splash:{ radius:88, mult:0.48 },
      lore:"Um disparo pesado que estoura em microgotas no impacto. √ìtimo para segurar enxames quando a sobreviv√™ncia ficar s√©ria." },

    { id:"glamourVortex", icon:"üåÄ", name:"Glamour V√≥rtice", desc:"Cone amplo", cost:200, cooldown:9, hp:255, kind:"cone",
      fireRate:1.75, dmg:12, range:280, hits:5, tint:"#FF79C6",
      lore:"Um spray que ‚Äòvarre‚Äô a linha: menos foco, mais controle de volume. Perfeito quando o jogo sobe o ritmo." },

    { id:"prismaSupreme", icon:"üí†", name:"Prisma Supreme", desc:"Amplifica o Purificador", cost:175, cooldown:10, hp:260, kind:"lens",
      tint:"#A9B6FF",
      beamMult:1.18, splitMult:0.60,
      lore:"Um prisma raro que n√£o s√≥ refrata: ele amplifica o feixe e d√° mais presen√ßa ao dano refratado." },


    { id:"shovel", icon:"üßπ", name:"P√°", desc:"Remove planta", cost:0, cooldown:0, hp:0, kind:"tool", tint:"#eef2ff",
      lore:"Sem drama: errou o encaixe, remove e replaneja." }
  ];

  
  // ================= Loja (Perfumes especiais) =================
  // Especiais N√ÉO podem ser liberados por cheat (LIBERATUDO/UNLOCKALL). Apenas por compra com ü™ô moedas.
  const SPECIAL_SHOP = {
    // especiais originais
    lunaNova:      { price: 180 },
    glamourVortex: { price: 160 },
    prismaSupreme: { price: 170 },

    // especiais adicionados
    cremeLily:     { price: 200 },
    lizAura:       { price: 200 },
    quasarFire:    { price: 220 },
    florattaDuplo: { price: 210 },

    malbecLegend:  { price: 260 },
    refil:         { price: 120 },
    egeoBombBlack: { price: 280 },

    casa214:       { price: 240 },
    botikMagnet:   { price: 160 },
    customPerfume: { price: 260 },
  };

  function isSpecialPlant(id){ return !!(id && SPECIAL_SHOP[id]); }
const plantById = new Map(PlantDefs.map(p=>[p.id,p]));


  // ================= Perfume Customizado (meta-especial) =================
  function defaultCustomPerfumeCfg(){
    return {
      name: "Perfume Customizado",
      icon: "üß™",
      label: "CUSTOM",
      kind: "shooter",   // shooter | wall | healer | slow | beam | charge | homing | cone | bomb | infuse
      strength: 5,       // 1..10
      bottleKey: "presetDrop",
      bottleTint: "#8DE1FF",
      projTint: "#8DE1FF",
      shotCount: 1,      // 1..5 (shooter/slow)
      effect: "none",    // none | fire | poison | frost | resin | stun (shooter/slow)

      // Cad√™ncia manual (shooter/slow/homing)
      cadenceMode: "auto",  // auto | manual
      cadence: 1.20,        // 0.40..3.00 (s) ‚Äî usado quando cadenceMode=manual

      // Etapa 10 (Charge Shot)
      chargeTime: 1.8,  // 0.8..3.0 (s) ‚Äî quando pronto, clique no perfume para atirar

      // Etapa 12 (Infuse / buff em cima)
      infuseType: "resist",     // resist | power | shield | regen | haste
      infuseStrength: 5,        // 1..10
      infusePermanent: false,   // permanente (dura a fase toda)
      infuseDuration: 8.0,      // 2..20 (s) ‚Äî ignorado se permanente

      // Etapa 7/8 (proj√©teis)
      pierce: false,     // atravessa inimigos
      pierceHits: 2,     // 1..5 (quantos inimigos pode acertar)
      aoe: false,        // dano em √°rea no impacto
      aoeRadius: 90,     // 40..220 (px)

      hpMode: "auto",    // auto | manual
      hp: 260            // usado quando hpMode=manual
    };
  }
function _sanitizeHexColor(v, fallback){
    if(typeof v !== "string") return fallback;
    let s = v.trim();
    if(!s) return fallback;
    if(s[0] !== "#") s = "#"+s;
    if(/^#[0-9a-fA-F]{3}$/.test(s)){
      s = "#"+s[1]+s[1]+s[2]+s[2]+s[3]+s[3];
    }
    if(!/^#[0-9a-fA-F]{6}$/.test(s)) return fallback;
    return s.toUpperCase();
  }

  function _sanitizeCustomPerfumeCfg(cfg){
    const c = (_isPlainObject(cfg) ? cfg : {});
    const out = defaultCustomPerfumeCfg();
    // name
    out.name = (typeof c.name==="string" && c.name.trim()) ? c.name.trim().slice(0, 24) : out.name;
    // icon (emoji/texto curto)
    out.icon = (typeof c.icon==="string" && c.icon.trim()) ? c.icon.trim().slice(0, 4) : out.icon;
    // label no frasco
    out.label = (typeof c.label==="string" && c.label.trim()) ? c.label.trim().toUpperCase().slice(0, 6) : out.label;
    // kind
    const allowed = new Set(["shooter","wall","healer","slow","beam","charge","cone","bomb","homing","infuse"]);
    out.kind = allowed.has(c.kind) ? c.kind : out.kind;
    // strength
    out.strength = _clampInt(c.strength, 1, 10) || out.strength;
    // bottleKey
    out.bottleKey = (typeof c.bottleKey==="string" && c.bottleKey.trim()) ? c.bottleKey.trim() : out.bottleKey;
    // colors
    out.bottleTint = _sanitizeHexColor(c.bottleTint, out.bottleTint);
    out.projTint = _sanitizeHexColor(c.projTint, out.projTint);
    // shotCount
    out.shotCount = _clampInt(c.shotCount, 1, 5) || out.shotCount;
    // effect
    const effAllowed = new Set(["none","fire","poison","frost","resin","stun"]);
    out.effect = effAllowed.has(c.effect) ? c.effect : out.effect;

    // Cad√™ncia manual (shooter/slow/homing)
    out.cadenceMode = (c.cadenceMode==="manual") ? "manual" : "auto";
    out.cadence = +clamp(Number(c.cadence!=null ? c.cadence : out.cadence), 0.40, 3.00).toFixed(2);

    // Etapa 10 (Charge Shot)
    out.chargeTime = +clamp(Number(c.chargeTime!=null ? c.chargeTime : out.chargeTime), 0.8, 3.0).toFixed(1);

    // Etapa 12 (Infuse)
    const infAllowed = new Set(["resist","power","shield","regen","haste"]);
    out.infuseType = infAllowed.has(c.infuseType) ? c.infuseType : out.infuseType;
    out.infuseStrength = _clampInt(c.infuseStrength, 1, 10) || out.infuseStrength;
    out.infusePermanent = !!c.infusePermanent;
    out.infuseDuration = +clamp(Number(c.infuseDuration!=null ? c.infuseDuration : out.infuseDuration), 2.0, 20.0).toFixed(1);


    // Etapa 7/8 (proj√©teis)
    out.pierce = !!c.pierce;
    out.pierceHits = _clampInt(c.pierceHits, 1, 5) || out.pierceHits;
    out.aoe = !!c.aoe;
    out.aoeRadius = _clampInt(c.aoeRadius, 40, 220) || out.aoeRadius;

    // hp
    out.hpMode = (c.hpMode==="manual") ? "manual" : "auto";
    out.hp = _clampInt(c.hp, 50, 9999) || out.hp;
    return out;
  }

  function _customKindName(kind){
    return kind==="wall" ? "Tank" :
      kind==="healer" ? "Healer" :
      kind==="slow" ? "Slow shooter" :
      kind==="homing" ? "Homing" :
      kind==="beam" ? "Beam" :
      kind==="charge" ? "Charge Shot" :
      kind==="infuse" ? "Infuse" :
      kind==="cone" ? "Cone" :
      kind==="bomb" ? "Bomba" : "Shooter";
  }

  

function getCustomHpCaps(kind){
  // limites para HP manual do perfume customizado (caps por tipo)
  switch(kind){
    case "wall":  return {min: 300, max: 6500, step: 50};
    case "bomb":  return {min: 200, max: 9999, step: 50};
    case "cone":  return {min: 150, max: 1400, step: 25};
    case "healer":return {min: 160, max: 1100, step: 25};
    case "slow":  return {min: 140, max: 950,  step: 25};
    case "homing":return {min: 140, max: 950,  step: 25};
    case "beam":  return {min: 180, max: 1400, step: 25};
    case "charge":return {min: 150, max: 1200, step: 25};
    default:      return {min: 140, max: 950,  step: 25}; // shooter
  }
}

function getCustomCadenceMin(cfg){
  // Cad√™ncia m√≠nima cresce conforme efeitos / multi-shot / pierce / AoE / tipo.
  const c = (_isPlainObject(cfg) ? cfg : {});
  const kind = (typeof c.kind==="string" ? c.kind : "shooter");
  const s = _clampInt(c.strength, 1, 10) || 5;
  const p = (s-1)/9;
  const pow = Math.pow(p, 1.15);

  let min = (kind==="slow") ? 0.95 : (kind==="homing") ? 0.78 : 0.70;
  const reasons = [];

  if(kind==="slow"){ min += 0.18; reasons.push("Slow shooter"); }
  if(kind==="homing"){ min += 0.10; reasons.push("Homing"); }

  const sc = _clampInt(c.shotCount, 1, 5) || 1;
  if(sc>1){ min += 0.12*(sc-1); reasons.push(`Multi-shot x${sc}`); }

  if(!!c.pierce){
    const hits = _clampInt(c.pierceHits, 1, 5) || 1;
    min += 0.12 + 0.06*(hits-1);
    reasons.push(`Pierce (${hits} hits)`);
  }

  if(!!c.aoe){
    const rad = _clampInt(c.aoeRadius, 40, 220) || 90;
    min += 0.12 + 0.08*(rad/220);
    reasons.push(`AoE (${rad}px)`);
  }

  const eff = (typeof c.effect==="string" ? c.effect : "none");
  if(eff==="fire"){ min += 0.05; reasons.push("Fogo"); }
  else if(eff==="poison"){ min += 0.05; reasons.push("Veneno"); }
  else if(eff==="frost"){ min += 0.09; reasons.push("Gelo"); }
  else if(eff==="resin"){ min += 0.09; reasons.push("Resina"); }
  else if(eff==="stun"){ min += 0.22; reasons.push("Stun"); }

  // for√ßa alta tamb√©m sobe um pouco o m√≠nimo
  min += 0.10*pow;
  if(s>=9){ min += 0.06; reasons.push("For√ßa alta"); }
  else if(s>=8){ min += 0.04; reasons.push("For√ßa alta"); }

  min = +clamp(min, 0.45, 3.00).toFixed(2);
  return { min, reasons };
}

function makeCustomPerfumeDef(cfg){
    const c = _sanitizeCustomPerfumeCfg(cfg);
    const s = _clampInt(c.strength, 1, 10);
    const p = (s-1)/9;                 // 0..1
    const pow = Math.pow(p, 1.15);     // curva suave
    const sc = _clampInt(c.shotCount, 1, 5) || 1;

    const effAllowed = new Set(["fire","poison","frost","resin","stun"]);
    const eff = effAllowed.has(c.effect) ? c.effect : "none";

    // Etapa 7/8 (proj√©teis): pierce + AoE (apenas shooter/slow)
    const projEnabled = (c.kind==="shooter" || c.kind==="slow" || c.kind==="homing");
    const pierceEnabled = projEnabled && !!c.pierce;
    const pierceHits = pierceEnabled ? (_clampInt(c.pierceHits, 1, 5) || 2) : 1;
    const pierceCost = pierceEnabled ? (8 + Math.round(14*pow) + (pierceHits-1) * (6 + Math.round(6*pow))) : 0;
    const pierceCd   = pierceEnabled ? (0.10 + 0.06*pow + (pierceHits-1) * 0.05) : 0;

    const aoeEnabled = projEnabled && !!c.aoe;
    const aoeRadius = aoeEnabled ? (_clampInt(c.aoeRadius, 40, 220) || 90) : 0;
    const aoeMult = aoeEnabled ? 0.45 : 0;
    const aoeCost = aoeEnabled ? (10 + Math.round(16*pow) + Math.round(aoeRadius*0.12)) : 0;
    const aoeCd   = aoeEnabled ? (0.12 + 0.06*pow) : 0;

    // sobrecargas por multi-shot e efeito (apenas shooter/slow)
    const shotCost = (sc-1) * (10 + Math.round(18*pow));
    const shotCd   = (sc-1) * (0.18 + 0.04*pow);

    let effCost = 0, effCd = 0;
    if(eff !== "none"){
      effCost = 10 + Math.round(18*pow);
      effCd   = 0.30 + 0.15*pow;
      if(eff === "stun"){ effCost += 10 + Math.round(10*pow); effCd += 0.10; }
    }

    // base
    let def = {
      id:"customPerfume",
      icon: c.icon,
      name: c.name,
      desc: `Custom (${_customKindName(c.kind)})`,
      kind: c.kind,
      cost: 150,
      cooldown: 10,
      hp: 260,
      tint: (c.bottleTint || "#8DE1FF"),
      projTint: (c.projTint || (c.bottleTint || "#8DE1FF")),
      lore:"Um frasco em branco. Voc√™ escolhe a fun√ß√£o, o visual e a for√ßa ‚Äî pagando o pre√ßo no custo e no cooldown.",
      custom:true,
      // para debug/preview
      _strength:s,
      _pow:+pow.toFixed(3)
    };

    if(c.kind==="shooter"){
      const dmg = Math.round(14 + 52*pow);
      const autoFireRate = Math.max(0.68, +(1.55 - 0.80*pow).toFixed(2));
      const cadInfo = getCustomCadenceMin(c);
      const minFireRate = cadInfo.min;
      let fireRate = autoFireRate;
      const cadMode = (c.cadenceMode==="manual") ? "manual" : "auto";
      // em auto: respeita o m√≠nimo; em manual: clamp no m√≠nimo
      if(cadMode==="manual"){
        const want = clamp(Number(c.cadence!=null ? c.cadence : autoFireRate), 0.40, 3.00);
        fireRate = +Math.max(minFireRate, want).toFixed(2);
      }else{
        fireRate = +Math.max(autoFireRate, minFireRate).toFixed(2);
      }
      const rateBoost = (cadMode==="manual" && fireRate < autoFireRate) ? (autoFireRate / fireRate) : 1.0;
      const cadCost = (rateBoost>1.001) ? Math.round((rateBoost-1) * (35 + 55*pow)) : 0;
      const cadCd   = (rateBoost>1.001) ? ((rateBoost-1) * (0.55 + 0.65*pow)) : 0;
      const hp = Math.round(210 + 110*pow);

      def = { ...def, kind:"shooter",
        dmg, fireRate, projSpeed:330,
        pierceHits,
        aoe: aoeEnabled ? { radius: aoeRadius, mult: aoeMult } : null,
        shotCount: sc,
        effect: eff,
        burn: (eff==="fire") ? { time: +(2.2 + 1.5*pow).toFixed(1), dps: Math.round(4 + 10*pow) } : null,
        poison:(eff==="poison")?{ time: +(3.0 + 1.8*pow).toFixed(1), dps: Math.round(3 + 9*pow) } : null,
        frost:(eff==="frost") ? { time: +(2.0 + 1.4*pow).toFixed(1), mult: +(Math.max(0.40, 0.78 - 0.30*pow)).toFixed(3) } : null,
        resin:(eff==="resin") ? { time: +(2.4 + 1.6*pow).toFixed(1), mult: +(Math.max(0.40, 0.90 - 0.25*pow)).toFixed(3) } : null,
        stun: (eff==="stun")  ? { time: +(0.45 + 0.18*pow).toFixed(2) } : null,
        cost: Math.round(95 + 165*pow) + shotCost + effCost + pierceCost + aoeCost + cadCost,
        cooldown: +Math.max(1.5, (5.8 + 4.8*pow + shotCd + effCd + pierceCd + aoeCd + cadCd)).toFixed(1),
        hp,
        _autoFireRate: autoFireRate,
        _minFireRate: minFireRate,
        _cadenceMode: cadMode,
        _cadenceReasons: cadInfo.reasons
      };
    } else if(c.kind==="slow"){
      const dmg = Math.round(10 + 40*pow);
      const autoFireRate = Math.max(0.85, +(2.05 - 1.10*pow).toFixed(2));
      const cadInfo = getCustomCadenceMin(c);
      const minFireRate = cadInfo.min;
      let fireRate = autoFireRate;
      const cadMode = (c.cadenceMode==="manual") ? "manual" : "auto";
      // em auto: respeita o m√≠nimo; em manual: clamp no m√≠nimo
      if(cadMode==="manual"){
        const want = clamp(Number(c.cadence!=null ? c.cadence : autoFireRate), 0.40, 3.00);
        fireRate = +Math.max(minFireRate, want).toFixed(2);
      }else{
        fireRate = +Math.max(autoFireRate, minFireRate).toFixed(2);
      }
      const rateBoost = (cadMode==="manual" && fireRate < autoFireRate) ? (autoFireRate / fireRate) : 1.0;
      const cadCost = (rateBoost>1.001) ? Math.round((rateBoost-1) * (35 + 55*pow)) : 0;
      const cadCd   = (rateBoost>1.001) ? ((rateBoost-1) * (0.55 + 0.65*pow)) : 0;
      const slowMult = Math.max(0.45, +(0.74 - 0.29*pow).toFixed(3));
      const slowTime = +(2.0 + 1.5*pow).toFixed(1);
      const hp = Math.round(220 + 130*pow);

      def = { ...def, kind:"slow",
        dmg, fireRate, projSpeed:315,
        pierceHits,
        aoe: aoeEnabled ? { radius: aoeRadius, mult: aoeMult } : null,
        slowMult, slowTime,
        shotCount: sc,
        effect: eff,
        burn: (eff==="fire") ? { time: +(2.0 + 1.5*pow).toFixed(1), dps: Math.round(3 + 9*pow) } : null,
        poison:(eff==="poison")?{ time: +(2.6 + 1.8*pow).toFixed(1), dps: Math.round(3 + 8*pow) } : null,
        frost:(eff==="frost") ? { time: +(2.2 + 1.5*pow).toFixed(1), mult: +(Math.max(0.35, slowMult-0.08)).toFixed(3) } : null,
        resin:(eff==="resin") ? { time: +(2.6 + 1.6*pow).toFixed(1), mult: +(Math.max(0.40, 0.90 - 0.25*pow)).toFixed(3) } : null,
        stun: (eff==="stun")  ? { time: +(0.45 + 0.18*pow).toFixed(2) } : null,
        cost: Math.round(120 + 180*pow) + shotCost + effCost + pierceCost + aoeCost + cadCost,
        cooldown: +Math.max(1.5, (8.7 + 5.8*pow + shotCd + effCd + pierceCd + aoeCd + cadCd)).toFixed(1),
        hp,
        _autoFireRate: autoFireRate,
        _minFireRate: minFireRate,
        _cadenceMode: cadMode,
        _cadenceReasons: cadInfo.reasons
      };

    
    } else if(c.kind==="homing"){
      // Homing (teleguiado) ‚Äî proj√©teis curvam at√© o alvo.
      // Regra: prioriza inimigos na mesma lane do disparo; se n√£o houver, mira em qualquer lane.
      const dmg = Math.round(12 + 48*pow);
      const autoFireRate = Math.max(0.74, +(1.70 - 0.80*pow).toFixed(2));
      const cadInfo = getCustomCadenceMin(c);
      const minFireRate = cadInfo.min;
      let fireRate = autoFireRate;
      const cadMode = (c.cadenceMode==="manual") ? "manual" : "auto";
      // em auto: respeita o m√≠nimo; em manual: clamp no m√≠nimo
      if(cadMode==="manual"){
        const want = clamp(Number(c.cadence!=null ? c.cadence : autoFireRate), 0.40, 3.00);
        fireRate = +Math.max(minFireRate, want).toFixed(2);
      }else{
        fireRate = +Math.max(autoFireRate, minFireRate).toFixed(2);
      }
      const rateBoost = (cadMode==="manual" && fireRate < autoFireRate) ? (autoFireRate / fireRate) : 1.0;
      const cadCost = (rateBoost>1.001) ? Math.round((rateBoost-1) * (35 + 55*pow)) : 0;
      const cadCd   = (rateBoost>1.001) ? ((rateBoost-1) * (0.55 + 0.65*pow)) : 0;
      const hp = Math.round(210 + 120*pow);

      def = { ...def, kind:"homing",
        dmg, fireRate, projSpeed:310,
        homing: { turnRate: +(4.6 + 2.2*pow).toFixed(2), seekEvery: 0.08 },
        pierceHits,
        aoe: aoeEnabled ? { radius: aoeRadius, mult: aoeMult } : null,
        shotCount: sc,
        effect: eff,
        burn: (eff==="fire") ? { time: +(2.2 + 1.5*pow).toFixed(1), dps: Math.round(4 + 10*pow) } : null,
        poison:(eff==="poison")?{ time: +(3.0 + 1.8*pow).toFixed(1), dps: Math.round(3 + 9*pow) } : null,
        frost:(eff==="frost") ? { time: +(2.0 + 1.4*pow).toFixed(1), mult: +(Math.max(0.40, 0.78 - 0.30*pow)).toFixed(3) } : null,
        resin:(eff==="resin") ? { time: +(2.4 + 1.6*pow).toFixed(1), mult: +(Math.max(0.40, 0.90 - 0.25*pow)).toFixed(3) } : null,
        stun: (eff==="stun")  ? { time: +(0.45 + 0.18*pow).toFixed(2) } : null,

        // Homing √© mais "seguro" do que shooter comum, ent√£o cobra um pouco a mais
        cost: Math.round(140 + 220*pow) + shotCost + effCost + pierceCost + aoeCost + 20 + cadCost,
        cooldown: +Math.max(1.7, (9.0 + 6.8*pow + shotCd + effCd + pierceCd + aoeCd + cadCd)).toFixed(1),
        hp,
        _autoFireRate: autoFireRate,
        _minFireRate: minFireRate,
        _cadenceMode: cadMode,
        _cadenceReasons: cadInfo.reasons
      };


    } else if(c.kind==="charge"){
      // Charge Shot ‚Äî carrega e fica "pronto"; o jogador clica na planta para disparar
      const ctRaw = (c.chargeTime!=null ? Number(c.chargeTime) : 1.8);
      const chargeTime = +clamp(ctRaw, 0.8, 3.0).toFixed(1);
      const tNorm = (chargeTime - 0.8) / 2.2; // 0..1

      const dmg = Math.round((34 + 210*pow) * (0.95 + 0.55*tNorm));
      const hp  = Math.round(240 + 170*pow);

      def = { ...def, kind:"charge",
        dmg,
        projSpeed: 285,
        projR: Math.round(8 + 5*pow + 2*tNorm),
        projLife: +(3.8 + 1.0*tNorm).toFixed(2),
        chargeTime,
        // plantar: custo/cd (a cad√™ncia de tiro vem do chargeTime interno)
        cost: Math.round(150 + 260*pow + 55*tNorm),
        cooldown: +(10.5 + 9.5*pow + 0.8*tNorm).toFixed(1),
        hp
      };
    } else if(c.kind==="beam"){
      // Beam (raio cont√≠nuo) ‚Äî igual Purificador na mec√¢nica de beam/bateria, mas SEM purificar
      const dps = Math.round(24 + 86*pow);
      const range = Math.round(430 + 140*pow);
      const tickRate = 0.20; // ticks r√°pidos, igual Purificador (som e feel consistentes)
      // mais forte = drena um pouco mais (balance)
      const batteryDrain = +(0.034 + 0.018*pow).toFixed(3);

      def = { ...def, kind:"beam",
        tickRate, dps, range,
        batteryDrain,
        // recarga em pulsos (igual Purificador)
        batteryPulseEvery:5,
        batteryPulseAmount:0.25,
        batteryPulseAmountBoost:0.40,
        // IMPORTANT: custom beam N√ÉO purifica
        noPurify:true,
        // (mant√©m campo para compatibilidade, mas n√£o ser√° usado se noPurify=true)
        purifyAOE:78,
        hp: Math.round(220 + 160*pow),
        cost: Math.round(170 + 320*pow),
        cooldown: +(11.0 + 10.5*pow).toFixed(1)
      };
    
    } else if(c.kind==="infuse"){
      // Infuse ‚Äî s√≥ pode ser usado em cima de outro perfume (efeitos completos vir√£o nas pr√≥ximas sub-etapas)
      const infAllowed2 = new Set(["resist","power","shield","regen","haste"]);
      const infType = infAllowed2.has(c.infuseType) ? c.infuseType : "resist";
      const infStr = _clampInt(c.infuseStrength, 1, 10) || 5;
      const infPerm = !!c.infusePermanent;
      const infDur = +clamp(Number(c.infuseDuration!=null ? c.infuseDuration : 8.0), 2.0, 20.0).toFixed(1);

      // custo/cd base (ainda sem efeito real ‚Äî serve para calibrar a economia)
      const typeExtra = (infType==="power")?10:(infType==="shield")?22:(infType==="regen")?16:(infType==="haste")?18:0;
      const baseCost = (120 + Math.round(220*pow) + Math.round(infDur*6) + infStr*12 + typeExtra);
      const baseCd = (7.5 + 6.5*pow + infDur*0.25 + infStr*0.50);

      const cost = infPerm ? Math.round((baseCost + 120) * 3.1) : baseCost;
      const cooldown = infPerm ? +(12.0 + 10.0*pow + infStr*0.85).toFixed(1) : +baseCd.toFixed(1);

      def = { ...def, kind:"infuse",
        hp: 1,
        infuse: { type: infType, strength: infStr, duration: infDur, permanent: infPerm },
        cost, cooldown
      };
    } else if(c.kind==="wall"){
      def = { ...def, kind:"wall",
        hp: Math.round(900 + 3000*pow),
        cost: Math.round(80 + 170*pow),
        cooldown: +(12.0 + 11.5*pow).toFixed(1)
      };
    } else if(c.kind==="healer"){
      const healAmount = Math.round(12 + 50*pow);
      const healRate = Math.max(1.20, +(3.20 - 1.60*pow).toFixed(2));
      def = { ...def, kind:"healer",
        healAmount, healRate,
        hp: Math.round(240 + 120*pow),
        cost: Math.round(120 + 170*pow),
        cooldown: +(9.0 + 7.0*pow).toFixed(1)
      };
    } else if(c.kind==="cone"){
      const dmg = Math.round(7 + 20*pow);
      const hits = Math.max(3, Math.min(7, 3 + Math.floor(p*4)));
      const range = Math.round(230 + 110*pow);
      const fireRate = Math.max(0.95, +(2.20 - 1.10*pow).toFixed(2));
      def = { ...def, kind:"cone",
        dmg, hits, range, fireRate,
        hp: Math.round(230 + 140*pow),
        cost: Math.round(120 + 170*pow),
        cooldown: +(9.0 + 7.2*pow).toFixed(1)
      };
    } else if(c.kind==="bomb"){
      const dmg = Math.round(160 + 1100*pow);
      const fuse = Math.max(0.60, +(1.25 - 0.55*pow).toFixed(2));
      def = { ...def, kind:"bomb",
        dmg, fuse,
        hp: 9999,
        cost: Math.round(170 + 270*pow),
        cooldown: +(14.0 + 15.0*pow).toFixed(1)
      };
    }

    // HP manual (opcional): ajusta custo/cooldown com base no HP escolhido
    const hpBase = def.hp;
    const hpCaps = getCustomHpCaps(def.kind);
    if(c.hpMode==="manual"){
      const hpManual = _clampInt(c.hp, hpCaps.min, hpCaps.max) || hpBase;
      def.hp = hpManual;
      const delta = hpManual - hpBase;
      if(delta!==0){
        const costMul = (def.kind==="wall") ? 0.020 : 0.050; // custo por HP extra
        const cdMul   = (def.kind==="wall") ? 0.00045 : 0.00105; // cooldown por HP extra
        def.cost = Math.max(25, Math.round(def.cost + delta * costMul));
        def.cooldown = +Math.max(1.5, (def.cooldown + delta * cdMul)).toFixed(1);
      }
      def.hpManual = true;
    }else{
      def.hpManual = false;
    }

    // desc coerente
    def.desc = `Custom ${_customKindName(def.kind)} ‚Ä¢ For√ßa ${s}/10`
      + ((def.kind==="shooter"||def.kind==="slow") ? ` ‚Ä¢ Shots ${def.shotCount||1}` : ``)
      + ((def.effect && def.effect!=="none") ? ` ‚Ä¢ ${def.effect.toUpperCase()}` : ``)
      + ` ‚Ä¢ HP ${def.hp}` + ((def.hpManual)?` (MANUAL)`:``);

    return def;
  }

  function applyCustomPerfumeDefFromProgress(){
    if(!progress.customPerfume) progress.customPerfume = defaultCustomPerfumeCfg();
    progress.customPerfume = _sanitizeCustomPerfumeCfg(progress.customPerfume);
    const def = makeCustomPerfumeDef(progress.customPerfume);
    plantById.set(def.id, def);
    const idx = PlantDefs.findIndex(p=>p.id===def.id);
    if(idx>=0) PlantDefs[idx] = def;
    return def;
  }

  // ================= Enemies =================
  const EnemyDefs = {
    whiff: { key:"whiff", name:"Fuma√ßinha", hp:160, speed:20, damage:20, biteRate:0.95, tint:"#9aa7ff", glyph:"~",  size:1.00,
      lore:"O b√°sico do b√°sico: bruma que se acha grande coisa." },

    fast:  { key:"fast",  name:"Veloz", hp:120, speed:32, damage:16, biteRate:0.8, tint:"#9fffd8", glyph:">>", size:0.86,
      lore:"N√£o √© forte, mas √© insolente. Pega voc√™ antes da forma√ß√£o ficar pronta." },

    dense: { key:"dense", name:"Densa", hp:360, speed:15, damage:30, biteRate:0.98, tint:"#c7b6ff", glyph:"OO", size:1.18,
      lore:"Uma nuvem pesada. Se encosta, machuca de verdade." },

    toxic: { key:"toxic", name:"T√≥xica", hp:250, speed:17, damage:26, biteRate:0.9, tint:"#ffd36a", glyph:"‚ò£", size:1.06,
      poison:{ dps:10, time:3.2 },
      lore:"Pior que morder √© deixar veneno no ar. Ignorar ela vira bola de neve." },

    boss1: { key:"boss1", name:"Miasma Rei", hp:3200, speed:12, damage:48, biteRate:0.78, tint:"#ff6a6a", glyph:"üëë", size:1.65,
      spawnMinionsRate:8.0,
      lore:"O rei antigo do mal cheiro. Caiu‚Ä¶ mas deixou algo acordando por tr√°s." },

    /* === P√ìS-HIST√ìRIA (Novos mal cheiros) === */
    reflect: { key:"reflect", name:"Bruma Reflexa", hp:220, speed:18, damage:22, biteRate:0.92, tint:"#A9B6FF", glyph:"‚óá", size:1.02,
      requiresPurify:true, reflectProjectiles:true,
      lore:"At√© voc√™ purificar, ela ‚Äònega‚Äô proj√©teis comuns. O Purificador resolve." },

    sticky: { key:"sticky", name:"Fedor Grudento", hp:190, speed:16, damage:18, biteRate:0.92, tint:"#D7A0FF", glyph:"‚âà", size:1.02,
      stickyDebuff:{ fireMult:1.35, time:4.0 },
      lore:"Quando encosta, deixa o campo ‚Äòpesado‚Äô. O Clean e o Purificador ajudam a controlar." },

    cloak:  { key:"cloak", name:"N√©voa Camuflada", hp:180, speed:22, damage:22, biteRate:0.88, tint:"#9aa7ff", glyph:"?", size:0.98,
      requiresPurify:true, evasive:true,
      lore:"Enquanto n√£o for purificada, ela ‚Äòsome‚Äô ‚Äî e faz ataques comuns falharem." },

    armored:{ key:"armored", name:"Miasma Encoura√ßado", hp:520, speed:14, damage:34, biteRate:1.05, tint:"#c7b6ff", glyph:"‚õìÔ∏è", size:1.18,
      requiresPurify:true, dmgReduction:0.55,
      lore:"Casca grossa de mau cheiro. Sem purificar, voc√™ perde tempo demais." },

        /* === CAMPANHA 2 (Novos mal cheiros) === */
    sealed: { key:"sealed", name:"Bruma Lacrada", hp:260, speed:16, damage:24, biteRate:0.92, tint:"#B7F2FF", glyph:"‚üê", size:1.06,
      purifierImmune:true, purifierImmuneType:"salt",
      lore:"Um lacre qu√≠mico impede o Purificador de ‚Äòentrar‚Äô. Quebre o lacre com marca√ß√µes espec√≠ficas." },

    insulated: { key:"insulated", name:"Bruma Isolante", hp:320, speed:14, damage:28, biteRate:0.98, tint:"#FFB36A", glyph:"‚ñ£", size:1.10,
      purifierImmune:true, purifierImmuneType:"resin",
      lore:"Isolamento denso: o feixe escorrega. Resina certa faz o miasma ‚Äògrudar‚Äô e perder a prote√ß√£o." },

    selfclean: { key:"selfclean", name:"Bruma Autolimpante", hp:240, speed:18, damage:22, biteRate:0.90, tint:"#FFD36A", glyph:"‚ü≤", size:1.04,
      cleanseAura:{ rate:3.0, range:180 },
      lore:"Ela ‚Äòlava‚Äô o campo: limpa marca√ß√µes de aliados pr√≥ximos e atrasa seus combos." },

        /* === P√ìS-GAME (elites para sobreviv√™ncia dif√≠cil) === */
    colossus: { key:"colossus", name:"Colosso do Miasma", hp:1100, speed:10, damage:52, biteRate:1.15, tint:"#B7B6FF", glyph:"‚¨õ", size:1.48,
      requiresPurify:true, dmgReduction:0.68,
      lore:"Um bloco de bruma comprimida. Enquanto n√£o for purificado, ele aguenta ‚Äòdemais‚Äô e quebra sua linha no tempo." },

    corrosive: { key:"corrosive", name:"Bruma Corrosiva", hp:380, speed:18, damage:26, biteRate:0.88, tint:"#FFB36A", glyph:"‚ò†", size:1.08,
      poison:{ dps:16, time:5.0 },
      stickyDebuff:{ fireMult:1.55, time:4.2 },
      lore:"Ela n√£o quer s√≥ morder: ela quer deixar seu campo lento e doente. Se empilhar, vira p√¢nico." },

    shatter: { key:"shatter", name:"Bruma Fragmentada", hp:280, speed:22, damage:22, biteRate:0.92, tint:"#9FFFD8", glyph:"‚ú∂", size:1.02,
      onDieSpawn:{ count:2, spread:26, pool:["whiff","fast"] },
      lore:"Quando cai, ela se estilha√ßa em fragmentos menores. Se voc√™ n√£o tiver controle de volume, o enxame volta." },
boss2: { key:"boss2", name:"Imperador do Eclipse", hp:4200, speed:11, damage:55, biteRate:0.78, tint:"#FF4B6E", glyph:"üú≤", size:1.75,
      spawnMinionsRate:6.6,
      lore:"O que sobrou do Rei‚Ä¶ evoluiu. Um eclipse de bruma que s√≥ cai com a forma√ß√£o completa." }
  };

  // ================= Campaign / Worlds =================
  const Campaigns = {
    story: {
      id:"story",
      title:"Campanha 1 ‚Äî A Vitrine",
      subtitle:"Defenda a loja e derrube o Miasma Rei.",
      unlocked:true,
      worlds: [
        {
          id:1, name:"Mundo 1 ‚Äî Jardim da Vitrine", desc:"Treino leve, com hordas sinalizadas.",
          rewardPlant:"wall",
          prepTime:24, introDelay:6,
          skyAroma: { prepMin:5.2, prepMax:7.4, gameMin:10.2, gameMax:15.2, types:["gold"] },
          waves: [
            { type:"ramp", ramp:{ count:6, baseGap:4.4, pool:["whiff"] }, trickle:{ count:4, gap:4.8, pool:["whiff"] }, rest:6 },
            { type:"horde", horde:{ count:9, window:0.9, pool:["whiff","whiff","fast"] }, trickle:{ count:7, gap:3.9, pool:["whiff","fast","whiff"] }, rest:7 },
            { type:"horde", horde:{ count:11, window:1.0, pool:["whiff","fast"] }, trickle:{ count:9, gap:3.4, pool:["whiff","fast"] }, rest:7 },
            { type:"final", warn:true, horde:{ count:16, window:1.2, pool:["whiff","fast","fast"] } }
          ]
        },
        {
          id:2, name:"Mundo 2 ‚Äî Corredor do Provador", desc:"Velozes entram, mas com respiro entre hordas.",
          rewardPlant:"slow",
          prepTime:22, introDelay:6,
          skyAroma: { prepMin:5.3, prepMax:7.7, gameMin:10.4, gameMax:15.6, types:["gold"] },
          waves: [
            { type:"ramp", ramp:{ count:7, baseGap:4.0, pool:["whiff","fast","whiff"] }, trickle:{ count:4, gap:4.6, pool:["whiff","fast"] }, rest:6 },
            { type:"horde", horde:{ count:11, window:1.0, pool:["fast","whiff","fast"] }, trickle:{ count:8, gap:3.3, pool:["whiff","fast"] }, rest:7 },
            { type:"horde", horde:{ count:13, window:1.05, pool:["fast","fast","whiff"] }, trickle:{ count:10, gap:3.0, pool:["whiff","fast"] }, rest:7 },
            { type:"final", warn:true, horde:{ count:18, window:1.2, pool:["fast","fast","whiff"] } }
          ]
        },
        {
          id:3, name:"Mundo 3 ‚Äî Dep√≥sito de Fragr√¢ncias", desc:"Densas aparecem. Segure a linha.",
          rewardPlant:"healer",
          prepTime:20, introDelay:6,
          skyAroma: { prepMin:5.6, prepMax:8.2, gameMin:10.8, gameMax:16.0, types:["gold"] },
          waves: [
            { type:"ramp", ramp:{ count:8, baseGap:3.8, pool:["whiff","fast"] }, trickle:{ count:5, gap:4.2, pool:["whiff","fast"] }, rest:6 },
            { type:"horde", horde:{ count:12, window:1.05, pool:["dense","whiff","fast"] }, trickle:{ count:9, gap:3.0, pool:["whiff","fast","dense"] }, rest:7 },
            { type:"horde", horde:{ count:14, window:1.1, pool:["dense","fast","whiff"] }, trickle:{ count:11, gap:2.8, pool:["dense","fast","whiff"] }, rest:7 },
            { type:"final", warn:true, horde:{ count:20, window:1.25, pool:["dense","fast","whiff"] } }
          ]
        },
        {
          id:4, name:"Mundo 4 ‚Äî Noite da Loja Fechada", desc:"T√≥xicas entram. Veneno vira press√£o real.",
          rewardPlant:"bomb",
          prepTime:19, introDelay:6,
          skyAroma: { prepMin:6.0, prepMax:8.6, gameMin:11.2, gameMax:16.6, types:["gold"] },
          waves: [
            { type:"ramp", ramp:{ count:9, baseGap:3.6, pool:["whiff","fast","dense"] }, trickle:{ count:6, gap:3.8, pool:["whiff","fast","dense"] }, rest:6 },
            { type:"horde", horde:{ count:14, window:1.15, pool:["toxic","dense","fast"] }, trickle:{ count:10, gap:2.9, pool:["toxic","dense","whiff","fast"] }, rest:7 },
            { type:"horde", horde:{ count:16, window:1.2, pool:["toxic","dense","fast"] }, trickle:{ count:12, gap:2.6, pool:["toxic","dense","fast","whiff"] }, rest:7 },
            { type:"final", warn:true, horde:{ count:22, window:1.3, pool:["toxic","dense","fast"] } }
          ]
        },
        {
          id:5, name:"Mundo 5 ‚Äî C√¢mara do Miasma", desc:"Boss no final. O Rei cai‚Ä¶ mas algo acorda.",
          rewardPlant:"beam",
          prepTime:19, introDelay:6,
          skyAroma: { prepMin:6.2, prepMax:9.0, gameMin:11.6, gameMax:17.2, types:["gold"] },
          waves: [
            { type:"ramp", ramp:{ count:10, baseGap:3.4, pool:["fast","dense","toxic","whiff"] }, trickle:{ count:6, gap:3.6, pool:["fast","dense","whiff"] }, rest:6 },
            { type:"horde", horde:{ count:16, window:1.2, pool:["fast","dense","toxic"] }, trickle:{ count:12, gap:2.6, pool:["fast","dense","toxic","whiff"] }, rest:7 },
            { type:"horde", horde:{ count:18, window:1.25, pool:["fast","dense","toxic"] }, trickle:{ count:14, gap:2.4, pool:["fast","dense","toxic"] }, rest:7 },
            { type:"final", warn:true, boss:true,
              horde:{ count:1, window:0.6, pool:["boss1"] },
              minions:{ count:10, window:1.2, pool:["fast","toxic","dense","fast"] }
            }
          ]
        }
      ]
    },

    post: {
      id:"post",
      title:"P√≥s-Hist√≥ria ‚Äî O Eclipse do Miasma",
      subtitle:"A bruma evoluiu: agora ela reage. O Purificador vira pe√ßa central.",
      unlocked:false,
      worlds: [
        {
          id:6, name:"Mundo 6 ‚Äî Galeria de Espelhos", desc:"Bruma Reflexa aparece. Purifique para ela parar de negar proj√©teis.",
          rewardPlant:"prismLens",
          prepTime:20, introDelay:6,
          skyAroma: { prepMin:6.0, prepMax:8.6, gameMin:11.4, gameMax:17.0, types:["gold","crystal"] },
          gimmick:"Purifica√ß√£o obrigat√≥ria: alguns mal cheiros s√≥ ‚Äòaceitam‚Äô dano depois do Purificador tocar neles.",
          waves: [
            { type:"ramp", ramp:{ count:9, baseGap:3.8, pool:["whiff","fast","reflect"] }, trickle:{ count:7, gap:3.8, pool:["whiff","reflect"] }, rest:7 },
            { type:"horde", horde:{ count:14, window:1.2, pool:["reflect","fast","whiff"] }, trickle:{ count:12, gap:2.9, pool:["reflect","fast","whiff"] }, rest:8 },
            { type:"horde", horde:{ count:16, window:1.25, pool:["reflect","dense","fast"] }, trickle:{ count:12, gap:2.8, pool:["reflect","dense","fast"] }, rest:8 },
            { type:"final", warn:true, horde:{ count:22, window:1.4, pool:["reflect","fast","dense"] } }
          ]
        },
        {
          id:7, name:"Mundo 7 ‚Äî Cafeteria do Estoque", desc:"Fedor Grudento desacelera seus ataques. Trap vira ouro.",
          rewardPlant:"coffeeTrap",
          prepTime:19, introDelay:6,
          skyAroma: { prepMin:6.0, prepMax:9.0, gameMin:11.4, gameMax:17.4, types:["gold","espresso"] },
          gimmick:"Grude no campo: algumas mordidas aplicam um debuff que deixa suas plantas mais lentas.",
          waves: [
            { type:"ramp", ramp:{ count:10, baseGap:3.6, pool:["fast","whiff","sticky"] }, trickle:{ count:8, gap:3.6, pool:["sticky","fast","whiff"] }, rest:7 },
            { type:"horde", horde:{ count:16, window:1.25, pool:["sticky","fast","dense"] }, trickle:{ count:13, gap:2.8, pool:["sticky","fast","whiff"] }, rest:8 },
            { type:"horde", horde:{ count:18, window:1.3, pool:["sticky","dense","toxic"] }, trickle:{ count:14, gap:2.7, pool:["sticky","fast","dense"] }, rest:8 },
            { type:"final", warn:true, horde:{ count:24, window:1.45, pool:["sticky","fast","dense"] } }
          ]
        },
        {
          id:8, name:"Mundo 8 ‚Äî Jardim Sensorial", desc:"N√©voa Camuflada ‚Äòsome‚Äô at√© ser purificada. Booster abre janelas de dano.",
          rewardPlant:"arboBoost",
          prepTime:19, introDelay:6,
          skyAroma: { prepMin:6.2, prepMax:9.4, gameMin:11.8, gameMax:17.8, types:["gold","botik"] },
          gimmick:"Camuflagem: ataques comuns falham √†s vezes at√© o inimigo ser purificado.",
          waves: [
            { type:"ramp", ramp:{ count:11, baseGap:3.5, pool:["cloak","fast","whiff"] }, trickle:{ count:9, gap:3.4, pool:["cloak","whiff","fast"] }, rest:7 },
            { type:"horde", horde:{ count:18, window:1.3, pool:["cloak","dense","fast"] }, trickle:{ count:14, gap:2.7, pool:["cloak","fast","toxic"] }, rest:8 },
            { type:"horde", horde:{ count:20, window:1.35, pool:["cloak","toxic","dense"] }, trickle:{ count:15, gap:2.6, pool:["cloak","dense","fast"] }, rest:8 },
            { type:"final", warn:true, horde:{ count:26, window:1.5, pool:["cloak","fast","dense","toxic"] } }
          ]
        },
        {
          id:9, name:"Mundo 9 ‚Äî Sala de Neutraliza√ß√£o", desc:"Encoura√ßados aguentam demais sem purificar. Clean vira obrigat√≥rio.",
          rewardPlant:"nativaClean",
          prepTime:18, introDelay:6,
          skyAroma: { prepMin:6.4, prepMax:9.8, gameMin:12.2, gameMax:18.2, types:["gold","prism"] },
          gimmick:"Armadura + purifica√ß√£o: sem Purificador, o dano ‚Äòn√£o entra‚Äô direito.",
          waves: [
            { type:"ramp", ramp:{ count:12, baseGap:3.4, pool:["armored","fast","whiff"] }, trickle:{ count:10, gap:3.2, pool:["armored","dense","whiff"] }, rest:7 },
            { type:"horde", horde:{ count:20, window:1.35, pool:["armored","dense","toxic"] }, trickle:{ count:16, gap:2.6, pool:["armored","fast","dense"] }, rest:8 },
            { type:"horde", horde:{ count:22, window:1.4, pool:["armored","toxic","dense"] }, trickle:{ count:16, gap:2.5, pool:["armored","dense","fast","whiff"] }, rest:8 },
            { type:"final", warn:true, horde:{ count:28, window:1.6, pool:["armored","dense","toxic","fast"] } }
          ]
        },
        {
          id:10, name:"Mundo 10 ‚Äî Eclipse do Miasma", desc:"Boss final. Voc√™ vai precisar de tudo que aprendeu.",
          rewardPlant:null,
          prepTime:18, introDelay:6,
          skyAroma: { prepMin:6.2, prepMax:9.6, gameMin:12.0, gameMax:18.0, types:["gold","crown","prism","botik"] },
          gimmick:"Chef√£o com escudo extra: quebra r√°pido com Purificador + buff do Arbo Booster + Elys√©e Prisma na linha.",
          waves: [
            { type:"ramp", ramp:{ count:12, baseGap:3.4, pool:["fast","dense","toxic","whiff"] }, trickle:{ count:10, gap:3.1, pool:["fast","dense","whiff"] }, rest:7 },
            { type:"horde", horde:{ count:22, window:1.4, pool:["armored","fast","toxic"] }, trickle:{ count:16, gap:2.5, pool:["armored","fast","dense"] }, rest:8 },
            { type:"final", warn:true, boss:true,
              horde:{ count:1, window:0.7, pool:["boss2"] },
              minions:{ count:16, window:1.5, pool:["reflect","sticky","cloak","armored","fast","toxic"] }
            }
          ]
        }
      ]
  },
    c2: {
      id:"c2",
      title:"Campanha 2 ‚Äî Contra-Lacre",
      subtitle:"Lacres, resinas e bruma autolimpante: controle fino, combos e purifica√ß√£o.",
      unlocked:false,
      worlds: [
        {
          id:11, name:"Mundo 11 ‚Äî Corredor Salino", desc:"Primeiros lacres aparecem. Dano bruto ainda resolve ‚Äî mas a marca abre caminho.",
          rewardPlant:"zaadCat",
          prepTime:18, introDelay:6,
          skyAroma: { prepMin:6.2, prepMax:9.4, gameMin:12.0, gameMax:18.0, types:["gold","botik","prism"] },
          gimmick:"Lacre (‚üê): parte do miasma ignora o Purificador at√© ser ‚Äòsalinizado‚Äô.",
          waves: [
            { type:"ramp", ramp:{ count:12, baseGap:3.4, pool:["whiff","fast","sealed"] }, trickle:{ count:10, gap:3.2, pool:["whiff","sealed"] }, rest:7 },
            { type:"horde", horde:{ count:20, window:1.35, pool:["sealed","fast","dense"] }, trickle:{ count:16, gap:2.6, pool:["sealed","fast","whiff"] }, rest:8 },
            { type:"horde", horde:{ count:22, window:1.4, pool:["sealed","armored","toxic"] }, trickle:{ count:16, gap:2.5, pool:["sealed","dense","fast"] }, rest:8 },
            { type:"final", warn:true, horde:{ count:28, window:1.6, pool:["sealed","fast","dense","armored"] } }
          ]
        },
        {
          id:12, name:"Mundo 12 ‚Äî Oficina do Catalisador", desc:"Agora o miasma tenta ‚Äòlavar‚Äô as marca√ß√µes. Priorize alvos e ganhe janelas.",
          rewardPlant:"ekosResin",
          prepTime:18, introDelay:6,
          skyAroma: { prepMin:6.0, prepMax:9.2, gameMin:12.0, gameMax:18.2, types:["gold","crystal","espresso"] },
          gimmick:"Autolimpeza (‚ü≤): inimigos limpam marca√ß√µes em √°rea. Foque e finalize r√°pido.",
          waves: [
            { type:"ramp", ramp:{ count:13, baseGap:3.3, pool:["sealed","fast","whiff"] }, trickle:{ count:10, gap:3.1, pool:["sealed","fast"] }, rest:7 },
            { type:"horde", horde:{ count:22, window:1.4, pool:["sealed","selfclean","fast"] }, trickle:{ count:16, gap:2.5, pool:["selfclean","fast","whiff"] }, rest:8 },
            { type:"horde", horde:{ count:24, window:1.45, pool:["sealed","selfclean","dense","toxic"] }, trickle:{ count:18, gap:2.45, pool:["sealed","dense","fast"] }, rest:8 },
            { type:"final", warn:true, horde:{ count:30, window:1.65, pool:["sealed","selfclean","fast","dense"] } }
          ]
        },
        {
          id:13, name:"Mundo 13 ‚Äî Dep√≥sito de Resinas", desc:"Isolamento denso faz o feixe ‚Äòescorregar‚Äô. Resina certa faz o miasma grudar.",
          rewardPlant:null,
          prepTime:18, introDelay:6,
          skyAroma: { prepMin:6.3, prepMax:9.8, gameMin:12.4, gameMax:18.6, types:["gold","prism","crown"] },
          gimmick:"Isolante (‚ñ£): inimigos ignoram o Purificador at√© receber ‚Äòresina‚Äô.",
          waves: [
            { type:"ramp", ramp:{ count:14, baseGap:3.25, pool:["insulated","fast","whiff"] }, trickle:{ count:10, gap:3.0, pool:["insulated","whiff"] }, rest:7 },
            { type:"horde", horde:{ count:24, window:1.45, pool:["insulated","sealed","dense"] }, trickle:{ count:18, gap:2.5, pool:["insulated","fast","whiff"] }, rest:8 },
            { type:"horde", horde:{ count:26, window:1.5, pool:["insulated","selfclean","toxic"] }, trickle:{ count:18, gap:2.45, pool:["sealed","dense","fast"] }, rest:8 },
            { type:"final", warn:true, horde:{ count:32, window:1.7, pool:["insulated","sealed","selfclean","fast","dense"] } }
          ]
        },
        {
          id:14, name:"Mundo 14 ‚Äî C√¢mara Autolimpante", desc:"O campo inteiro vira uma guerra de timing. Buffs e traps valem ouro.",
          rewardPlant:null,
          prepTime:18, introDelay:6,
          skyAroma: { prepMin:6.4, prepMax:10.0, gameMin:12.6, gameMax:19.0, types:["gold","botik","espresso"] },
          gimmick:"Press√£o de limpeza: muita Autolimpante. Marque, catalise e finalize antes da aura apagar tudo.",
          waves: [
            { type:"ramp", ramp:{ count:14, baseGap:3.2, pool:["selfclean","fast","whiff"] }, trickle:{ count:12, gap:3.0, pool:["selfclean","fast"] }, rest:7 },
            { type:"horde", horde:{ count:26, window:1.5, pool:["selfclean","sealed","fast"] }, trickle:{ count:18, gap:2.45, pool:["selfclean","dense","whiff"] }, rest:8 },
            { type:"horde", horde:{ count:28, window:1.55, pool:["selfclean","insulated","dense","toxic"] }, trickle:{ count:20, gap:2.4, pool:["sealed","insulated","fast"] }, rest:8 },
            { type:"final", warn:true, horde:{ count:36, window:1.8, pool:["selfclean","sealed","insulated","fast","dense","toxic"] } }
          ]
        },
        {
          id:15, name:"Mundo 15 ‚Äî Protocolo Zero", desc:"Final da campanha. Se o lacre existir, voc√™ quebra. Se a bruma reagir, voc√™ reorganiza.",
          rewardPlant:null,
          prepTime:18, introDelay:6,
          skyAroma: { prepMin:6.6, prepMax:10.2, gameMin:12.8, gameMax:19.2, types:["gold","crown","prism","botik","espresso"] },
          gimmick:"Mistura total: lacre + resina + autolimpeza. Use sinergias (Prisma no Purificador, Booster, Clean, Trap, marcas).",
          waves: [
            { type:"ramp", ramp:{ count:16, baseGap:3.1, pool:["fast","dense","toxic","sealed","insulated"] }, trickle:{ count:12, gap:2.9, pool:["fast","sealed","insulated"] }, rest:7 },
            { type:"horde", horde:{ count:28, window:1.55, pool:["selfclean","sealed","insulated","armored"] }, trickle:{ count:20, gap:2.4, pool:["selfclean","fast","dense"] }, rest:8 },
            { type:"horde", horde:{ count:30, window:1.6, pool:["reflect","cloak","selfclean","sealed","insulated"] }, trickle:{ count:22, gap:2.35, pool:["sealed","insulated","fast","toxic"] }, rest:8 },
            { type:"final", warn:true, boss:true,
              horde:{ count:1, window:0.7, pool:["boss1"] },
              minions:{ count:22, window:1.6, pool:["sealed","insulated","selfclean","fast","dense","toxic","armored"] }
            }
          ]
        }
      ]
    },


survival: {
  id:"survival",
  title:"Sobreviv√™ncia ‚Äî Bruma Infinita",
  subtitle:"Waves infinitas com dificuldade crescente e boss a cada 5 waves.",
  unlocked:true,
  worlds: [
    {
      id:101, name:"Sobreviv√™ncia ‚Äî Loja Infinita", desc:"A dificuldade sobe at√© um teto. A cada 5 waves surge um boss.",
      rewardPlant:null,
      prepTime:18, introDelay:6,
      skyAroma: { prepMin:6.0, prepMax:9.0, gameMin:11.6, gameMax:17.6, types:["gold","botik","prism","espresso","crown"] },
      gimmick:"Infinito: dificuldade crescente (at√© cap) + boss a cada 5 waves.",
      survival:true,
      enemyPreview:["whiff","fast","dense","toxic","reflect","sticky","cloak","armored","boss1","boss2"],
      waves: []
    }
  ]
},

survival_hc: {
  id:"survival_hc",
  title:"Sobreviv√™ncia HARDCORE ‚Äî Eclipse Profundo",
  subtitle:"Waves infinitas mais r√°pidas, inimigos mais fortes e elites exclusivas.",
  unlocked:false,
  worlds: [
    {
      id:102, name:"Hardcore ‚Äî Loja em Ru√≠nas", desc:"Mais frequ√™ncia + inimigos mais fortes. Elites exclusivas e boss a cada 4 waves.",
      rewardPlant:null,
      prepTime:18, introDelay:6,
      skyAroma: { prepMin:6.2, prepMax:9.4, gameMin:11.8, gameMax:18.0, types:["gold","botik","prism","espresso","crown"] },
      gimmick:"Hardcore: +frequ√™ncia, +for√ßa, elites exclusivas (Corrosivo/Fragmentada/Colosso) + boss a cada 4 waves.",
      survival:true,
      hardcore:true,
      enemyPreview:["whiff","fast","dense","toxic","reflect","sticky","cloak","armored","sealed","insulated","selfclean","corrosive","shatter","colossus","boss1","boss2"],
      waves: []
    }
  ]
}
  };

  // ================= Progress (sem bug de "j√° venceu") =================
  const progress = {
    activeCampaignId: "story",
    // desbloqueio de mundos (por campanha)
    worldUnlocked: {
      story: Campaigns.story.worlds.map(w => w.id === 1),
      post: Campaigns.post.worlds.map(_ => false),
      c2:   Campaigns.c2.worlds.map(_ => false),
      survival: Campaigns.survival.worlds.map(_ => true),
      survival_hc: Campaigns.survival_hc.worlds.map(_ => true)
    },
    // plantas desbloqueadas
    unlockedPlants: new Set(["sun","shooter","cone","shovel"]),
    // moedas (meta-progresso)
    currency: 0,
    // perfumes especiais comprados na lojinha
    specialOwned: new Set([]),
    // perks (meta-upgrades)
    perks: { slotPlus: 0, freeCoffee: 0 },
    lastLoadout: ["sun","shooter","cone"],
    postUnlocked: false,
    c2Unlocked: false,
    customPerfume: defaultCustomPerfumeCfg()
  };

  // ================= Save/Load (robusto + compat√≠vel) =================
  // ‚ö†Ô∏è Nota: ao abrir o jogo via "file://" (arquivo local), alguns navegadores podem n√£o
  // persistir o storage de forma confi√°vel. Por isso, al√©m do autosave, existe Exportar/Importar Save.
  const SAVE_KEY = "bd_progress";              // chave est√°vel (n√£o muda entre vers√µes)
  const SAVE_BAK_KEY = "bd_progress_bak";      // backup autom√°tico do save anterior
  const LEGACY_SAVE_KEYS = ["bd_progress_v7"]; // migra√ß√£o autom√°tica de saves antigos
  const SAVE_VERSION = 2;

  // Loadout (base 8 perfumes por fase; perks podem aumentar)
const MAX_LOADOUT = 8;

function _clampInt(n, lo, hi){
  n = Math.floor(Number(n||0));
  if(!Number.isFinite(n)) n = 0;
  if(lo!=null) n = Math.max(lo, n);
  if(hi!=null) n = Math.min(hi, n);
  return n;
}
function maxLoadoutFromPerks(perks){
  return MAX_LOADOUT + _clampInt(perks?.slotPlus, 0, 7);
}
function getMaxLoadout(){
  // Nota: progress existe em runtime; durante load/sanitize, use maxLoadoutFromPerks(...)
  return maxLoadoutFromPerks(progress?.perks);
}

  function _storageOK(){
    try{
      const k = "__bd_test__";
      localStorage.setItem(k, "1");
      localStorage.removeItem(k);
      return true;
    }catch(e){ return false; }
  }
  let STORAGE_OK = _storageOK();

  function _safeLSGet(k){ try{ return localStorage.getItem(k); }catch(e){ return null; } }
  function _safeLSSet(k,v){ try{ localStorage.setItem(k,v); return true; }catch(e){ return false; } }
  function _safeLSRemove(k){ try{ localStorage.removeItem(k); return true; }catch(e){ return false; } }

  function _isPlainObject(x){
    return !!x && typeof x==="object" && (x.constructor===Object || Object.getPrototypeOf(x)===Object.prototype);
  }

  // Serializa√ß√£o que preserva campos futuros sem precisar "editar o save" a cada patch:
  // - Converte Set -> {__t:"Set", v:[...]}
  // - Copia todos os campos "data-like" do progress (e extras), ignorando fun√ß√µes.
  function _pack(v){
    if(v instanceof Set) return {__t:"Set", v:Array.from(v)};
    if(v instanceof Map) return {__t:"Map", v:Array.from(v.entries())};
    if(Array.isArray(v)) return v.map(_pack);
    if(v && typeof v==="object"){
      const out = {};
      for(const [k,val] of Object.entries(v)){
        if(typeof val === "function") continue;
        out[k] = _pack(val);
      }
      return out;
    }
    return v;
  }
  function _unpack(v){
    if(!v || typeof v!=="object") return v;
    if(Array.isArray(v)) return v.map(_unpack);
    if(v.__t==="Set" && Array.isArray(v.v)) return new Set(v.v.map(_unpack));
    if(v.__t==="Map" && Array.isArray(v.v)) return new Map(v.v.map(([a,b])=>[_unpack(a), _unpack(b)]));
    const out = {};
    for(const [k,val] of Object.entries(v)){
      out[k] = _unpack(val);
    }
    return out;
  }

  function defaultProgressState(){
    return {
      activeCampaignId: "story",
      worldUnlocked: {
        story: Campaigns.story.worlds.map(w => w.id === 1),
        post:  Campaigns.post.worlds.map(_ => false),
        c2:    Campaigns.c2.worlds.map(_ => false),
        survival: Campaigns.survival.worlds.map(_ => true),
        survival_hc: Campaigns.survival_hc.worlds.map(_ => true)
      },
      unlockedPlants: ["sun","shooter","cone","shovel"],
      currency: 0,
      specialOwned: [],
      perks: { slotPlus: 0, freeCoffee: 0 },
      lastLoadout: ["sun","shooter","cone"],
      postUnlocked: false,
      c2Unlocked: false,
      customPerfume: defaultCustomPerfumeCfg()
    };
  }

  // merge que:
  // - aplica defaults para campos faltando
  // - preserva campos desconhecidos (pra n√£o "quebrar no futuro")
  function _deepMergePreserve(def, saved){
    if(def instanceof Set){
      if(saved instanceof Set) return new Set(Array.from(saved));
      if(Array.isArray(saved)) return new Set(saved);
      return new Set(Array.from(def));
    }
    if(Array.isArray(def)){
      if(Array.isArray(saved)) return saved.slice();
      if(saved instanceof Set) return Array.from(saved);
      return def.slice();
    }
    if(_isPlainObject(def)){
      const res = {};
      const s = _isPlainObject(saved) ? saved : {};
      for(const k of Object.keys(def)){
        res[k] = _deepMergePreserve(def[k], s[k]);
      }
      // extras (campos novos de vers√µes futuras)
      for(const [k,v] of Object.entries(s)){
        if(!(k in def)) res[k] = v;
      }
      return res;
    }
    return (saved === undefined) ? def : saved;
  }

  function _sanitizeProgressData(d){
    const def = defaultProgressState();
    const raw = (d && typeof d==="object") ? d : {};
    let out = _deepMergePreserve(def, raw);

    // activeCampaignId v√°lido
    const allowed = new Set(["story","post","c2","survival","survival_hc"]);
    if(!allowed.has(out.activeCampaignId)) out.activeCampaignId = def.activeCampaignId;

    // worldUnlocked (arrays boolean)
    if(!_isPlainObject(out.worldUnlocked)) out.worldUnlocked = def.worldUnlocked;

    function _fixBoolArray(arr, len, fill){
      let a = Array.isArray(arr) ? arr.slice(0, len) : [];
      a = a.map(x=>!!x);
      while(a.length < len) a.push(fill);
      return a;
    }

    out.worldUnlocked.story = _fixBoolArray(out.worldUnlocked.story, Campaigns.story.worlds.length, false);
    out.worldUnlocked.post  = _fixBoolArray(out.worldUnlocked.post,  Campaigns.post.worlds.length,  false);
    out.worldUnlocked.c2    = _fixBoolArray(out.worldUnlocked.c2,    Campaigns.c2.worlds.length,    false);
    out.worldUnlocked.survival = _fixBoolArray(out.worldUnlocked.survival, Campaigns.survival.worlds.length, true);
    out.worldUnlocked.survival_hc = _fixBoolArray(out.worldUnlocked.survival_hc, Campaigns.survival_hc.worlds.length, true);

    // world 1 always unlocked
    out.worldUnlocked.story[0] = true;
    // survival sempre dispon√≠vel
    if(out.worldUnlocked.survival.length) out.worldUnlocked.survival[0] = true;
    if(out.worldUnlocked.survival_hc.length) out.worldUnlocked.survival_hc[0] = true;

    // flags
    out.postUnlocked = !!out.postUnlocked;
    out.c2Unlocked   = !!out.c2Unlocked;

    // Heur√≠stica de retrocompatibilidade: saves antigos sem c2Unlocked
    if(typeof raw?.c2Unlocked !== "boolean"){
      try{
        const up = raw?.unlockedPlants;
        const list = (up instanceof Set) ? Array.from(up) : (Array.isArray(up) ? up : []);
        if(!!raw?.postUnlocked && list.includes("nativaClean")){
          out.c2Unlocked = true;
        }
      }catch(_e){}
    }

    // campanhas extras s√≥ liberam o primeiro mundo quando desbloqueadas
    if(out.postUnlocked) out.worldUnlocked.post[0] = true;
    if(out.c2Unlocked)   out.worldUnlocked.c2[0] = true;

    // Hardcore √© conte√∫do p√≥s-campanha 2; se ainda estiver bloqueado, volta pro modo normal
    if(!out.c2Unlocked && out.activeCampaignId==="survival_hc") out.activeCampaignId = "survival";

    // currency
    out.currency = Number.isFinite(out.currency) ? Math.max(0, Math.floor(out.currency)) : 0;

    // perks
    if(!_isPlainObject(out.perks)) out.perks = {};
    out.perks.slotPlus = _clampInt(out.perks.slotPlus, 0, 7);
    out.perks.freeCoffee = _clampInt(out.perks.freeCoffee, 0, 9999);

    // perfume customizado (especial)
    out.customPerfume = _sanitizeCustomPerfumeCfg(out.customPerfume);

    // specialOwned (somente especiais)
    let so = out.specialOwned;
    if(so instanceof Set) so = Array.from(so);
    if(!Array.isArray(so)) so = [];
    so = so.filter(id=>isSpecialPlant(id));
    so = Array.from(new Set(so));
    out.specialOwned = so;

    // unlockedPlants (somente n√£o-especiais)
    let up = out.unlockedPlants;
    if(up instanceof Set) up = Array.from(up);
    if(!Array.isArray(up)) up = def.unlockedPlants.slice();
    up = up.filter(id => plantById.has(id) && !isSpecialPlant(id));
    // ensure basics
    for(const id of def.unlockedPlants){
      if(!up.includes(id)) up.push(id);
    }
    out.unlockedPlants = up;

    // Migra√ß√£o de saves afetados por bug antigo: mundos/campanhas salvos, mas perfumes n√£o.
    // Se parece que o usu√°rio usou UNLOCKALL/LIBERATUDO (todas campanhas/mundos liberados) e ainda assim s√≥ tem os b√°sicos,
    // reconstroi a lista completa de perfumes padr√£o (exclui especiais da lojinha).
    try{
      const basicsSet = new Set(def.unlockedPlants);
      const onlyBasics = Array.isArray(out.unlockedPlants) && out.unlockedPlants.every(id=>basicsSet.has(id));
      const storyAll = Array.isArray(out.worldUnlocked?.story) && out.worldUnlocked.story.length && out.worldUnlocked.story.every(Boolean);
      const likelyCheat = !!out.postUnlocked && !!out.c2Unlocked && storyAll;
      if(likelyCheat && onlyBasics){
        out.unlockedPlants = PlantDefs.filter(p=>!isSpecialPlant(p.id)).map(p=>p.id);
      }
    }catch(_e){}

    // lastLoadout (valida + limita)
    let ll = out.lastLoadout;
    if(ll instanceof Set) ll = Array.from(ll);
    if(!Array.isArray(ll)) ll = def.lastLoadout.slice();
    ll = ll.filter(id => plantById.has(id) && id!=="shovel" && (!isSpecialPlant(id) || so.includes(id)));
    ll = Array.from(new Set(ll)).slice(0, maxLoadoutFromPerks(out.perks));
    out.lastLoadout = ll;

    // Milestones (Campanha 2): garante que os perfumes-chave venham ANTES do mundo que exige a mec√¢nica.
    if(out.c2Unlocked){
      if(!out.unlockedPlants.includes("kaiakSal")) out.unlockedPlants.push("kaiakSal");
      if(out.worldUnlocked.c2[1] && !out.unlockedPlants.includes("zaadCat")) out.unlockedPlants.push("zaadCat");
      if(out.worldUnlocked.c2[2] && !out.unlockedPlants.includes("ekosResin")) out.unlockedPlants.push("ekosResin");
    }

    return out;
  }

  function hasSavedProgress(){
    if(!STORAGE_OK) return false;
    try{ return !!_safeLSGet(SAVE_KEY) || LEGACY_SAVE_KEYS.some(k=>!!_safeLSGet(k)) || !!_safeLSGet(SAVE_BAK_KEY); }
    catch(e){ return false; }
  }

  function applyProgressData(d){
    const p = _sanitizeProgressData(d);

    // aplica campos conhecidos
    progress.activeCampaignId = p.activeCampaignId;
    progress.worldUnlocked.story = p.worldUnlocked.story;
    progress.worldUnlocked.post  = p.worldUnlocked.post;
    progress.worldUnlocked.c2    = p.worldUnlocked.c2;
    progress.worldUnlocked.survival = p.worldUnlocked.survival;
    progress.worldUnlocked.survival_hc = p.worldUnlocked.survival_hc;

    progress.unlockedPlants = new Set(p.unlockedPlants);
    progress.currency = Number.isFinite(p.currency) ? Math.max(0, Math.floor(p.currency)) : 0;
    progress.specialOwned = new Set(Array.isArray(p.specialOwned) ? p.specialOwned : []);
    progress.perks = _isPlainObject(p.perks) ? { slotPlus:_clampInt(p.perks.slotPlus,0,7), freeCoffee:_clampInt(p.perks.freeCoffee,0,9999) } : { slotPlus:0, freeCoffee:0 };
    progress.lastLoadout = Array.isArray(p.lastLoadout) ? p.lastLoadout.slice() : [];

    progress.postUnlocked = !!p.postUnlocked;
    progress.c2Unlocked   = !!p.c2Unlocked;

    progress.customPerfume = _sanitizeCustomPerfumeCfg(p.customPerfume);

    // preserva extras (campos futuros) sem interferir no jogo atual
    const KNOWN = new Set(["activeCampaignId","worldUnlocked","unlockedPlants","currency","specialOwned","perks","lastLoadout","postUnlocked","c2Unlocked","customPerfume"]);
    for(const [k,v] of Object.entries(p)){
      if(!KNOWN.has(k)){
        try{ progress[k] = v; }catch(_e){}
      }
    }

    // atualiza a defini√ß√£o do Perfume Customizado com base no save
    try{ applyCustomPerfumeDefFromProgress(); }catch(_e){}

    Campaigns.post.unlocked = progress.postUnlocked;
    Campaigns.c2.unlocked   = progress.c2Unlocked;
    return true;
  }

  function _buildSavePayload(){
    return {
      v: SAVE_VERSION,
      ts: Date.now(),
      data: _pack(progress)
    };
  }

  function saveProgress(){
    if(!STORAGE_OK) return false;
    try{
      const payload = _buildSavePayload();
      const json = JSON.stringify(payload);

      // backup do save anterior
      const prev = _safeLSGet(SAVE_KEY);
      if(prev) _safeLSSet(SAVE_BAK_KEY, prev);

      if(!_safeLSSet(SAVE_KEY, json)){
        return false;
      }
      return true;
    }catch(e){ return false; }
  }

  function _tryParseJSON(raw){
    if(!raw) return null;
    try{ return JSON.parse(raw); }catch(e){ return null; }
  }

  function loadProgress(){
    if(!STORAGE_OK) return false;

    // 1) chave nova
    let parsed = _tryParseJSON(_safeLSGet(SAVE_KEY));

    // 2) migra legacy
    if(!parsed){
      for(const k of LEGACY_SAVE_KEYS){
        parsed = _tryParseJSON(_safeLSGet(k));
        if(parsed) break;
      }
    }

    // 3) backup
    if(!parsed){
      parsed = _tryParseJSON(_safeLSGet(SAVE_BAK_KEY));
    }

    if(!parsed) return false;

    const data = parsed?.data ? parsed.data : parsed;
    const unpacked = _unpack(data);

    const ok = applyProgressData(unpacked);
    if(ok){
      // garante que, ap√≥s carregar legacy, a gente re-salve na chave est√°vel
      try{ saveProgress(); }catch(_e){}
    }
    return ok;
  }

  function clearProgressSave(){
    if(!STORAGE_OK) return false;
    _safeLSRemove(SAVE_KEY);
    _safeLSRemove(SAVE_BAK_KEY);
    for(const k of LEGACY_SAVE_KEYS) _safeLSRemove(k);
    return true;
  }

  function resetProgressToDefaults(){
    applyProgressData(defaultProgressState());
    progress.lastLoadout = normalizeLoadout(progress.lastLoadout || []);
    try{ currentLoadout = progress.lastLoadout.slice(); }catch(e){}
    try{ selectedId = null; }catch(e){}
    try{ rebuildSeedBank(); }catch(e){}
  }

  // Export/Import (garantia contra perda de save por navegador/origem/arquivo)
  function exportSaveToFile(){
    try{
      const payload = _buildSavePayload();
      const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,"-");
      a.href = url;
      a.download = `boticario-defense-save-${stamp}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1500);
      flashOverlayToast("üíæ Save exportado (arquivo).", "good");
    }catch(e){
      flashOverlayToast("‚ö†Ô∏è N√£o foi poss√≠vel exportar o save.", "warn");
    }
  }

  function importSaveFromFile(){
    try{
      const inp = document.createElement("input");
      inp.type = "file";
      inp.accept = "application/json,.json";
      inp.addEventListener("change", ()=>{
        const f = inp.files && inp.files[0];
        if(!f) return;
        const r = new FileReader();
        r.onload = ()=>{
          try{
            const parsed = JSON.parse(String(r.result||""));
            const data = parsed?.data ? parsed.data : parsed;
            const unpacked = _unpack(data);
            applyProgressData(unpacked);
            rebuildSeedBank();
            saveProgress();
            flashOverlayToast("‚úÖ Save importado com sucesso!", "good");
            renderOverlay();
          }catch(e){
            flashOverlayToast("‚ö†Ô∏è Arquivo inv√°lido / corrompido.", "warn");
          }
        };
        r.readAsText(f);
      });
      inp.click();
    }catch(e){
      flashOverlayToast("‚ö†Ô∏è N√£o foi poss√≠vel importar o save.", "warn");
    }
  }

  // autosave extra ao fechar aba
  window.addEventListener("beforeunload", ()=>{ try{ saveProgress(); }catch(_e){} });
  document.addEventListener("visibilitychange", ()=>{
    if(document.visibilityState==="hidden"){
      try{ saveProgress(); }catch(_e){}
    }
  });

  // carrega o save automaticamente (se existir)
  loadProgress();
  try{ applyCustomPerfumeDefFromProgress(); }catch(_e){}


  // ===== Loadout (m√°x. 8 perfumes por fase) =====
  function isPlantOwned(id){
    if(id==="shovel") return true;
    if(isSpecialPlant(id)) return !!(progress.specialOwned && progress.specialOwned.has && progress.specialOwned.has(id));
    return !!(progress.unlockedPlants && progress.unlockedPlants.has && progress.unlockedPlants.has(id));
  }

  function normalizeLoadout(ids){
    const src = Array.isArray(ids) ? ids : [];
    const out = [];
    const max = getMaxLoadout();

    for(const id of src){
      if(id==="shovel") continue;
      if(!plantById.has(id)) continue;
      if(!isPlantOwned(id)) continue;
      if(out.includes(id)) continue;
      out.push(id);
      if(out.length>=max) break;
    }
    // completa com outros desbloqueados (ordem do PlantDefs)
    for(const def of PlantDefs){
      if(out.length>=max) break;
      if(def.id==="shovel") continue;
      if(!isPlantOwned(def.id)) continue;
      if(out.includes(def.id)) continue;
      out.push(def.id);
    }
    return out.slice(0,max);
  }

  // garante um loadout inicial sempre v√°lido
  progress.lastLoadout = normalizeLoadout(progress.lastLoadout || []);
  saveProgress();
// ================= Runtime =================
  let mode = "menu";  // "menu" | "map" | "info" | "playing"
  let running = false; // s√≥ roda update em playing
  let paused = false;
  let won = false, lost = false;

  let currentCampaign = Campaigns.story;
  let currentWorld = null;

  // snapshot do Perfume Customizado para a fase (evita vers√µes diferentes na mesma partida)
  let matchCustomPerfumeDef = null;

  let survivalState = null;

  let aroma = 150;

  let selectedId = null;
  // Perk runtime: Free Coffee (usado 1x por mundo, ao primeiro mal cheiro)
  let perkFreeCoffeeUsed = false;
  let hoverCell = null;
  let gameTime = 0;
  let visualTime = 0; // anima√ß√µes visuais (roda mesmo fora do jogo)
  let lastTs = 0;

// tela: flash sutil (Casa 214)
let screenFlashT = 0;
let screenFlashColor = "#A9C6FF";


  const plants = Array.from({length:ROWS}, ()=>Array.from({length:COLS}, ()=>null));
  const cellLocks = Array.from({length:ROWS}, ()=>Array.from({length:COLS}, ()=>0));
  const enemies = [];
  const projectiles = [];
  const aromas = [];
  const coins = [];
  const particles = [];
  const rings = [];
  const mowers = [];
  const cooldowns = new Map();
  let spawnQueue = [];
  let waveStartTimes = [];
  let lastPlannedT = 999999;
  let nextSkyAroma = 2.0;

  // beams
  const beams = [];

  // alerts
  const alerts = [];

  // pointer hold-to-collect
  let pointerDown = false;
  let pointerMoved = false;
  let pointerConsumed = false;
  let downX = 0, downY = 0;

  // global buffs
  const globalBuffs = {
    enemySlowAllT: 0,
    beamBoostT: 0
  };

  // loadout (m√°x. 8 perfumes por fase; a p√° √© sempre inclu√≠da)
  let currentLoadout = progress.lastLoadout.slice();
  let pendingStart = null;
  let loadoutDraft = null;

  // info UI selection
  let overlayMode = "menu"; // "menu" | "map" | "loadout" | "info"
  let infoKind = "plants";  // "plants" | "enemies"
  let infoSelectedId = "sun";

  // ================= Zoom =================
  function isNarrow(){ return window.innerWidth <= 900; }
  function isShort(){ return window.innerHeight <= 620; }
  function syncMobileClass(){
    // layout mobile (barra horizontal de perfumes etc.)
    document.body.classList.toggle("mobile", isNarrow());
  }
  syncMobileClass();
  window.addEventListener("resize", syncMobileClass, {passive:true});

  let zoom = (isNarrow() || isShort()) ? 1.00 : 1.12;

  function zoomClamp(){
    if(isShort()) return {min:0.80, max:1.00};      // celular em paisagem (altura curta)
    if(isNarrow()) return {min:0.85, max:1.18};     // tablets / janela pequena
    return {min:0.90, max:1.40};                    // desktop
  }

  function applyZoom(){
    const {min,max} = zoomClamp();
    zoom = clamp(zoom, min, max);
    canvas.style.setProperty("--zoom", zoom.toFixed(2));
    zoomText.textContent = `${Math.round(zoom*100)}%`;
    zoomInBtn.disabled = zoom >= (max - 1e-6);
    zoomOutBtn.disabled = zoom <= (min + 1e-6);
  }

  zoomInBtn.addEventListener("click", ()=>{ zoom += 0.06; applyZoom(); });
  zoomOutBtn.addEventListener("click", ()=>{ zoom -= 0.06; applyZoom(); });

  // ao redimensionar / virar o celular, garante que o zoom n√£o estoure o layout
  window.addEventListener("resize", ()=>{ applyZoom(); }, {passive:true});
  window.addEventListener("orientationchange", ()=>{ setTimeout(applyZoom, 250); }, {passive:true});
  applyZoom();


  // ================= Utilities =================
  function activeOrbCount(){
    let n = 0;
    for(const s of aromas) if(!s.collected) n++;
    return n;
  }

  function activeCoinCount(){
    let n = 0;
    for(const c of coins) if(!c.collected) n++;
    return n;
  }

  function reduceAllCooldowns(amount){
    if(amount <= 0) return;
    for(const id of cooldowns.keys()){
      cooldowns.set(id, Math.max(0, (cooldowns.get(id) || 0) - amount));
    }
  }

  function healAllPlants(amount){
    if(amount <= 0) return;
    let did = false;
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const p = plants[r][c];
        if(!p) continue;
        const before = p.hp;
        p.hp = Math.min(p.maxHp, p.hp + amount);
        if(p.hp > before) did = true;
      }
    }
    if(did) ring(GRID_X + GRID_W/2, GRID_Y + GRID_H/2, "#7CFFB2", 10, 160, 0.55);
  }

  function pickFrom(pool){
    return pool[irand(0, pool.length-1)];
  }

  function pickAromaType(types){
    // simples: 70% gold, 30% special se tiver
    if(!types || types.length===0) return "gold";
    if(types.length===1) return types[0];
    const specials = types.filter(t=>t!=="gold");
    if(specials.length===0) return "gold";
    const roll = Math.random();
    if(roll < 0.70) return "gold";
    return specials[irand(0, specials.length-1)];
  }

  function trySpawnAromaOrb(x, y, typeId, falling){
    if(activeOrbCount() >= MAX_ORBS_ON_SCREEN) return false;
    const def = AromaTypes[typeId] || AromaTypes.gold;
    aromas.push({
      x,
      y: falling ? -24 : y,
      targetY:y,
      typeId: def.id,
      value: def.value,
      vy: falling ? rand(90, 140) : 0,
      life: 11,
      collected:false,
      bob: rand(0,Math.PI*2)
    });
    return true;
  }


  // ================= Moedas (Currency) =================
  function spawnCoin(x, y, value=1, falling=false){
    if(activeCoinCount() >= MAX_COINS_ON_SCREEN) return false;
    const v = Math.max(1, Math.floor(value||1));
    coins.push({
      x,
      y: falling ? -18 : y,
      targetY: y,
      value: v,
      vy: falling ? rand(120, 170) : 0,
      life: 14.5,
      collected:false,
      bob: rand(0,Math.PI*2),
      seed: rand(0,9999)
    });
    return true;
  }

  function coinUnderMouse(x,y){
    for(const c of coins){
      if(c.collected) continue;
      const dx=x-c.x, dy=y-c.y;
      if(dx*dx + dy*dy <= COIN_CLICK_R2) return c;
    }
    return null;
  }

  let _currencyDirty = false;
  let _currencySaveT = 0;

  function addCurrency(amount){
    const a = Math.max(0, Math.floor(amount||0));
    if(!a) return;
    progress.currency = Math.max(0, (progress.currency||0) + a);
    _currencyDirty = true;
    _currencySaveT = 0;
  }

  function collectCoin(c){
    if(!c || c.collected) return false;
    c.collected = true;
    addCurrency(c.value || 1);
    puff(c.x, c.y, "#FFD36A", 12);
    ring(c.x, c.y, "#FFD36A", 6, 44, 0.30);
    try{ SFX.play("ui"); }catch(_e){}
    return true;
  }

  function tryDropCoin(e){
    if(!e || !e.def) return;
    if(activeCoinCount() >= MAX_COINS_ON_SCREEN) return;

    const boss = (e.def.key==="boss1" || e.def.key==="boss2");
    const hc = !!(currentWorld && currentWorld.hardcore);

    let chance = (currentWorld && currentWorld.survival) ? (hc ? 0.20 : 0.14) : 0.10;
    let value = 1;

    if(boss){
      chance = 1.0;
      value = (e.def.key==="boss2") ? 6 : 5;
    }else if(e.def.key==="colossus"){
      chance = hc ? 0.44 : 0.38;
      value = 3;
    }else if(e.def.key==="corrosive"){
      chance = hc ? 0.30 : 0.24;
      value = 2;
    }else if(e.def.key==="shatter"){
      chance = hc ? 0.28 : 0.22;
      value = 2;
    }else if(e.def.key==="sealed" || e.def.key==="insulated" || e.def.key==="selfclean"){
      chance *= 1.25;
      value = (Math.random() < 0.35) ? 2 : 1;
    }else if(e.def.key==="armored" || e.def.key==="reflect" || e.def.key==="sticky"){
      chance *= 1.12;
      value = 1;
    }

    if(Math.random() < chance){
      spawnCoin(e.x, e.y-16, value, false);
    }
  }

  function puff(x,y, tint, amount=10){
    for(let i=0;i<amount;i++){
      particles.push({
        x, y,
        vx: rand(-90,90),
        vy: rand(-140,30),
        r: rand(2.5,7),
        a: 1,
        tint,
        life: rand(.35,.85)
      });
    }
  }

  function ring(x,y, tint, start=8, end=56, life=0.42){
    rings.push({ x,y, tint, r:start, dr:(end-start)/life, a:1, life, max:life });
  }

  function scheduleRamp(startT, ramp, isFirstWave=false){
    const scale = WAVE_TIME_SCALE;
    const n = ramp.count;
    const g0 = ramp.baseGap * 1.15 * scale;
    const g1 = ramp.baseGap * 0.75 * scale;
    let t = startT;

    for(let i=0;i<n;i++){
      const a = (n<=1) ? 1 : i/(n-1);
      const gap = (g0 + (g1-g0)*a) * ((isFirstWave && i<3) ? 1.35 : 1.0);
      spawnQueue.push({ t, row: irand(0,ROWS-1), type: pickFrom(ramp.pool) });
      t += gap;
    }
    return t - startT;
  }

  function scheduleHorde(startT, horde){
    const scale = WAVE_TIME_SCALE;
    const n = horde.count;
    const w = Math.max(0.2, (horde.window || 1.0) * (0.95 + 0.15*scale));
    for(let i=0;i<n;i++){
      const off = rand(0, w);
      spawnQueue.push({ t: startT + off, row: irand(0,ROWS-1), type: pickFrom(horde.pool) });
    }
    return w + SPAWN_THROTTLE_EXTRA_REST;
  }

  function scheduleTrickle(startT, trickle){
    const scale = WAVE_TIME_SCALE;
    const n = trickle.count;
    const g = trickle.gap * scale;
    for(let i=0;i<n;i++){
      spawnQueue.push({ t: startT + i*g, row: irand(0,ROWS-1), type: pickFrom(trickle.pool) });
    }
    return (n<=0) ? 0 : (n-1)*g;
  }

  

// ================= Survival Mode Planning =================
function survivalDifficultyForWave(waveIndex, hardcore=false){
  // 0..cap
  const cap = hardcore ? 1.25 : 1.0;
  const step = hardcore ? 0.11 : 0.08;
  return Math.min(cap, Math.max(0, (waveIndex-1) * step));
}

function survivalPool(d, hardcore=false){
  if(!hardcore){
    if(d < 0.20) return ["whiff","fast","whiff","fast","whiff"];
    if(d < 0.45) return ["fast","dense","whiff","fast","dense","toxic"];
    if(d < 0.70) return ["dense","toxic","fast","reflect","sticky","whiff","cloak"];
    return ["dense","toxic","fast","reflect","sticky","cloak","armored","fast","toxic"];
  }

  // Hardcore: inclui elites exclusivas e (mais tarde) lacres/resinas/autolimpeza
  if(d < 0.18) return ["fast","whiff","fast","dense","toxic"];
  if(d < 0.40) return ["fast","dense","toxic","reflect","sticky","whiff"];
  if(d < 0.65) return ["dense","toxic","reflect","sticky","cloak","armored","sealed","insulated","fast"];
  if(d < 0.85) return ["toxic","reflect","cloak","armored","sealed","insulated","selfclean","corrosive","shatter","fast"];
  return ["armored","sealed","insulated","selfclean","corrosive","shatter","colossus","toxic","reflect","cloak","fast"];
}

function planOneSurvivalWave(world, waveIndex, waveT){
  const hardcore = !!world?.hardcore;
  const d = survivalDifficultyForWave(waveIndex, hardcore);

  const bossEvery = hardcore ? 4 : 5;
  // boss a cada N waves
  if(waveIndex % bossEvery === 0){
    const lead = hardcore ? 2.0 : 2.2;
    addAlert(Math.max((world.prepTime||0) + 0.2, waveT - lead), hardcore ? `CHEF√ÉO HARDCORE! (Wave ${waveIndex})` : `CHEF√ÉO! (Wave ${waveIndex})`, 2.2, "bad", "lastHorde");

    // chance do boss2 aumenta a cada boss
    const baseP2 = hardcore ? 0.12 : 0.06;
    const p2 = clamp(survivalState?.boss2Chance ?? baseP2, 0, 0.92);
    const bossType = (Math.random() < p2) ? "boss2" : "boss1";

    if(survivalState){
      survivalState.bossCount = (survivalState.bossCount||0) + 1;
      const inc = hardcore ? 0.16 : 0.12;
      survivalState.boss2Chance = Math.min(0.92, (survivalState.boss2Chance||baseP2) + inc);
    }

    scheduleHorde(waveT, { count:1, window: hardcore ? 0.65 : 0.75, pool:[bossType] });

    const minCount = Math.round((hardcore ? 12 : 8) + (hardcore ? 14 : 10)*d);
    scheduleHorde(waveT + (hardcore ? 0.28 : 0.35), { count:minCount, window: hardcore ? 1.15 : 1.45, pool:survivalPool(d, hardcore) });

    // Hardcore: aftershock extra
    if(hardcore){
      const extra = Math.round(6 + 10*d);
      scheduleHorde(waveT + 0.95, { count:extra, window: 1.0, pool:["fast","toxic","shatter","corrosive"] });
    }

    return waveT + ((hardcore ? 5.1 : 5.8) * WAVE_TIME_SCALE);
  }

  // wave normal
  const rampCount = Math.round((hardcore ? 10 : 7) + (hardcore ? 16 : 12)*d);
  const baseGap = clamp((hardcore ? 3.65 : 4.2) - (hardcore ? 1.95 : 1.55)*d, hardcore ? 1.75 : 2.35, hardcore ? 3.65 : 4.2);
  const dur = scheduleRamp(waveT, { count:rampCount, baseGap, pool:survivalPool(d, hardcore) }, waveIndex===1);

  // Hardcore: micro-horda no meio (press√£o de volume)
  if(hardcore && d > 0.30){
    const midT = waveT + dur * 0.55;
    const mcount = Math.round(5 + 8*d);
    scheduleHorde(midT, { count:mcount, window: 0.9, pool: survivalPool(d, true) });
  }

  const t2 = waveT + dur + (hardcore ? 0.85 : 1.2) * WAVE_TIME_SCALE;
  const trickleCount = Math.round((hardcore ? 6 : 3) + (hardcore ? 12 : 9)*d);
  const trickleGap = clamp((hardcore ? 3.9 : 4.5) - (hardcore ? 2.35 : 2.05)*d, hardcore ? 1.75 : 2.25, hardcore ? 3.9 : 4.5);
  const dur2 = scheduleTrickle(t2, { count:trickleCount, gap:trickleGap, pool:survivalPool(d, hardcore) });

  const restBase = hardcore ? 4.6 : 6.2;
  const rest = (restBase - (hardcore ? 1.25 : 1.0)*d) * WAVE_TIME_SCALE;
  return t2 + dur2 + rest;
}

function buildSurvivalPlan(world){
  const hardcore = !!world?.hardcore;
  survivalState = { nextWave: 1, bossCount: 0, boss2Chance: hardcore ? 0.12 : 0.06, hardcore };

  spawnQueue = [];
  waveStartTimes = [];
  // alerts j√° foram inicializados fora

  let t = (world.prepTime || 18) + (world.introDelay || 0);

  // planeja um bloco inicial e deixa o update estender depois
  const initialWaves = hardcore ? 14 : 12;
  for(let i=0;i<initialWaves;i++){
    const waveIndex = survivalState.nextWave;
    const waveT = t + ((waveIndex===1) ? 1.6 * WAVE_TIME_SCALE : 0);
    waveStartTimes.push(waveT);
    t = planOneSurvivalWave(world, waveIndex, waveT);
    survivalState.nextWave++;
  }

  spawnQueue.sort((a,b)=>a.t-b.t);
  lastPlannedT = t;
  nextSkyAroma = 2.2;

  // em sobreviv√™ncia, os n√≥s da barra n√£o s√£o t√£o √∫teis (e ficariam infinitos)
  barNodes.innerHTML = "";
}

function extendSurvivalPlanIfNeeded(world){
  if(!world?.survival) return;
  if(!survivalState) return;

  // quando estiver perto do fim do plano, estende mais waves
  if(gameTime < (lastPlannedT - 35)) return;

  let t = lastPlannedT;
  const add = survivalState.hardcore ? 10 : 8;
  for(let i=0;i<add;i++){
    const waveIndex = survivalState.nextWave;
    const waveT = t + ((waveIndex===1) ? 1.6 * WAVE_TIME_SCALE : 0);
    waveStartTimes.push(waveT);
    t = planOneSurvivalWave(world, waveIndex, waveT);
    survivalState.nextWave++;
  }

  spawnQueue.sort((a,b)=>a.t-b.t);
  lastPlannedT = t;
}
function addAlert(t, text, duration=2.7, kind="bad", sfx=null){
    alerts.push({ t, text, duration, kind, sfx, played:false });
  }
  function currentAlert(){
    for(const a of alerts){
      if(gameTime >= a.t && gameTime <= a.t + a.duration){
        return { a, p: (gameTime - a.t) / a.duration };
      }
    }
    return null;
  }

  function buildWorldPlan(world){
    spawnQueue = [];
    waveStartTimes = [];
    alerts.length = 0;

    let t = (world.prepTime || 18) + (world.introDelay || 0);

    // contagem regressiva: 3, 2, 1, Perfumar!
    const introEnd = (world.prepTime || 18) + (world.introDelay || 0);
    addAlert(Math.max(0.10, introEnd - 3.0), "3", 0.9, "warn", "count3");
    addAlert(Math.max(0.10, introEnd - 2.0), "2", 0.9, "warn", "count2");
    addAlert(Math.max(0.10, introEnd - 1.0), "1", 0.9, "warn", "count1");
    addAlert(Math.max(0.10, introEnd - 0.20), "Perfumar!", 1.1, "warn", "go");


    if(world && world.survival){
      buildSurvivalPlan(world);
      return;
    }


    for(let i=0;i<world.waves.length;i++){
      const w = world.waves[i];
      const isFirstWave = (i===0);
      const waveT = t + (isFirstWave ? 1.6 * WAVE_TIME_SCALE : 0); // in√≠cio mais suave s√≥ na 1¬™ wave
      waveStartTimes.push(waveT);

      if(w.type === "ramp"){
        const dur = scheduleRamp(waveT, w.ramp, isFirstWave);
        const t2 = waveT + dur + 1.2 * WAVE_TIME_SCALE;
        const dur2 = w.trickle ? scheduleTrickle(t2, w.trickle) : 0;
        t = t2 + dur2 + (w.rest || 0) * WAVE_TIME_SCALE;
      }

      if(w.type === "horde"){
        const dur = scheduleHorde(waveT, w.horde);
        const t2 = waveT + dur + 1.4 * WAVE_TIME_SCALE;
        const dur2 = w.trickle ? scheduleTrickle(t2, w.trickle) : 0;
        t = t2 + dur2 + (w.rest || 0) * WAVE_TIME_SCALE;
      }

      if(w.type === "final"){
        if(w.warn){
          const lead = 2.8;
          addAlert(Math.max((world.prepTime||0) + 0.2, waveT - lead), "√öltima Horda!", 2.7, "bad", "lastHorde");
        }
        if(w.boss){
          scheduleHorde(waveT, w.horde);
          if(w.minions){
            scheduleHorde(waveT + 0.3, w.minions);
          }
          t = waveT + Math.max(w.horde.window||0.6, (w.minions?.window||0)) * (0.95 + 0.2*WAVE_TIME_SCALE) + 2.0 * WAVE_TIME_SCALE;
        } else {
          const dur = scheduleHorde(waveT, w.horde);
          t = waveT + dur + 2.0 * WAVE_TIME_SCALE;
        }
      }
    }

    spawnQueue.sort((a,b)=>a.t-b.t);
    lastPlannedT = t;
    nextSkyAroma = 2.2;

    barNodes.innerHTML = "";
    for(const wt of waveStartTimes){
      const left = clamp(wt / lastPlannedT, 0, 1) * 100;
      const n = document.createElement("div");
      n.className = "node";
      n.style.left = left.toFixed(2) + "%";
      barNodes.appendChild(n);
    }
  }

  function getWaveIndex(){
    let idx = 0;
    for(const wt of waveStartTimes){
      if(gameTime >= wt) idx++;
    }
    return idx;
  }
  function isPreparation(){
    if(!currentWorld) return false;
    return gameTime < (currentWorld.prepTime || 0);
  }

  function maxEnemiesForWorld(worldId){
    if(currentWorld && currentWorld.survival){
      const wi = getWaveIndex();
      const d = survivalDifficultyForWave(wi, !!currentWorld.hardcore);
      return currentWorld.hardcore ? (18 + Math.floor(18*d)) : (14 + Math.floor(12*d));
    }
    // um pouco mais "capado" no come√ßo, mas o pacing j√° t√° mais lento
    return 10 + Math.floor(worldId*1.6);
  }

  // ================= Seedbank UI =================
  const seedEls = new Map();

  function availablePlants(){
    const ids = (Array.isArray(currentLoadout) && currentLoadout.length)
      ? currentLoadout.slice(0,getMaxLoadout())
      : normalizeLoadout(progress.lastLoadout || []);

    const arr = [];
    for(const id of ids){
      if(id==="shovel") continue;
      if(!isPlantOwned(id)) continue;
      const def = plantById.get(id);
      if(def) arr.push(def);
    }
    // a p√° sempre est√° dispon√≠vel
    arr.push(plantById.get("shovel"));
    return arr;
  }

  function applySeedbankLayout(){
    if(!seedbank) return;
    const rows = 8;

    // (Compat) Se algum patch antigo deixou wrapper, desfaz.
    const prevWrap = seedbank.querySelector(":scope > .seedbankCols");
    if(prevWrap){
      const oldSeeds = Array.from(prevWrap.querySelectorAll(".seed"));
      seedbank.innerHTML = "";
      for(const s of oldSeeds) seedbank.appendChild(s);
    }

    const n = seedbank.querySelectorAll(":scope > .seed").length;
    const mult = n > rows;
    seedbank.classList.toggle("multicol", mult);

    // Colunas: 8 por coluna
    let cols = mult ? Math.ceil(n / rows) : 1;

    // Larguras (lidas do CSS pra evitar drift)
    const rootStyles = getComputedStyle(document.documentElement);
    const base = parseFloat(rootStyles.getPropertyValue("--sideBaseW")) || 240; // 1 coluna
    const colWBase = parseFloat(rootStyles.getPropertyValue("--seedColW")) || 210;
    const gap  = parseFloat(rootStyles.getPropertyValue("--seedGap")) || 10;
    const minColW = 170;

    // Por padr√£o, usamos a largura base do CSS.
    // Se faltar espa√ßo na tela, a gente tenta "apertar" as seeds horizontalmente
    // para caber todas as colunas sem scroll (e sem mexer no order/DOM).
    let colW = colWBase;
    seedbank.style.removeProperty("--seedColW");

    let desired = base + (cols - 1) * (colW + gap);

    // Queremos: painel pode crescer em colunas, mas sem esmagar a √°rea de jogo.
    // Em vez de sobrepor, o shell expande (quando houver espa√ßo) e mantemos uma folga
    // √† direita para n√£o ‚Äúcolar‚Äù e manter o campo mais central.
    const shellBase = parseFloat(rootStyles.getPropertyValue("--shellBaseW")) || 1180;
    const playTarget = parseFloat(rootStyles.getPropertyValue("--playTargetW")) || 940;
    const playMinWanted = parseFloat(rootStyles.getPropertyValue("--playMinW")) || 860;

    // Padding √† direita (compensa quando o painel cresce; mant√©m o campo mais central)
    let padRight = (desired > base) ? Math.min(base, 240) : 0;

    // Clamp baseado no viewport: garante um m√≠nimo pro campo sempre que poss√≠vel
    try{
      const avail = Math.max(320, window.innerWidth - 24); // -padding do .wrap
      const minPlay = Math.min(playMinWanted, Math.max(520, avail - base - 40)); // fallback em telas menores
      const maxSide = Math.max(base, avail - minPlay - padRight - 24);

      // 1) Primeiro, tenta caber "apertando" as seeds (horizontal) sem perder colunas.
      if(mult && cols > 1 && desired > maxSide){
        const extraForCols = Math.max(0, maxSide - base);
        const perCol = extraForCols / (cols - 1);
        const fitColW = Math.floor(perCol - gap);
        const newColW = Math.max(minColW, Math.min(colWBase, fitColW));
        const desired2 = base + (cols - 1) * (newColW + gap);
        if(desired2 <= maxSide){
          colW = newColW;
          seedbank.style.setProperty("--seedColW", String(colW));
          desired = desired2;
        }
      }

      if(desired > maxSide){
        const extra = Math.max(0, maxSide - base);
        const maxCols = 1 + Math.floor(extra / (colW + gap));
        const clampedCols = Math.max(1, maxCols);
        desired = base + (clampedCols - 1) * (colW + gap);

        // Se precisou clamp, habilita scroll horizontal s√≥ no seedbank (√∫ltimo recurso)
        if(mult && clampedCols < cols){
          seedbank.style.overflowX = "auto";
          seedbank.style.paddingBottom = "8px";
        }else{
          seedbank.style.overflowX = "";
          seedbank.style.paddingBottom = "";
        }
        cols = clampedCols;
      }else{
        seedbank.style.overflowX = "";
        seedbank.style.paddingBottom = "";
      }
    }catch(e){
      seedbank.style.overflowX = "";
      seedbank.style.paddingBottom = "";
    }

    // Aplicar larguras: painel empurra (sem sobrepor) e o shell tenta manter o campo grande.
    document.documentElement.style.setProperty("--sideW", desired + "px");
    // Ajusta padding-right ‚Äúvirtual‚Äù para deixar o jogo mais central quando h√° colunas extras
    document.documentElement.style.setProperty("--sidePadW", padRight + "px");

    const shellDesired = Math.max(shellBase, shellBase + (desired - base) + padRight);
    document.documentElement.style.setProperty("--shellW", shellDesired + "px");
  }
function rebuildSeedBank(){
    seedbank.innerHTML = "";
    seedEls.clear();

    for(const p of availablePlants()){
      const el = document.createElement("div");
      el.className = "seed";
      el.dataset.id = p.id;
      el.innerHTML = `
        <div class="icon">${p.icon}</div>
        <div class="meta">
          <div class="name">${p.name}</div>
          <div class="desc">${p.desc}</div>
          <div class="cost"><span class="costNum">${p.cost}</span> aromas</div>
        </div>
        <div class="cool"><span class="coolTxt">0.0s</span></div>
      `;

      el.addEventListener("mousedown", (ev)=> ev.preventDefault());
      el.addEventListener("click", ()=>{
        if(mode !== "playing") return;
        if(selectedId === p.id){ selectedId = null; SFX.play("ui"); }
        else { selectedId = p.id; SFX.play("select"); }
        syncSeedUI();
      });

      seedbank.appendChild(el);
      seedEls.set(p.id, el);
    }

        applySeedbankLayout();

if(selectedId && !isPlantOwned(selectedId)) selectedId = null;
    syncSeedUI();
  }

  function syncSeedUI(){
    for(const [id, el] of seedEls){
      el.classList.toggle("selected", selectedId === id);

      const def = plantById.get(id);
      const rem = cooldowns.get(id) || 0;
      el.classList.toggle("cooling", rem>0);

      const coolTxt = el.querySelector(".coolTxt");
      if(coolTxt) coolTxt.textContent = `${rem.toFixed(1)}s`;

      const costEl = el.querySelector(".cost");
      if(costEl && def){
        const affordable = def.cost <= aroma;
        costEl.classList.toggle("good", affordable);
        costEl.classList.toggle("bad", !affordable);
      }
    }
  }

  // ================= Overlay (Menu/Map/Info) =================
  function showOverlay(modeName){
    overlayMode = modeName;
    overlay.classList.add("show");
    renderOverlay();
  }
  function hideOverlay(){
    overlay.classList.remove("show");
  }

  tabMenu.addEventListener("click", ()=>{ overlayMode="menu"; renderOverlay(); });
  tabMap.addEventListener("click",  ()=>{ overlayMode="map";  renderOverlay(); });
  tabInfo.addEventListener("click", ()=>{ overlayMode="info"; renderOverlay(); });

  btnCloseOverlay.addEventListener("click", hideOverlay);

  btnMenu.addEventListener("click", ()=> showOverlay("menu"));
  btnMap.addEventListener("click",  ()=> showOverlay("map"));
  btnInfo.addEventListener("click", ()=> showOverlay("info"));

  
  function buySpecialPlant(id){
    if(!id || !isSpecialPlant(id)) return false;
    const def = plantById.get(id);
    const price = SPECIAL_SHOP[id]?.price || 0;

    // j√° comprado
    if(progress.specialOwned && progress.specialOwned.has(id)){
      if(id==="customPerfume"){
        flashOverlayToast("üß™ Editar perfume customizado.", "good");
        openCustomPerfumeEditor();
      }else{
        flashOverlayToast("‚úÖ J√° comprado.", "good");
      }
      return true;
    }

    if((progress.currency||0) < price){
      flashOverlayToast("‚ùå Moedas insuficientes.", "bad");
      return false;
    }

    progress.currency = Math.max(0, (progress.currency||0) - price);
    progress.specialOwned.add(id);

    // se for o custom, aplica a defini√ß√£o atual (mesmo antes de editar)
    if(id==="customPerfume"){
      try{ applyCustomPerfumeDefFromProgress(); }catch(_e){}
    }

    // garante loadout v√°lido e atualiza sele√ß√£o
    progress.lastLoadout = normalizeLoadout(progress.lastLoadout || []);
    rebuildSeedBank();
    saveProgress();

    flashOverlayToast(`‚úÖ Comprou: ${def?def.icon:"‚ú®"} ${def?def.name:id}!`, "good");

    if(id==="customPerfume"){
      openCustomPerfumeEditor();
    }else{
      renderOverlay();
    }
    return true;
  }

  // ================= Perks (meta-upgrades) =================
  const PERK_DEFS = {
    slotPlus: {
      id:"slotPlus",
      icon:"‚ûï",
      name:"+1 slot m√°ximo",
      desc:"Aumenta o m√°ximo de perfumes no loadout em +1.",
      max:7,
      basePrice: 120,
      stepPrice: 90
    },
    freeCoffee: {
      id:"freeCoffee",
      icon:"‚òï",
      name:"Free Coffee",
      desc:"Perk consum√≠vel: ao aparecer o primeiro mal cheiro do mundo, gasta 1 token e planta automaticamente 1 Coffee Armadilha gr√°tis na linha dele, na √∫ltima coluna (se ocupado, tenta colunas anteriores).",
      max: 9999,
      price: 150
    }
  };

  function perkCount(id){
    if(!progress.perks) progress.perks = {slotPlus:0, freeCoffee:0};
    return _clampInt(progress.perks[id], 0, 9999);
  }
  function perkPrice(id){
    const d = PERK_DEFS[id];
    if(!d) return 999999;
    if(id==="slotPlus"){
      const n = _clampInt(perkCount("slotPlus"), 0, d.max);
      return d.basePrice + n * d.stepPrice;
    }
    return d.price || 0;
  }
  function perkAtMax(id){
    const d = PERK_DEFS[id];
    if(!d) return true;
    if(id==="freeCoffee") return false;
    return perkCount(id) >= (d.max||0);
  }
  function buyPerk(id){
    const d = PERK_DEFS[id];
    if(!d) return false;

    if(!progress.perks) progress.perks = {slotPlus:0, freeCoffee:0};

    if(perkAtMax(id)){
      flashOverlayToast("‚úÖ Perk j√° est√° no m√°ximo.", "good");
      return true;
    }

    const price = perkPrice(id);
    if((progress.currency||0) < price){
      flashOverlayToast("‚ùå Moedas insuficientes.", "bad");
      return false;
    }

    progress.currency = Math.max(0, (progress.currency||0) - price);
    progress.perks[id] = perkCount(id) + 1;

    // garante loadout v√°lido (se o usu√°rio perdeu plantas/ownership)
    progress.lastLoadout = normalizeLoadout(progress.lastLoadout || []);
    try{ currentLoadout = progress.lastLoadout.slice(); }catch(_e){}
    rebuildSeedBank();

    saveProgress();

    flashOverlayToast(`‚úÖ Comprou perk: ${d.icon} ${d.name}!`, "good");
    renderOverlay();
    return true;
  }

function renderOverlay(){

    tabMenu.classList.toggle("active", overlayMode==="menu");
    tabMap.classList.toggle("active", overlayMode==="map" || overlayMode==="loadout");
    tabInfo.classList.toggle("active", overlayMode==="info" || overlayMode==="custom");

    overlayBody.innerHTML = "";

    if(overlayMode === "menu"){
      renderMenu();
    } else if(overlayMode === "map"){
      renderMap();
    } else if(overlayMode === "loadout"){
      renderLoadout();
    } else if(overlayMode === "custom"){
      renderCustomPerfume();
    } else {
      renderInfo();
    }
  }


  // ================= Cheats (c√≥digo secreto no Menu) =================
  // No Menu Principal, digite: LIBERATUDO (ou UNLOCKALL)
  // Para ganhar moedas: MEDEMONEYPLS ( +50 ü™ô )
  // ou d√™ duplo clique no t√≠tulo e cole o c√≥digo.
  let _cheatBuf = "";
  let _cheatLast = 0;

  function flashOverlayToast(msg, kind="good"){
    const t = document.createElement("div");
    t.textContent = msg;
    t.style.position = "fixed";
    t.style.left = "50%";
    t.style.bottom = "18px";
    t.style.transform = "translateX(-50%)";
    t.style.padding = "10px 14px";
    t.style.borderRadius = "999px";
    t.style.background = "rgba(5,8,20,.92)";
    t.style.border = "1px solid rgba(255,255,255,.16)";
    t.style.boxShadow = "0 16px 40px rgba(0,0,0,.55)";
    t.style.zIndex = "9999";
    t.style.color = "var(--ink)";
    t.style.fontSize = "13px";
    t.style.pointerEvents = "none";
    if(kind==="bad") t.style.borderColor = "rgba(255,106,106,.55)";
    if(kind==="warn") t.style.borderColor = "rgba(255,211,106,.55)";
    document.body.appendChild(t);
    setTimeout(()=>{ t.style.opacity="0"; t.style.transition="opacity .25s ease"; }, 1400);
    setTimeout(()=> t.remove(), 1700);
  }

  function cheatUnlockAll(){
    // campanhas
    progress.postUnlocked = true;
    progress.c2Unlocked = true;

    // mundos
    progress.worldUnlocked.story = Campaigns.story.worlds.map(_=>true);
    progress.worldUnlocked.post  = Campaigns.post.worlds.map(_=>true);
    progress.worldUnlocked.c2    = Campaigns.c2.worlds.map(_=>true);
    progress.worldUnlocked.survival = Campaigns.survival.worlds.map(_=>true);
    progress.worldUnlocked.survival_hc = Campaigns.survival_hc.worlds.map(_=>true);

    // perfumes/plantas
    progress.unlockedPlants = new Set(PlantDefs.filter(p=>!isSpecialPlant(p.id)).map(p=>p.id));
    // especiais permanecem travados (s√≥ compra)

    // mant√©m loadout v√°lido
    progress.lastLoadout = normalizeLoadout(progress.lastLoadout || []);
    saveProgress();

    try{ SFX.play("ui"); }catch(_e){}
    flashOverlayToast("‚úÖ C√≥digo aceito: campanhas + perfumes padr√£o liberados (especiais ainda exigem ü™ô moedas).", "good");
    renderOverlay(); // atualiza bot√µes/locks
  }

  function cheatGiveMoney(amount=50){
    const a = Math.max(1, Math.floor(amount||0));
    addCurrency(a);
    saveProgress();
    try{ SFX.play("ui"); }catch(_e){}
    flashOverlayToast(`ü™ô +${a} moedas!`, "good");
    renderOverlay();
  }

  function _cheatTry(buf){
    const up = (buf || "").toUpperCase();
    if(up.endsWith("LIBERATUDO") || up.endsWith("UNLOCKALL")){
      cheatUnlockAll();
      return true;
    }
    if(up.endsWith("MEDEMONEYPLS")){
      cheatGiveMoney(50);
      return true;
    }
    return false;
  }

  document.addEventListener("keydown", (e)=>{
    if(overlayMode !== "menu") return;
    if(e.ctrlKey || e.metaKey || e.altKey) return;
    if(e.repeat) return;

    const now = performance.now();
    if(now - _cheatLast > 1200) _cheatBuf = "";
    _cheatLast = now;

    const k = e.key;

    if(k === "Enter"){
      if(_cheatTry(_cheatBuf)) _cheatBuf = "";
      return;
    }
    if(k === "Backspace"){
      _cheatBuf = _cheatBuf.slice(0, -1);
      return;
    }
    if(k === "Escape"){
      _cheatBuf = "";
      return;
    }

    if(k && k.length === 1 && /[a-z0-9]/i.test(k)){
      _cheatBuf = (_cheatBuf + k).slice(-24);
      if(_cheatTry(_cheatBuf)) _cheatBuf = "";
    }
  }, { passive:true });


  function renderMenu(){
    overlayTitle.textContent = "Menu";
    overlayDesc.textContent = "";

    const wrap = document.createElement("div");
    wrap.className = "menuCompact";

    const header = document.createElement("div");
    header.className = "menuHeader";

    const title = document.createElement("div");
    title.className = "menuTitle";
    title.textContent = "Botic√°rio Defense";
    title.addEventListener("dblclick", ()=>{
      const code = prompt("C√≥digo secreto:");
      if(!code) return;
      const up = String(code).trim().toUpperCase();
      if(up === "LIBERATUDO" || up === "UNLOCKALL"){
        cheatUnlockAll();
      }else if(up === "MEDEMONEYPLS"){
        cheatGiveMoney(50);
      }else{
        try{ SFX.play("select"); }catch(_e){}
        flashOverlayToast("‚ùå C√≥digo incorreto.", "bad");
      }
    });

    const meta = document.createElement("div");
    meta.className = "menuMeta";
    const c = Number.isFinite(progress.currency) ? progress.currency : 0;
    const s = (progress.specialOwned && typeof progress.specialOwned.size === "number") ? progress.specialOwned.size : 0;
    meta.innerHTML = `
      <span class="chip">ü™ô ${c}</span>
      <span class="chip">‚≠ê Especiais: ${s}</span>
      <span class="chip">Som: ${SFX.isEnabled() ? "ON" : "OFF"}</span>
    `;

    header.appendChild(title);
    header.appendChild(meta);

    const big = document.createElement("button");
    big.className = "menuPlayBig";

    function campLabel(id){
      if(id==="story") return "Campanha 1";
      if(id==="post") return "P√≥s-Hist√≥ria";
      if(id==="c2") return "Campanha 2";
      if(id==="survival") return "Sobreviv√™ncia";
      if(id==="survival_hc") return "Sobreviv√™ncia HARDCORE";
      return id;
    }
    function pickContinueCampaign(){
      if(progress.c2Unlocked) return "c2";
      if(progress.postUnlocked) return "post";
      return "story";
    }
    function pickContinueWorld(campId){
      const camp = Campaigns[campId];
      const arr = (progress.worldUnlocked && progress.worldUnlocked[campId]) ? progress.worldUnlocked[campId] : [];
      let idx = Array.isArray(arr) ? arr.lastIndexOf(true) : -1;
      if(idx < 0) idx = 0;
      if(!camp || !camp.worlds || !camp.worlds.length) return { campaignId: campId, world: null };
      idx = Math.min(idx, camp.worlds.length-1);
      return { campaignId: campId, world: camp.worlds[idx] };
    }

    const contCamp = pickContinueCampaign();
    const cont = pickContinueWorld(contCamp);
    big.textContent = cont.world ? `JOGAR ‚Äî ${campLabel(cont.campaignId)} ‚Ä¢ ${cont.world.name}` : "JOGAR";
    big.addEventListener("click", ()=>{
      const campId = cont.campaignId;
      const w = cont.world;
      if(!w){ overlayMode="map"; renderOverlay(); return; }
      progress.activeCampaignId = campId;
      saveProgress();
      pendingStart = { campaignId: campId, worldId: w.id };
      loadoutDraft = normalizeLoadout(progress.lastLoadout || []);
      overlayMode = "loadout";
      renderOverlay();
    });

    const grid = document.createElement("div");
    grid.className = "menuGrid";

    const btnWorld = document.createElement("button");
    btnWorld.textContent = "Selecionar mundo";
    btnWorld.addEventListener("click", ()=>{ overlayMode="map"; renderOverlay(); });

    const btnSurvival = document.createElement("button");
    btnSurvival.textContent = "Modo sobreviv√™ncia";
    btnSurvival.addEventListener("click", ()=>{
      progress.activeCampaignId = "survival";
      saveProgress();
      overlayMode="map"; renderOverlay();
    });

    const btnSurvivalHC = document.createElement("button");
    btnSurvivalHC.textContent = progress.c2Unlocked ? "Sobreviv√™ncia HARDCORE" : "Sobreviv√™ncia HARDCORE üîí";
    btnSurvivalHC.disabled = !progress.c2Unlocked;
    btnSurvivalHC.addEventListener("click", ()=>{
      progress.activeCampaignId = "survival_hc";
      saveProgress();
      overlayMode="map"; renderOverlay();
    });

    const btnExport = document.createElement("button");
    btnExport.textContent = "Salvar (exportar)";
    btnExport.addEventListener("click", ()=>{ exportSaveToFile(); });

    const btnImport = document.createElement("button");
    btnImport.textContent = "Carregar (importar)";
    btnImport.addEventListener("click", ()=>{ importSaveFromFile(); });

    const btnReset = document.createElement("button");
    btnReset.className = "danger";
    btnReset.textContent = "Resetar progresso";
    btnReset.addEventListener("click", ()=>{
      clearProgressSave();
      resetProgressToDefaults();
      saveProgress();
      overlayMode="menu";
      renderOverlay();
    });

    grid.appendChild(btnWorld);
    grid.appendChild(btnSurvival);
    grid.appendChild(btnSurvivalHC);
    grid.appendChild(btnExport);
    grid.appendChild(btnImport);
    grid.appendChild(btnReset);

    const hint = document.createElement("div");
    hint.className = "menuHint";
    hint.innerHTML = `Dica: <b>Exportar save</b> √© o jeito mais seguro de n√£o perder progresso.`;

    wrap.appendChild(header);
    wrap.appendChild(big);
    wrap.appendChild(grid);
    wrap.appendChild(hint);

    overlayBody.appendChild(wrap);
  }

  function renderMap(){
    overlayTitle.textContent = "Mapa";
    if(progress.activeCampaignId==="survival"){
      overlayDesc.textContent = "Sobreviva o m√°ximo poss√≠vel. A cada 5 waves surge um boss e a dificuldade sobe at√© um teto.";
    }else if(progress.activeCampaignId==="survival_hc"){
      overlayDesc.textContent = "Hardcore: waves mais r√°pidas, inimigos mais fortes (escala por wave) e elites exclusivas. Boss a cada 4 waves.";
    }else{
      overlayDesc.textContent = "Escolha um mundo. A P√≥s-Hist√≥ria libera ao vencer a Campanha 1. A Campanha 2 libera ao concluir a P√≥s-Hist√≥ria.";
    }

    const campTabs = document.createElement("div");
    campTabs.className = "campaignTabs";

    const storyBtn = document.createElement("button");
    storyBtn.className = "tabBtn" + (progress.activeCampaignId==="story" ? " active" : "");
    storyBtn.textContent = "Campanha 1";
    storyBtn.addEventListener("click", ()=>{ progress.activeCampaignId="story"; saveProgress(); renderOverlay(); });

    const postBtn = document.createElement("button");
    postBtn.className = "tabBtn" + (progress.activeCampaignId==="post" ? " active" : "");
    postBtn.textContent = progress.postUnlocked ? "P√≥s-Hist√≥ria" : "P√≥s-Hist√≥ria üîí";
    postBtn.disabled = !progress.postUnlocked;
    postBtn.addEventListener("click", ()=>{ progress.activeCampaignId="post"; saveProgress(); renderOverlay(); });

    campTabs.appendChild(storyBtn);
    campTabs.appendChild(postBtn);


    const c2Btn = document.createElement("button");
    c2Btn.className = "tabBtn" + (progress.activeCampaignId==="c2" ? " active" : "");
    c2Btn.textContent = progress.c2Unlocked ? "Campanha 2" : "Campanha 2 üîí";
    c2Btn.disabled = !progress.c2Unlocked;
    c2Btn.addEventListener("click", ()=>{ progress.activeCampaignId="c2"; saveProgress(); renderOverlay(); });

    campTabs.appendChild(c2Btn);

    const survivalBtn = document.createElement("button");
    survivalBtn.className = "tabBtn" + (progress.activeCampaignId==="survival" ? " active" : "");
    survivalBtn.textContent = "Sobreviv√™ncia";
    survivalBtn.addEventListener("click", ()=>{ progress.activeCampaignId="survival"; saveProgress(); renderOverlay(); });
    campTabs.appendChild(survivalBtn);

    const survivalHcBtn = document.createElement("button");
    survivalHcBtn.className = "tabBtn" + (progress.activeCampaignId==="survival_hc" ? " active" : "");
    survivalHcBtn.textContent = progress.c2Unlocked ? "Hardcore" : "Hardcore üîí";
    survivalHcBtn.disabled = !progress.c2Unlocked;
    survivalHcBtn.addEventListener("click", ()=>{ progress.activeCampaignId="survival_hc"; saveProgress(); renderOverlay(); });
    campTabs.appendChild(survivalHcBtn);


    overlayBody.appendChild(campTabs);

    const camp = Campaigns[progress.activeCampaignId];
    const wrap = document.createElement("div");
    wrap.className = "worlds";

    camp.worlds.forEach((w, idx)=>{
      const unlocked = progress.worldUnlocked[camp.id][idx];
      const reward = w.rewardPlant ? plantById.get(w.rewardPlant) : null;

      const card = document.createElement("div");
      card.className = "world" + (unlocked ? "" : " locked");
      card.innerHTML = `
        <div class="title">${w.name}</div>
        <div class="tag"><span class="miniDot" style="background:${unlocked ? "#7CFFB2" : "rgba(255,255,255,.25)"}"></span>${unlocked ? "Dispon√≠vel" : "Bloqueado"}</div>
        <div class="small">${w.desc}</div>
        <div class="small"><b>Gimmick:</b> ${w.gimmick || "‚Äî"}</div>
        <div class="tag"><span class="miniDot" style="background:#FFD36A"></span>Recompensa: ${reward ? `${reward.icon} ${reward.name}` : (idx===camp.worlds.length-1 ? "‚Äî (final)" : "‚Äî")}</div>
      `;

      const btn = document.createElement("button");
      btn.textContent = unlocked ? "Escolher perfumes" : "Bloqueado";
      btn.disabled = !unlocked;
      btn.addEventListener("click", ()=>{
        pendingStart = { campaignId: camp.id, worldId: w.id };
        loadoutDraft = normalizeLoadout(progress.lastLoadout || []);
        overlayMode = "loadout";
        renderOverlay();
      });

      card.appendChild(btn);
      wrap.appendChild(card);
    });

  
  overlayBody.appendChild(wrap);
  }

  // ===== Loadout (pr√©-fase) =====
  function worldEnemyKeys(world){
    if(world && Array.isArray(world.enemyPreview) && world.enemyPreview.length){
      return Array.from(new Set(world.enemyPreview));
    }
    const set = new Set();
    const addPool = (pool)=>{ if(Array.isArray(pool)) for(const k of pool) set.add(k); };
    for(const w of (world.waves||[])){
      if(w.ramp) addPool(w.ramp.pool);
      if(w.trickle) addPool(w.trickle.pool);
      if(w.horde) addPool(w.horde.pool);
      if(w.minions) addPool(w.minions.pool);
    }
    return Array.from(set);
  }

  function renderLoadout(){
    overlayTitle.textContent = "Sele√ß√£o de perfumes";
    overlayDesc.textContent = `Escolha at√© ${getMaxLoadout()} perfumes para levar na partida (a p√° √© sempre inclu√≠da).`;

    if(!pendingStart){
      const p = document.createElement('p');
      p.className = 'small';
      p.textContent = 'Selecione um mundo no mapa para montar o loadout.';
      overlayBody.appendChild(p);
      const b = document.createElement('button');
      b.textContent = 'Voltar ao mapa';
      b.addEventListener('click', ()=>{ overlayMode='map'; renderOverlay(); });
      overlayBody.appendChild(b);
      return;
    }

    const camp = Campaigns[pendingStart.campaignId];
    const world = (camp && camp.worlds)
      ? (camp.worlds.find(x=>Number(x.id)===Number(pendingStart.worldId)) || camp.worlds.find(x=>String(x.id)===String(pendingStart.worldId)))
      : null;

    if(!world){
      overlayTitle.textContent = "Sele√ß√£o de perfumes";
      overlayDesc.textContent = "N√£o consegui carregar o mundo selecionado. Volte ao mapa e selecione novamente.";
      const b = document.createElement('button');
      b.textContent = 'Voltar ao mapa';
      b.addEventListener('click', ()=>{ overlayMode='map'; renderOverlay(); });
      overlayBody.appendChild(b);
      return;
    }

    overlayTitle.textContent = `Sele√ß√£o de perfumes ‚Äî ${world.name}`;

    if(loadoutDraft==null) loadoutDraft = normalizeLoadout(progress.lastLoadout || []);

    const sec = document.createElement('div');
    sec.className = 'section';
    sec.innerHTML = `<b>Mal cheiros deste mundo</b><p>${world.desc}</p>`;

    const row = document.createElement('div');
    row.className = 'enemyRow';
    for(const k of worldEnemyKeys(world)){
      const e = EnemyDefs[k];
      if(!e) continue;
      const isBoss = (k==='boss1' || k==='boss2');
      const chip = document.createElement('span');
      chip.className = 'chip ' + (isBoss ? 'bad' : (e.requiresPurify ? 'warn' : 'good'));
      chip.innerHTML = `<span class='miniDot' style='background:${e.tint}'></span>${e.glyph} ${e.name}`;
      row.appendChild(chip);
    }
    sec.appendChild(row);
    overlayBody.appendChild(sec);

    const slots = document.createElement('div');
    slots.className = 'loadoutSlots';
    const picks = Array.isArray(loadoutDraft) ? loadoutDraft : [];
    for(let i=0;i<getMaxLoadout();i++){
      const s = document.createElement('div');
      const id = picks[i];
      if(id){
        const def = plantById.get(id);
        s.className = 'slot';
        s.innerHTML = `${def?def.icon:'‚ùî'} ${def?def.name:id}`;
      }else{
        s.className = 'slot empty';
        s.textContent = `Vazio ${i+1}`;
      }
      slots.appendChild(s);
    }
    overlayBody.appendChild(slots);

    const btns = document.createElement('div');
    btns.className = 'loadoutBtns';

    const btnAuto = document.createElement('button');
    btnAuto.textContent = 'Auto (sugerir)';
    btnAuto.addEventListener('click', ()=>{ loadoutDraft = normalizeLoadout([]); renderOverlay(); });

    const btnClear = document.createElement('button');
    btnClear.textContent = 'Limpar';
    btnClear.addEventListener('click', ()=>{ loadoutDraft = []; renderOverlay(); });

    const btnBack = document.createElement('button');
    btnBack.textContent = 'Voltar ao mapa';
    btnBack.addEventListener('click', ()=>{ overlayMode='map'; renderOverlay(); });

    const btnStart = document.createElement('button');
    btnStart.className = 'primary';
    btnStart.textContent = 'Come√ßar fase';
    btnStart.addEventListener('click', ()=>{
      currentLoadout = normalizeLoadout(loadoutDraft || []);
      progress.lastLoadout = currentLoadout.slice();
      saveProgress();
      const ps = pendingStart;
      pendingStart = null;
      startWorld(ps.campaignId, ps.worldId);
      addAlert(0.35, 'PERFUMES SELECIONADOS', 2.2, 'warn');
      hideOverlay();
    });

    btns.appendChild(btnAuto);
    btns.appendChild(btnClear);
    btns.appendChild(btnBack);
    btns.appendChild(btnStart);
    overlayBody.appendChild(btns);

    const grid = document.createElement('div');
    grid.className = 'loadoutGrid';
    const unlocked = PlantDefs.filter(p => isPlantOwned(p.id) && p.id!=='shovel');
    for(const def of unlocked){
      const card = document.createElement('div');
      card.className = 'pickCard' + (picks.includes(def.id) ? ' selected' : '');
      card.innerHTML = `
        <div class='pickHead'>
          <div class='pickIcon'>${def.icon}</div>
          <div class='pickMeta'>
            <div class='pickName'>${def.name}</div>
            <div class='pickDesc'>${def.desc}</div>
          </div>
        </div>
        <div class='pickFoot'>
          <span class='tag'><span class='miniDot' style='background:#FFD36A'></span>${def.cost} aromas</span>
          <span class='tag'><span class='miniDot' style='background:${def.tint}'></span>${def.kind}</span>
        </div>
      `;
      card.addEventListener('click', ()=>{
        let a = Array.isArray(loadoutDraft) ? loadoutDraft.slice() : [];
        const idx = a.indexOf(def.id);
        if(idx>=0) a.splice(idx,1);
        else { if(a.length>=getMaxLoadout()) return; a.push(def.id); }
        loadoutDraft = a;
        renderOverlay();
      });
      grid.appendChild(card);
    }
    overlayBody.appendChild(grid);
  }

  // ===== Info (fichas clic√°veis) =====
  function plantHow(def){
    // especiais (Campanha 2)
    if(def.id==="kaiakSal"){
      const t = def.salt?.time ?? 5;
      return `Atira cristais de sal a cada ${def.fireRate.toFixed(2)}s (dano ${def.dmg}). Marca o alvo com <b>Saliniza√ß√£o</b> por ${t.toFixed(1)}s ‚Äî isso quebra lacres e permite que o <b>Purificador</b> volte a afetar Brumas Lacradas.`;
    }
    if(def.id==="ekosResin"){
      const t = def.resin?.time ?? 6;
      const mult = def.resin?.mult ?? 0.86;
      return `Atira resina a cada ${def.fireRate.toFixed(2)}s (dano ${def.dmg}). Marca o alvo com <b>Resina</b> por ${t.toFixed(1)}s ‚Äî reduz levemente a velocidade (√ó${mult}) e quebra isolamentos, permitindo que o <b>Purificador</b> volte a afetar Brumas Isolantes.`;
    }
    if(def.id==="zaadCat"){
      const t = def.cataTime ?? 4.6;
      return `Pulsa catalisador a cada ${def.pulse.toFixed(1)}s. Perfumes adjacentes ficam <b>Catalisados</b> por ${t.toFixed(1)}s: quando aplicarem Sal/Resina, a dura√ß√£o das marca√ß√µes aumenta (combos mais consistentes).`;
    }
    if(def.kind==="sun"){
      const n = Math.max(1, Math.floor(def.twin||1));
      return `Gera ${n} fragr√¢ncia${n>1?"s":""} a cada ${def.genRate.toFixed(1)}s. (Moeda para plantar.)`;
    }
    if(def.kind==="shooter"){
      if(def.doubleShot){
        return `Atira <b>2</b> gotas de fragr√¢ncia a cada ${def.fireRate.toFixed(2)}s, cada uma causando ${def.dmg} de dano ao primeiro mal cheiro da linha.`;
      }
      const n = def.shotCount || 1;
      const shotTxt = (n>1) ? `Atira <b>${n}</b> proj√©teis` : `Atira 1 proj√©til`;
      if(def.burn){
        return `${shotTxt} a cada ${def.fireRate.toFixed(2)}s (dano ${def.dmg}) e aplica <b>Fogo</b>: ${def.burn.dps} DPS por ${def.burn.time.toFixed(1)}s.`;
      }
      if(def.poison){
        return `${shotTxt} a cada ${def.fireRate.toFixed(2)}s (dano ${def.dmg}) e aplica <b>Veneno</b>: ${def.poison.dps} DPS por ${def.poison.time.toFixed(1)}s.`;
      }
      return `${shotTxt} a cada ${def.fireRate.toFixed(2)}s, causando ${def.dmg} de dano ao primeiro mal cheiro da linha.`;
    }
if(def.kind==="cone"){
      return `A cada ${def.fireRate.toFixed(2)}s, solta um spray que acerta at√© ${def.hits} mal cheiros pr√≥ximos (alcance ~${def.range}). Cada acerto causa ${def.dmg} de dano.`;
    }
    if(def.kind==="wall"){
      return `N√£o ataca. Serve para segurar a linha com muita vida (${def.hp}).`;
    }
    if(def.kind==="refil"){
      const upMax = (def.upMax!=null ? def.upMax : 3);
      const upMul = (def.upMul!=null ? def.upMul : 1.18);
      return `S√≥ pode ser usado <b>em cima de outro perfume</b>. Ao aplicar, o Refil fica ‚Äúpendurado‚Äù por 2s e ent√£o sobe 1 n√≠vel (m√°x. ${upMax}): aumenta <b>dano</b> e <b>vida m√°xima</b> (√ó${upMul}) e cura instantaneamente proporcional ao HP extra. O Refil some e n√£o ocupa o tile.`;
    }
    if(def.kind==="slow"){
      const n = def.shotCount || 1;
      const shotTxt = (n>1) ? `Atira <b>${n}</b> proj√©teis` : `Atira 1 proj√©til`;
      const slowTxt = ` e aplicando lento (x${def.slowMult}) por ${def.slowTime.toFixed(1)}s`;
      if(def.burn){
        return `${shotTxt} a cada ${def.fireRate.toFixed(2)}s (dano ${def.dmg})${slowTxt} e <b>Fogo</b>: ${def.burn.dps} DPS por ${def.burn.time.toFixed(1)}s.`;
      }
      if(def.poison){
        return `${shotTxt} a cada ${def.fireRate.toFixed(2)}s (dano ${def.dmg})${slowTxt} e <b>Veneno</b>: ${def.poison.dps} DPS por ${def.poison.time.toFixed(1)}s.`;
      }
      return `${shotTxt} a cada ${def.fireRate.toFixed(2)}s, causando ${def.dmg} de dano${slowTxt}.`;
    }
    if(def.kind==="healer"){
      return `A cada ${def.healRate.toFixed(1)}s, cura +${def.healAmount} de vida das plantas adjacentes (cima/baixo/esquerda/direita). N√£o cura a si mesmo.`;
    }
    if(def.kind==="bomb"){
      if(def.doom){
        const rad = (def.blastRadius!=null ? def.blastRadius : 240);
        const lt  = (def.lockTime!=null ? def.lockTime : 60);
        return `Depois de plantar, explode em ~${def.fuse.toFixed(1)}s numa <b>√°rea circular</b> grande (raio ~${rad}). Causa ${def.dmg} de dano em m√∫ltiplas lanes e cria uma <b>cratera</b>: o tile fica indispon√≠vel por ${lt}s. Some ap√≥s explodir.`;
      }
      return `Depois de plantar, explode em ~${def.fuse.toFixed(1)}s e causa ${def.dmg} de dano nos mal cheiros da mesma linha (faixa). Some ap√≥s explodir.`;
    }
    if(def.kind==="beam"){
      return `Ataca continuamente com "bateria": a cada ${def.tickRate.toFixed(1)}s aplica dano (DPS ${def.dps}) ao primeiro mal cheiro na linha (alcance ${def.range}). Quanto menor a bateria, menor o dano. A bateria recarrega em pulsos: a cada ${def.batteryPulseEvery}s recupera ${Math.round(def.batteryPulseAmount*100)}% (com buff do Arbo Booster, ${Math.round(def.batteryPulseAmountBoost*100)}%) e o consumo do beam tamb√©m fica menor. Ao purificar um mal cheiro reativo pela primeira vez, gasta 50% da carga de uma vez. Quando o raio toca um mal cheiro reativo, a purifica√ß√£o respinga numa pequena √°rea no ponto de impacto.`;
    }
    if(def.kind==="lens"){
      return `N√£o ataca. Quando um Purificador est√° atirando na mesma linha, o Prisma refrata a luz: cria feixes extras para linhas vizinhas e habilita dano especial em chef√µes da p√≥s-hist√≥ria.`;
    }    if(def.kind==="trap"){
      const arm = (def.armTime && def.armTime>0) ? `Depois de plantar, leva ~${Math.round(def.armTime)}s para armar (antes disso fica inativa). ` : "";
      const post = def.postSlowTime ? ` Ap√≥s o stun, aplica lento por ~${def.postSlowTime.toFixed(1)}s.` : "";
      return `${arm}Armadilha: quando um mal cheiro encosta, ele fica atordoado por ~${def.stun.toFixed(1)}s e recebe dano. A armadilha explode e causa dano em √°rea na linha.${post} Some ap√≥s ativar.`;
    }
    if(def.kind==="booster"){
      return `A cada ${def.pulse.toFixed(1)}s, d√° um buff nas plantas adjacentes por ${def.buffTime.toFixed(1)}s: elas atacam mais r√°pido e com mais dano.`;
    }
    if(def.kind==="cleanser"){
      return `A cada ${def.pulse.toFixed(1)}s, remove veneno e grude das plantas ao redor (inclui si mesmo), cura um pouco e cria um escudo de espuma (absorve dano) que dura alguns segundos. Quando um escudo estoura, empurra levemente mal cheiros pr√≥ximos.`;
    }
    return def.desc || "‚Äî";
  }

  function enemyHow(def){
    // especiais (Campanha 2)
    if(def.key==="sealed"){
      return `Vem com <b>lacre</b>: enquanto n√£o estiver <b>Salinizada</b>, fica imune ao Purificador e recebe menos dano. Use <b>Kaiak Sal</b> para abrir o lacre e ent√£o finalize.`;
    }
    if(def.key==="insulated"){
      return `Vem com <b>isolamento</b>: enquanto n√£o estiver <b>Resinada</b>, fica imune ao Purificador e recebe menos dano. Use <b>Ekos Resina</b> para quebrar o isolamento e ent√£o finalize.`;
    }
    if(def.key==="selfclean"){
      const r = def.cleanseAura?.rate ?? 3;
      return `Tem uma <b>aura autolimpante</b>: a cada ~${r.toFixed(1)}s, remove marca√ß√µes (Sal/Resina) de aliados pr√≥ximos, atrapalhando seus combos. Foque nela cedo.`;
    }
    let base = `Anda pela linha e morde a planta ao encostar. Mordida: ${def.damage} a cada ${def.biteRate.toFixed(2)}s.`;
    if(def.poison){
      base += ` Aplica veneno (${def.poison.dps} DPS por ${def.poison.time.toFixed(1)}s).`;
    }
    if(def.requiresPurify){
      base += ` Enquanto n√£o for purificado, toma muito menos dano de ataques comuns.`;
    }
    if(def.reflectProjectiles){
      base += ` Nega proj√©teis comuns (at√© ser purificado).`;
    }
    if(def.evasive){
      base += ` Alguns ataques comuns falham at√© ser purificado.`;
    }
    if(def.dmgReduction){
      base += ` Tem redu√ß√£o de dano (principalmente antes da purifica√ß√£o).`;
    }
    if(def.stickyDebuff){
      base += ` Pode aplicar ‚Äúgrude‚Äù que deixa seus ataques mais lentos por ${def.stickyDebuff.time.toFixed(1)}s.`;
    }
    if(def.onDieSpawn){
      base += ` Ao morrer, se fragmenta em ${def.onDieSpawn.count} brumas menores.`;
    }
    if(def.key==="boss2"){
      base += ` Chef√£o com escudo extra (barra de vida adicional). O escudo pode ser quebrado aos poucos, mas cai MUITO mais r√°pido com o combo: Purificador + buff do Arbo Booster + Elys√©e Prisma na mesma linha.`;
    }
    return base;
  }

  function renderInfo(){
    overlayTitle.textContent = "Info (Fichas)";
    overlayDesc.textContent = "Clique em um perfume ou mal cheiro para ver como funciona, stats e lore.";
    if(infoKind==="perks") overlayDesc.textContent = "Compre perks com ü™ô moedas para facilitar a gameplay (efeitos persistem no save).";
    if(infoKind==="orbs") overlayDesc.textContent = "Fragr√¢ncias (orbs) s√£o colet√°veis no mapa e d√£o aromas instant√¢neos.";


    const topTabs = document.createElement("div");
    topTabs.className = "campaignTabs";

    const b1 = document.createElement("button");
    b1.className = "tabBtn" + (infoKind==="plants" ? " active" : "");
    b1.textContent = "Perfumes";
    b1.addEventListener("click", ()=>{ infoKind="plants"; infoSelectedId="sun"; renderOverlay(); });

    const b2 = document.createElement("button");
    b2.className = "tabBtn" + (infoKind==="enemies" ? " active" : "");
    b2.textContent = "Mal cheiros";
    b2.addEventListener("click", ()=>{ infoKind="enemies"; infoSelectedId="whiff"; renderOverlay(); });

    const b3 = document.createElement("button");
    b3.className = "tabBtn" + (infoKind==="orbs" ? " active" : "");
    b3.textContent = "Fragr√¢ncias (orbs)";
    b3.addEventListener("click", ()=>{
      // abre listagem r√°pida de orbs usando o mesmo layout
      infoKind="orbs"; infoSelectedId="gold"; renderOverlay();
    });

    const b4 = document.createElement("button");
    b4.className = "tabBtn" + (infoKind==="perks" ? " active" : "");
    b4.textContent = "Perks";
    b4.addEventListener("click", ()=>{
      infoKind="perks"; infoSelectedId="slotPlus"; renderOverlay();
    });

    topTabs.appendChild(b1);
    topTabs.appendChild(b2);
    topTabs.appendChild(b3);
    topTabs.appendChild(b4);
    overlayBody.appendChild(topTabs);

    const currencyLine = document.createElement("div");
    currencyLine.className = "small";
    currencyLine.style.marginTop = "6px";
    currencyLine.innerHTML = `ü™ô <b>${progress.currency||0}</b> moedas <span style="opacity:.7">‚Ä¢ Chance de drop ao derrotar mal cheiros (qualquer modo).</span>`;
    overlayBody.appendChild(currencyLine);

    const layout = document.createElement("div");
    layout.className = "infoLayout";

    const list = document.createElement("div");
    list.className = "infoList";

    const detail = document.createElement("div");
    detail.className = "infoDetail";

    function addItem(id, icon, title, subtitle, locked){
      const item = document.createElement("div");
      item.className = "infoItem" + (id===infoSelectedId ? " active" : "") + (locked ? " locked" : "");
      item.innerHTML = `
        <div class="ic">${icon}</div>
        <div style="min-width:0;">
          <div class="t1">${title} ${locked ? "<span class='small'>‚Ä¢ (bloqueado)</span>" : ""}</div>
          <div class="t2">${subtitle}</div>
        </div>
      `;
      item.addEventListener("click", ()=>{
        infoSelectedId = id;
        renderOverlay();
      });
      list.appendChild(item);
    }

    if(infoKind==="plants"){
      for(const p of PlantDefs){
        if(p.id==="shovel") continue;
        const sp = isSpecialPlant(p.id);
        const locked = !isPlantOwned(p.id);
        const sub = sp ? `${p.desc} ‚Ä¢ ü™ô ${SPECIAL_SHOP[p.id].price}` : p.desc;
        addItem(p.id, p.icon, p.name, sub, locked);
      }
      addItem("shovel", plantById.get("shovel").icon, plantById.get("shovel").name, "Ferramenta", false);

      const def = plantById.get(infoSelectedId) || plantById.get("sun");
      const sp = isSpecialPlant(def.id);
      const locked = def.id!=="shovel" && !isPlantOwned(def.id);
      const price = sp ? (SPECIAL_SHOP[def.id]?.price || 0) : 0;

      detail.innerHTML = `
        <div class="detailHead">
          <div class="detailIcon">${def.icon}</div>
          <div>
            <h3 class="detailTitle">${def.name} ${locked ? "<span class='small'>‚Ä¢ (bloqueado)</span>" : ""}</h3>
            <div class="detailSubtitle">${def.desc}</div>
          </div>
        </div>

        <div class="chips">
          <span class="chip">ü™ô Moedas: ${progress.currency||0}</span>
          ${sp ? `<span class="chip warn">ESPECIAL</span>` : ""}
          ${sp ? `<span class="chip">Pre√ßo: ü™ô ${price}</span>` : ""}
          <span class="chip warn">Custo: ${def.cost}</span>
          <span class="chip good">Cooldown: ${def.cooldown}s</span>
          <span class="chip">HP: ${def.hp}</span>
          <span class="chip">${def.kind.toUpperCase()}</span>
        </div>

        <div class="section">
          <b>Como funciona (na pr√°tica)</b>
          <p>${plantHow(def)}</p>
        </div>

        <div class="section">
          <b>Dicas r√°pidas</b>
          <p>${
            def.kind==="sun" ? "Plante cedo e em quantidade suficiente para sustentar a economia." :
            def.kind==="wall" ? "Use para ganhar tempo no come√ßo e segurar hordas enquanto monta dano atr√°s." :
            def.kind==="healer" ? "Deixe ele ao lado de plantas valiosas (ele cura s√≥ adjacentes). √ìtimo para manter tanques e DPS vivos." :
            def.kind==="beam" ? "Na p√≥s-hist√≥ria, ele ‚Äòativa‚Äô o dano contra brumas reativas. Combine com o Elys√©e Prisma." :
            def.kind==="lens" ? "Coloque entre o Purificador e a linha de frente. Isso aumenta cobertura e habilita dano especial em chef√µes." :
            def.kind==="trap" ? "Segura picos: use para parar um inimigo que escapou ou para abrir tempo durante hordas." :
            def.id==="kaiakSal" ? "Essencial contra Bruma Lacrada: marque com Sal e finalize com Purificador/DPS." :
            def.id==="ekosResin" ? "Essencial contra Bruma Isolante: resine para ‚Äògrudar‚Äô o alvo e abrir para Purificador." :
            def.id==="zaadCat" ? "Catalise seus marcadores (Kaiak/Ekos) para manter lacres quebrados por mais tempo." :
            def.kind==="booster" ? "Buffa o que estiver em volta: funciona melhor num bloco 2x2 de atacantes." :
            def.kind==="cleanser" ? "Excelente contra veneno e para ‚Äòmanter o campo leve‚Äô em mundos com press√£o cont√≠nua." :
            "Combina bem com uma forma√ß√£o est√°vel: tanque na frente + dano atr√°s."
          }</p>
        </div>


        ${sp ? `
        <div class="section">
          <b>Lojinha</b>
          <p>Este √© um <b>perfume especial</b>: ele s√≥ desbloqueia comprando com ü™ô moedas (cheats n√£o liberam).</p>
          ${locked ? `
            <div class="buyRow">
              <button class="buyBtn" id="buySpecialBtn">Comprar por ü™ô ${price}</button>
              <span class="buyHint">${(progress.currency||0) >= price ? "Pronto para comprar." : "Moedas insuficientes no momento."}</span>
            </div>
          ` : `<p class="buyHint">‚úÖ J√° comprado e dispon√≠vel na sua sele√ß√£o de perfumes.</p>`}
        </div>
        ` : ""}

        <div class="loreBox">‚Äú${def.lore || "‚Äî"}‚Äù</div>
      `;

      // compra de especiais
      if(sp){
        const btn = detail.querySelector("#buySpecialBtn");
        if(btn){
          btn.disabled = (progress.currency||0) < price;
          if(def.id==="customPerfume") btn.textContent = "Comprar + customizar";
          btn.addEventListener("click", (ev)=>{
            ev.preventDefault();
            buySpecialPlant(def.id);
          });
        }

        // editar: Perfume Customizado
        if(def.id==="customPerfume" && !locked){
          const row = detail.querySelector(".buyRow") || detail;
          const edit = document.createElement("button");
          edit.className = "buyBtn";
          edit.textContent = "Editar perfume";
          edit.style.marginLeft = "8px";
          edit.addEventListener("click", (ev)=>{
            ev.preventDefault();
            openCustomPerfumeEditor();
          });
          row.appendChild(edit);
        }
      }

    }

    if(infoKind==="enemies"){
      const order = ["whiff","fast","dense","toxic","reflect","sticky","cloak","armored","sealed","insulated","selfclean","corrosive","shatter","colossus","boss1","boss2"];
      for(const k of order){
        const e = EnemyDefs[k];
        if(!e) continue;
        addItem(e.key, e.glyph, e.name, "Mal cheiro", false);
      }

      const def = EnemyDefs[infoSelectedId] || EnemyDefs.whiff;

      detail.innerHTML = `
        <div class="detailHead">
          <div class="detailIcon">${def.glyph}</div>
          <div>
            <h3 class="detailTitle">${def.name}</h3>
            <div class="detailSubtitle">Mal cheiro ‚Ä¢ ${def.key.toUpperCase()}</div>
          </div>
        </div>

        <div class="chips">
          <span class="chip warn">HP: ${def.hp}</span>
          <span class="chip">Vel: ${def.speed}</span>
          <span class="chip bad">Mordida: ${def.damage}</span>
          <span class="chip">Cad√™ncia: ${def.biteRate}s</span>
          ${def.requiresPurify ? `<span class="chip bad">Reativo (precisa purificar)</span>` : ""}
          ${def.purifierImmune ? `<span class="chip warn">Imune ao Purificador</span>` : ""}
          ${(def.purifierImmune && def.purifierImmuneType) ? `<span class="chip good">Quebra com ${def.purifierImmuneType==="salt"?"SAL":"RESINA"}</span>` : ""}
          ${def.cleanseAura ? `<span class="chip warn">Limpa marca√ß√µes</span>` : ""}
          ${def.poison ? `<span class="chip warn">Veneno</span>` : ""}
          ${def.reflectProjectiles ? `<span class="chip warn">Nega proj√©teis</span>` : ""}
          ${def.evasive ? `<span class="chip warn">Camuflado</span>` : ""}
        </div>

        <div class="section">
          <b>Como funciona (na pr√°tica)</b>
          <p>${enemyHow(def)}</p>
        </div>

        <div class="section">
          <b>Contra-jogo</b>
          <p>${
            def.key==="sealed" ? "Quebre o lacre com Kaiak Sal. Enquanto n√£o estiver Salinizada, o Purificador n√£o faz efeito. Depois do Sal, finalize com Purificador/DPS." :
            def.key==="insulated" ? "Quebre o isolamento com Ekos Resina. Enquanto n√£o estiver Resinada, o Purificador n√£o faz efeito. Depois da Resina, finalize com Purificador/DPS." :
            def.key==="selfclean" ? "Priorize cedo: ela remove Sal/Resina dos aliados, atrapalhando seus combos. Use burst/armadilhas para tir√°-la do campo r√°pido." :
            def.key==="colossus" ? "Purifique o quanto antes: antes da purifica√ß√£o ele aguenta demais (redu√ß√£o alta) e quebra sua linha no tempo. Segure com parede/armadilha e finalize com Purificador + DPS concentrado." :
            def.key==="corrosive" ? "Priorize: ela aplica veneno e grude. Use Nativa Clean para remover veneno e evite deixar empilhar. Burst/armadilhas ajudam muito." :
            def.key==="shatter" ? "Controle de volume: ao morrer ela se fragmenta em menores. Use cone/AoE e mantenha armadilhas prontas pra segurar o enxame." :
            def.requiresPurify ? "Use Purificador (e depois finalize com DPS). Sem purificar, o tempo ‚Äòescapa‚Äô." :
            def.key==="fast" ? "Trave cedo: parede + tiro constante ou armadilha." :
            def.key==="dense" ? "Dano cont√≠nuo e linhas refor√ßadas. N√£o deixe ela chegar inteira." :
            def.key==="toxic" ? "Priorize: veneno faz bola de neve. Clean ajuda bastante." :
            "Forma√ß√£o padr√£o: tanque + dano."
          }</p>
        </div>

        <div class="loreBox">‚Äú${def.lore || "‚Äî"}‚Äù</div>
      `;
    }

    if(infoKind==="perks"){
      // lista de perks
      const lv = _clampInt(perkCount("slotPlus"), 0, 7);
      const maxNow = getMaxLoadout();
      addItem("slotPlus", PERK_DEFS.slotPlus.icon, PERK_DEFS.slotPlus.name, `N√≠vel: ${lv}/7 ‚Ä¢ M√°x atual: ${maxNow}`, false);

      const fc = perkCount("freeCoffee");
      addItem("freeCoffee", PERK_DEFS.freeCoffee.icon, PERK_DEFS.freeCoffee.name, `Tokens: ${fc} ‚Ä¢ ü™ô ${perkPrice("freeCoffee")}`, false);

      const d = PERK_DEFS[infoSelectedId] || PERK_DEFS.slotPlus;
      const owned = perkCount(d.id);
      const price = perkPrice(d.id);
      const atMax = perkAtMax(d.id);
      const canBuy = !atMax && (progress.currency||0) >= price;

      const effect = (d.id==="slotPlus")
        ? `M√°ximo de perfumes por mundo: <b>${MAX_LOADOUT}</b> + n√≠vel (${owned}) = <b>${MAX_LOADOUT + owned}</b>.`
        : `Perk consum√≠vel: quando aparecer o <b>primeiro</b> mal cheiro do mundo, gasta <b>1 token</b> e planta <b>1</b> Coffee Armadilha gr√°tis na linha dele (prioriza √∫ltima coluna; se ocupado, tenta colunas anteriores).`;

      detail.innerHTML = `
        <div class="detailHead">
          <div class="detailIcon">${d.icon}</div>
          <div>
            <h3 class="detailTitle">${d.name}</h3>
            <div class="detailSubtitle">Perk ‚Ä¢ ${d.id.toUpperCase()}</div>
          </div>
        </div>

        <div class="chips">
          <span class="chip">ü™ô Moedas: ${progress.currency||0}</span>
          <span class="chip good">${d.id==="freeCoffee" ? `Tokens: ${owned}` : `Comprado: ${owned}${d.id==="slotPlus" ? "/7" : ""}`}</span>
          ${d.id==="slotPlus" ? `<span class="chip warn">M√°x atual: ${getMaxLoadout()}</span>` : ""}
          <span class="chip">Pre√ßo: ü™ô ${price}</span>
        </div>

        <div class="section">
          <b>O que faz</b>
          <p>${d.desc}</p>
          <p class="small">${effect}</p>
        </div>

        <div class="section">
          <b>Comprar</b>
          ${atMax ? `<p class="buyHint">‚úÖ Voc√™ j√° est√° no m√°ximo deste perk.</p>` : `
            <div class="buyRow">
              <button class="buyBtn" id="buyPerkBtn">Comprar por ü™ô ${price}</button>
              <span class="buyHint">${canBuy ? "Pronto para comprar." : "Moedas insuficientes no momento."}</span>
            </div>
          `}
        </div>
      `;

      const btn = detail.querySelector("#buyPerkBtn");
      if(btn){
        btn.disabled = (progress.currency||0) < price;
        btn.addEventListener("click", (ev)=>{ ev.preventDefault(); buyPerk(d.id); });
      }
    }

    if(infoKind==="orbs"){
      const keys = Object.keys(AromaTypes);
      for(const k of keys){
        const a = AromaTypes[k];
        addItem(a.id, a.icon, a.name, `+${a.value} aromas`, false);
      }
      const def = AromaTypes[infoSelectedId] || AromaTypes.gold;
      detail.innerHTML = `
        <div class="detailHead">
          <div class="detailIcon">${def.icon}</div>
          <div>
            <h3 class="detailTitle">${def.name}</h3>
            <div class="detailSubtitle">Fragr√¢ncia (orb) ‚Ä¢ +${def.value} aromas</div>
          </div>
        </div>

        <div class="chips">
          <span class="chip warn">Valor: +${def.value}</span>
          <span class="chip good">Colet√°vel com arraste</span>
          <span class="chip">Tipo: ${def.id.toUpperCase()}</span>
        </div>

        <div class="section">
          <b>O que faz</b>
          <p>${def.how}</p>
        </div>

        <div class="loreBox">‚Äú${def.lore}‚Äù</div>
      `;
    }

    layout.appendChild(list);
    layout.appendChild(detail);
    overlayBody.appendChild(layout);
  }


  // ================= Perfume Customizado (Editor) =================
  let _customTmpCfg = null;

  function openCustomPerfumeEditor(){
    if(mode==="playing" && !won && !lost){
      flashOverlayToast("‚ö†Ô∏è Edite o perfume customizado fora da fase (no menu/mapa).", "warn");
      return;
    }
    _customTmpCfg = _sanitizeCustomPerfumeCfg(progress.customPerfume || defaultCustomPerfumeCfg());
    overlayMode = "custom";
    overlay.classList.add("show");
    renderOverlay();
  }

  function renderCustomPerfume(){
    overlayTitle.textContent = "Perfume Customizado";
    overlayDesc.textContent = "Monte seu pr√≥prio perfume: tipo, frasco, emoji, texto do frasco e for√ßa. For√ßa maior = mais caro para plantar e maior cooldown.";

    // bloqueio: precisa ter comprado
    const owned = !!(progress.specialOwned && progress.specialOwned.has && progress.specialOwned.has("customPerfume"));
    if(!owned){
      const warn = document.createElement("div");
      warn.className = "section";
      warn.innerHTML = `
        <b>Bloqueado</b>
        <p class="small">Voc√™ ainda n√£o comprou o Perfume Customizado na lojinha (aba Info ‚Üí Perfumes).</p>
        <div class="buyRow">
          <button class="buyBtn" id="goInfoBuy">Ir para a lojinha</button>
          <span class="buyHint">Compre primeiro para desbloquear a customiza√ß√£o.</span>
        </div>
      `;
      overlayBody.appendChild(warn);
      warn.querySelector("#goInfoBuy").addEventListener("click", ()=>{
        overlayMode = "info";
        infoKind = "plants";
        infoSelectedId = "customPerfume";
        renderOverlay();
      });
      return;
    }

    const cfg = _customTmpCfg ? _customTmpCfg : _sanitizeCustomPerfumeCfg(progress.customPerfume || defaultCustomPerfumeCfg());
    _customTmpCfg = cfg;

    const form = document.createElement("div");
    form.className = "section";
    form.innerHTML = `
      <div class="small" style="opacity:.9; margin-bottom:8px;">
        Dica: se ficar muito forte, compensa com custo/cooldown maiores.  
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <div style="flex:1; min-width:260px;">
          <div class="small" style="margin:6px 0 4px;">Nome</div>
          <input id="cName" class="input" placeholder="Nome do perfume" />
          <div class="small" style="margin:10px 0 4px;">Emoji</div>
          <input id="cIcon" class="input" placeholder="Ex: üß™" />
          <div class="small" style="margin:10px 0 4px;">Texto no frasco (at√© 6)</div>
          <input id="cLabel" class="input" placeholder="Ex: CUSTOM" />
        </div>

        <div style="flex:1; min-width:260px;">
          <div class="small" style="margin:6px 0 4px;">Tipo</div>
          <select id="cKind" class="input"></select>

          <div id="cChargeBox" style="display:none; margin-top:10px;">
            <div class="small" style="margin:0 0 4px;">Charge Shot ‚Äî tempo de carga: <b id="cChargeVal"></b>s</div>
            <input id="cCharge" type="range" min="0.8" max="3.0" step="0.1" style="width:100%;" />
            <div class="small" style="opacity:.75; margin-top:4px;">Na fase: espere carregar e <b>clique no perfume</b> para atirar.</div>
          </div>

          
          <div id="cInfuseBox" style="display:none; margin-top:10px;">
            <div class="small" style="margin:0 0 4px;">Infuse ‚Äî buff em cima de outro perfume</div>
            <div class="small" style="opacity:.75; margin-bottom:6px;">Na fase: s√≥ pode ser usado <b>em cima</b> de outro perfume. <b>Substitui</b> qualquer Infuse anterior no alvo (n√£o acumula).</div>
            <div class="small" style="margin:0 0 4px;">Tipo de buff</div>
            <select id="cInfType" class="input">
              <option value="resist">üõ° Resist√™ncia</option>
              <option value="power">üí™ For√ßa</option>
              <option value="shield">ü´ß Escudo</option>
              <option value="regen">üíö Recover HP</option>
              <option value="haste">‚ö° Cad√™ncia</option>
            </select>

            <div class="small" style="margin:10px 0 4px;">Intensidade: <b id="cInfStrVal"></b>/10</div>
            <input id="cInfStr" type="range" min="1" max="10" step="1" style="width:100%;" />

            <label class="small" style="display:flex; align-items:center; gap:8px; margin-top:10px;">
              <input id="cInfPerm" type="checkbox" />
              Permanente (na fase) ‚Äî muito mais caro
            </label>

            <div id="cInfDurBox" style="margin-top:10px;">
              <div class="small" style="margin:0 0 4px;">Dura√ß√£o: <b id="cInfDurVal"></b>s</div>
              <input id="cInfDur" type="range" min="2.0" max="20.0" step="0.5" style="width:100%;" />
            </div>
          </div>

<div class="small" style="margin:10px 0 4px;">Frasco</div>
          <select id="cBottle" class="input"></select>

          <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
            <div style="flex:1; min-width:150px;">
              <div class="small" style="margin:0 0 4px;">Cor do frasco</div>
              <input id="cBottleTint" type="color" class="input" style="height:42px; padding:6px;" />
            </div>
            <div style="flex:1; min-width:150px;">
              <div class="small" style="margin:0 0 4px;">Cor do proj√©til/aura</div>
              <input id="cProjTint" type="color" class="input" style="height:42px; padding:6px;" />
            </div>
          </div>

          <div class="small" style="margin:10px 0 4px;">For√ßa:
          <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
            <div style="flex:1; min-width:150px;">
              <div class="small" style="margin:0 0 4px;">Proj√©teis por tiro: <b id="cShotVal"></b></div>
              <input id="cShot" type="range" min="1" max="5" step="1" style="width:100%;" />
            </div>
            <div style="flex:1; min-width:150px;">
              <div class="small" style="margin:0 0 4px;">Efeito extra</div>
              <select id="cEffect" class="input">
                <option value="none">Nenhum</option>
                <option value="fire">üî• Flamejante (Fogo)</option>
                <option value="poison">‚ò†Ô∏è Veneno</option>
                <option value="frost">‚ùÑÔ∏è Gelo (Slow)</option>
                <option value="resin">üü† Resina (Diminui avan√ßo)</option>
                <option value="stun">‚ú® Stun curto</option>
              </select>
            </div>
          </div>

          <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
            <div style="flex:1; min-width:200px;">
              <label class="small" style="display:flex; align-items:center; gap:8px;">
                <input id="cPierce" type="checkbox" />
                Atravessa (Pierce)
              </label>
              <div class="small" style="margin:4px 0 4px; opacity:.85;">Limite de hits: <b id="cPierceVal"></b></div>
              <input id="cPierceHits" type="range" min="1" max="5" step="1" style="width:100%;" />
            </div>

            <div style="flex:1; min-width:200px;">
              <label class="small" style="display:flex; align-items:center; gap:8px;">
                <input id="cAoe" type="checkbox" />
                AoE no impacto
              </label>
              <div class="small" style="margin:4px 0 4px; opacity:.85;">Raio: <b id="cAoeVal"></b> px</div>
              <input id="cAoeRad" type="range" min="40" max="220" step="10" style="width:100%;" />
              <div class="small" style="opacity:.75; margin-top:4px;">(dano splash ~45% em c√≠rculo)</div>
            </div>
          </div>

          <div id="cCadBox" style="margin-top:10px;">
            <div class="small" style="margin:0 0 4px;">Cad√™ncia do tiro</div>
            <select id="cCadMode" class="input">
              <option value="auto">Auto (por for√ßa)</option>
              <option value="manual">Manual</option>
            </select>
            <div style="margin-top:10px;">
              <div class="small" style="margin:0 0 4px;">Intervalo real: <b id="cCadVal"></b>s <span style="opacity:.85;">(m√≠n: <b id="cCadMin"></b>s)</span></div>
              <input id="cCad" type="range" min="0.40" max="3.00" step="0.05" style="width:100%;" />
              <div id="cCadReason" class="small" style="opacity:.75; margin-top:4px;"></div>
            </div>
          </div>

          <div class="small" style="margin:10px 0 4px;">For√ßa: <b id="cStrVal"></b>/10</div>
          <input id="cStrength" type="range" min="1" max="10" step="1" style="width:100%;" />
        

<div class="small" style="margin:10px 0 4px;">HP</div>
<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end;">
  <div style="flex:1; min-width:170px;">
    <div class="small" style="margin:0 0 4px;">Modo</div>
    <select id="cHpMode" class="input">
      <option value="auto">Auto (por for√ßa)</option>
      <option value="manual">Manual</option>
    </select>
  </div>
  <div style="flex:2; min-width:220px;">
    <div class="small" style="margin:0 0 4px;">HP: <b id="cHpVal"></b></div>
    <input id="cHp" type="range" min="140" max="950" step="25" style="width:100%;" />
    <div class="small" style="opacity:.8; margin-top:4px;">HP manual ‚Üë custo/cooldown. Caps variam por tipo.</div>
  </div>
</div>
</div>
      </div>

      <div class="section" style="margin-top:12px;">
        <b>Preview</b>
        <div id="cPreview" class="small" style="margin-top:6px;"></div>
      </div>

      <div class="buyRow" style="margin-top:12px;">
        <button class="buyBtn" id="cSave">Salvar</button>
        <button class="buyBtn" id="cReset" style="opacity:.85;">Reset</button>
        <button class="buyBtn" id="cCancel" style="opacity:.85;">Voltar</button>
        <span class="buyHint">Voc√™ pode editar depois quando quiser.</span>
      </div>
    `;
    overlayBody.appendChild(form);

    // inputs
    const elName = form.querySelector("#cName");
    const elIcon = form.querySelector("#cIcon");
    const elLabel = form.querySelector("#cLabel");
    const elKind = form.querySelector("#cKind");
    const elChargeBox = form.querySelector("#cChargeBox");
    const elCharge = form.querySelector("#cCharge");
    const elChargeVal = form.querySelector("#cChargeVal");
    const elInfuseBox = form.querySelector("#cInfuseBox");
    const elInfType = form.querySelector("#cInfType");
    const elInfStr = form.querySelector("#cInfStr");
    const elInfStrVal = form.querySelector("#cInfStrVal");
    const elInfPerm = form.querySelector("#cInfPerm");
    const elInfDurBox = form.querySelector("#cInfDurBox");
    const elInfDur = form.querySelector("#cInfDur");
    const elInfDurVal = form.querySelector("#cInfDurVal");
    const elBottle = form.querySelector("#cBottle");
    const elBottleTint = form.querySelector("#cBottleTint");
    const elProjTint = form.querySelector("#cProjTint");
    const elShot = form.querySelector("#cShot");
    const elShotVal = form.querySelector("#cShotVal");
    const elEffect = form.querySelector("#cEffect");
    const elPierce = form.querySelector("#cPierce");
    const elPierceHits = form.querySelector("#cPierceHits");
    const elPierceVal = form.querySelector("#cPierceVal");
    const elAoe = form.querySelector("#cAoe");
    const elAoeRad = form.querySelector("#cAoeRad");
    const elAoeVal = form.querySelector("#cAoeVal");
    const elCadBox = form.querySelector("#cCadBox");
    const elCadMode = form.querySelector("#cCadMode");
    const elCad = form.querySelector("#cCad");
    const elCadVal = form.querySelector("#cCadVal");
    const elCadMin = form.querySelector("#cCadMin");
    const elCadReason = form.querySelector("#cCadReason");
    const elStr = form.querySelector("#cStrength");
    const elStrVal = form.querySelector("#cStrVal");
    const elHpMode = form.querySelector("#cHpMode");
    const elHp = form.querySelector("#cHp");
    const elHpVal = form.querySelector("#cHpVal");
    const elPrev = form.querySelector("#cPreview");

    elName.value = cfg.name || "";
    elIcon.value = cfg.icon || "";
    elLabel.value = cfg.label || "";
    elStr.value = String(cfg.strength || 5);
    elStrVal.textContent = String(cfg.strength || 5);
    if(elHpMode) elHpMode.value = cfg.hpMode || "auto";
    // hp slider bounds depend on kind
    const _hpCaps0 = getCustomHpCaps(cfg.kind||"shooter");
    if(elHp){ elHp.min = String(_hpCaps0.min); elHp.max = String(_hpCaps0.max); elHp.step = String(_hpCaps0.step); }
    if(typeof cfg.hp!=="number") cfg.hp = _clampInt(cfg.hp, _hpCaps0.min, _hpCaps0.max) || _hpCaps0.min;
    if(elHp) elHp.value = String(_clampInt(cfg.hp, _hpCaps0.min, _hpCaps0.max));
    if(elHpVal) elHpVal.textContent = String(_clampInt(cfg.hp, _hpCaps0.min, _hpCaps0.max));

    if(elBottleTint) elBottleTint.value = cfg.bottleTint || "#8DE1FF";
    if(elProjTint) elProjTint.value = cfg.projTint || (cfg.bottleTint || "#8DE1FF");

    if(elShot) elShot.value = String(cfg.shotCount || 1);
    if(elShotVal) elShotVal.textContent = String(cfg.shotCount || 1);
    if(elEffect) elEffect.value = cfg.effect || "none";

    if(elCharge){ elCharge.value = String(cfg.chargeTime!=null ? cfg.chargeTime : 1.8); }
    if(elChargeVal){ elChargeVal.textContent = String((cfg.chargeTime!=null ? cfg.chargeTime : 1.8).toFixed ? (cfg.chargeTime!=null ? cfg.chargeTime : 1.8).toFixed(1) : (cfg.chargeTime!=null ? cfg.chargeTime : 1.8)); }

    // Etapa 12 (Infuse)
    if(elInfType) elInfType.value = cfg.infuseType || "resist";
    if(elInfStr) elInfStr.value = String(cfg.infuseStrength || 5);
    if(elInfStrVal) elInfStrVal.textContent = String(cfg.infuseStrength || 5);
    if(elInfPerm) elInfPerm.checked = !!cfg.infusePermanent;
    if(elInfDur){ elInfDur.value = String(cfg.infuseDuration!=null ? cfg.infuseDuration : 8.0); }
    if(elInfDurVal){ elInfDurVal.textContent = String((cfg.infuseDuration!=null ? cfg.infuseDuration : 8.0).toFixed ? (cfg.infuseDuration!=null ? cfg.infuseDuration : 8.0).toFixed(1) : (cfg.infuseDuration!=null ? cfg.infuseDuration : 8.0)); }
    if(elInfDurBox) elInfDurBox.style.display = (cfg.infusePermanent ? "none" : "block");

    // Etapa 7/8 (pierce + AoE)
    if(elPierce) elPierce.checked = !!cfg.pierce;
    if(elPierceHits) elPierceHits.value = String(cfg.pierceHits || 2);
    if(elPierceVal) elPierceVal.textContent = String(_clampInt(cfg.pierceHits||2, 1, 5) || 1);
    if(elAoe) elAoe.checked = !!cfg.aoe;
    if(elAoeRad) elAoeRad.value = String(cfg.aoeRadius || 90);
    if(elAoeVal) elAoeVal.textContent = String(_clampInt(cfg.aoeRadius||90, 40, 220) || 90);

    // kinds
    const kindOpts = [
      ["shooter","Shooter (proj√©teis)"],
      ["slow","Slow shooter (proj√©teis + slow)"],
      ["homing","Homing (teleguiado)"],
      ["beam","Beam (raio cont√≠nuo ‚Ä¢ sem purificar)"],
      ["charge","Charge Shot (clique para atirar)"],
      ["infuse","Infuse (buff em cima)"],
      ["healer","Healer (cura)"],
      ["wall","Tank (parede / muito HP)"],
      ["cone","Cone (spray curto)"],
      ["bomb","Bomba (explos√£o)"],
    ];
    if(elKind){
      elKind.innerHTML = "";
      for(const [v,lab] of kindOpts){
        const o = document.createElement("option");
        o.value = v; o.textContent = lab;
        elKind.appendChild(o);
      }
      elKind.value = cfg.kind || "shooter";
    }

    // bottles (Etapa 6): presets + copiar frascos de outros perfumes
    // - Presets: op√ß√µes "livres" pensadas para o custom
    // - Especiais: frascos de perfumes especiais compr√°veis
    // - Padr√µes/outros: frascos do restante do jogo
    const bottleKeysAll = (()=>{ try{ return Object.keys(BottleStyles||{}); }catch(_e){ return []; } })();

    const presetOrder = [
      "presetDrop","presetStout","presetRound","presetSpray","presetSquare","presetTube",
      // extras "preset√°veis" (reaproveitam shapes que j√° existem no jogo)
      "prismLens","coffeeTrap","nativaClean","arboBoost","slow","beam","wall","bomb","healer","cone","sun","shooter"
    ].filter(k=>bottleKeysAll.includes(k));

    const used = new Set(presetOrder);

    const specialKeys = bottleKeysAll.filter(k=>!used.has(k) && isSpecialPlant(k)).sort((a,b)=>a.localeCompare(b));
    const otherKeys   = bottleKeysAll.filter(k=>!used.has(k) && !isSpecialPlant(k)).sort((a,b)=>a.localeCompare(b));

    function bottleLabelForKey(k){
      if(k && k.startsWith("preset")){
        const nice = k.replace(/^preset/,"").replace(/([A-Z])/g," $1").trim();
        return `Preset: ${nice || k}`;
      }
      const pd = (typeof plantById!=="undefined" && plantById && plantById.get) ? plantById.get(k) : null;
      if(pd && pd.name) return `Frasco: ${pd.name}`;
      return `Frasco: ${k}`;
    }

    elBottle.innerHTML = "";
    function addBottleGroup(label, keys){
      if(!keys || !keys.length) return;
      const og = document.createElement("optgroup");
      og.label = label;
      for(const k of keys){
        const o = document.createElement("option");
        o.value = k;
        o.textContent = bottleLabelForKey(k);
        og.appendChild(o);
      }
      elBottle.appendChild(og);
    }

    addBottleGroup("Presets", presetOrder);
    addBottleGroup("Especiais", specialKeys);
    addBottleGroup("Outros", otherKeys);

    // valida sele√ß√£o atual
    if(!BottleStyles[cfg.bottleKey]) cfg.bottleKey = presetOrder[0] || "presetDrop";
    elBottle.value = cfg.bottleKey;

    function updatePreview(){
      cfg.name = elName.value;
      cfg.icon = elIcon.value;
      cfg.label = elLabel.value;
      cfg.kind = elKind.value;
      // atualizar caps de HP ao trocar tipo
      const _hpCaps = getCustomHpCaps(cfg.kind||"shooter");
      if(elHp){ elHp.min=String(_hpCaps.min); elHp.max=String(_hpCaps.max); elHp.step=String(_hpCaps.step); }
      // shot/effect only for shooter/slow
      const seEnabled = (cfg.kind==="shooter" || cfg.kind==="slow" || cfg.kind==="homing");
      if(elShot) elShot.disabled = !seEnabled;
      if(elEffect) elEffect.disabled = !seEnabled;

      // cad√™ncia manual (s√≥ shooter/slow/homing)
      const cadEnabled = seEnabled;
      if(elCadBox) elCadBox.style.display = cadEnabled ? "block" : "none";
      if(elCadMode) elCadMode.disabled = !cadEnabled;
      if(elCad) elCad.disabled = (!cadEnabled || !(elCadMode && elCadMode.value==="manual"));

      // charge shot only when kind="charge"
      const chargeEnabled = (cfg.kind==="charge");
      if(elChargeBox) elChargeBox.style.display = chargeEnabled ? "block" : "none";
      if(elCharge) elCharge.disabled = !chargeEnabled;

      // infuse only when kind="infuse"
      const infuseEnabled = (cfg.kind==="infuse");
      if(elInfuseBox) elInfuseBox.style.display = infuseEnabled ? "block" : "none";
      if(elInfType) elInfType.disabled = !infuseEnabled;
      if(elInfStr) elInfStr.disabled = !infuseEnabled;
      if(elInfPerm) elInfPerm.disabled = !infuseEnabled;
      if(elInfDur) elInfDur.disabled = (!infuseEnabled || (elInfPerm && elInfPerm.checked));
      if(elInfDurBox) elInfDurBox.style.display = (!infuseEnabled || (elInfPerm && elInfPerm.checked)) ? "none" : "block";

      // Etapa 7/8: pierce + AoE (s√≥ shooter/slow)
      if(elPierce) elPierce.disabled = !seEnabled;
      if(elPierceHits) elPierceHits.disabled = !seEnabled;
      if(elAoe) elAoe.disabled = !seEnabled;
      if(elAoeRad) elAoeRad.disabled = !seEnabled;

      if(!seEnabled){
        cfg.shotCount = 1;
        if(elShot){ elShot.value="1"; }
        if(elShotVal) elShotVal.textContent="1";
        cfg.effect="none";
        if(elEffect) elEffect.value="none";

        cfg.pierce = false;
        cfg.pierceHits = 1;
        if(elPierce) elPierce.checked = false;
        if(elPierceHits) elPierceHits.value = "1";
        if(elPierceVal) elPierceVal.textContent = "1";

        cfg.aoe = false;
        cfg.aoeRadius = 90;
        if(elAoe) elAoe.checked = false;
        if(elAoeRad) elAoeRad.value = "90";
        if(elAoeVal) elAoeVal.textContent = "90";
      }

      if(!seEnabled){
        cfg.cadenceMode = "auto";
        if(elCadMode) elCadMode.value = "auto";
        if(elCad) elCad.value = String(cfg.cadence || 1.20);
        if(elCadVal) elCadVal.textContent = "";
        if(elCadMin) elCadMin.textContent = "";
        if(elCadReason) elCadReason.textContent = "";
      }
      cfg.bottleKey = elBottle.value;
      cfg.bottleTint = elBottleTint ? elBottleTint.value : cfg.bottleTint;
      cfg.projTint = elProjTint ? elProjTint.value : cfg.projTint;
      cfg.shotCount = elShot ? Number(elShot.value||1) : (cfg.shotCount||1);
      cfg.shotCount = _clampInt(cfg.shotCount, 1, 5);
      if(elShotVal) elShotVal.textContent = String(cfg.shotCount);
      cfg.effect = elEffect ? elEffect.value : (cfg.effect||"none");

      // pierce
      cfg.pierce = !!(seEnabled && elPierce && elPierce.checked);
      if(elPierceHits) elPierceHits.disabled = (!seEnabled || !cfg.pierce);
      cfg.pierceHits = cfg.pierce ? _clampInt(Number((elPierceHits ? elPierceHits.value : cfg.pierceHits) || 2), 1, 5) : 1;
      if(elPierceHits) elPierceHits.value = String(cfg.pierceHits);
      if(elPierceVal) elPierceVal.textContent = String(cfg.pierceHits);

      // aoe
      cfg.aoe = !!(seEnabled && elAoe && elAoe.checked);
      if(elAoeRad) elAoeRad.disabled = (!seEnabled || !cfg.aoe);
      cfg.aoeRadius = cfg.aoe ? _clampInt(Number((elAoeRad ? elAoeRad.value : cfg.aoeRadius) || 90), 40, 220) : 90;
      if(elAoeRad) elAoeRad.value = String(cfg.aoeRadius);
      if(elAoeVal) elAoeVal.textContent = String(cfg.aoeRadius);

      // cad√™ncia manual
      if(cadEnabled){
        cfg.cadenceMode = (elCadMode && elCadMode.value==="manual") ? "manual" : "auto";
        cfg.cadence = +clamp(Number((elCad ? elCad.value : cfg.cadence) || cfg.cadence || 1.20), 0.40, 3.00).toFixed(2);
        const cadInfo = getCustomCadenceMin(cfg);
        const minFR = cadInfo.min;
        if(cfg.cadenceMode==="manual"){
          cfg.cadence = +Math.max(minFR, cfg.cadence).toFixed(2);
          if(elCad) elCad.value = String(cfg.cadence);
        }
        if(elCadMin) elCadMin.textContent = String(minFR.toFixed ? minFR.toFixed(2) : minFR);
        if(elCadReason){
          elCadReason.textContent = cadInfo.reasons && cadInfo.reasons.length
            ? ("M√≠nimo aumentado por: " + cadInfo.reasons.join(", "))
            : "";
        }
      }

      // charge time
      if(chargeEnabled){
        cfg.chargeTime = elCharge ? Number(elCharge.value||cfg.chargeTime||1.8) : (cfg.chargeTime||1.8);
        cfg.chargeTime = +clamp(cfg.chargeTime, 0.8, 3.0).toFixed(1);
        if(elCharge) elCharge.value = String(cfg.chargeTime);
        if(elChargeVal) elChargeVal.textContent = String(cfg.chargeTime.toFixed(1));
      }else{
        // mant√©m o valor salvo, mas garante um default v√°lido
        cfg.chargeTime = +clamp(Number(cfg.chargeTime!=null ? cfg.chargeTime : 1.8), 0.8, 3.0).toFixed(1);
        if(elChargeVal) elChargeVal.textContent = String(cfg.chargeTime.toFixed(1));
      }

      // infuse params
      if(infuseEnabled){
        cfg.infuseType = elInfType ? elInfType.value : (cfg.infuseType||"resist");
        cfg.infuseStrength = elInfStr ? Number(elInfStr.value||cfg.infuseStrength||5) : (cfg.infuseStrength||5);
        cfg.infuseStrength = _clampInt(cfg.infuseStrength, 1, 10) || 5;
        if(elInfStr) elInfStr.value = String(cfg.infuseStrength);
        if(elInfStrVal) elInfStrVal.textContent = String(cfg.infuseStrength);

        cfg.infusePermanent = !!(elInfPerm && elInfPerm.checked);
        if(elInfPerm) elInfPerm.checked = cfg.infusePermanent;

        if(!cfg.infusePermanent){
          cfg.infuseDuration = elInfDur ? Number(elInfDur.value||cfg.infuseDuration||8.0) : (cfg.infuseDuration||8.0);
          cfg.infuseDuration = +clamp(cfg.infuseDuration, 2.0, 20.0).toFixed(1);
          if(elInfDur) elInfDur.value = String(cfg.infuseDuration);
          if(elInfDurVal) elInfDurVal.textContent = String(cfg.infuseDuration.toFixed(1));
        }else{
          cfg.infuseDuration = +clamp(Number(cfg.infuseDuration!=null ? cfg.infuseDuration : 8.0), 2.0, 20.0).toFixed(1);
          if(elInfDurVal) elInfDurVal.textContent = String(cfg.infuseDuration.toFixed(1));
        }
        if(elInfDurBox) elInfDurBox.style.display = cfg.infusePermanent ? "none" : "block";
      }else{
        // defaults v√°lidos
        cfg.infuseType = (cfg.infuseType || "resist");
        cfg.infuseStrength = _clampInt(cfg.infuseStrength, 1, 10) || 5;
        cfg.infuseDuration = +clamp(Number(cfg.infuseDuration!=null ? cfg.infuseDuration : 8.0), 2.0, 20.0).toFixed(1);
        cfg.infusePermanent = !!cfg.infusePermanent;
        if(elInfType) elInfType.value = cfg.infuseType;
        if(elInfStr) elInfStr.value = String(cfg.infuseStrength);
        if(elInfStrVal) elInfStrVal.textContent = String(cfg.infuseStrength);
        if(elInfPerm) elInfPerm.checked = cfg.infusePermanent;
        if(elInfDur) elInfDur.value = String(cfg.infuseDuration);
        if(elInfDurVal) elInfDurVal.textContent = String(cfg.infuseDuration.toFixed(1));
      }


      cfg.strength = Number(elStr.value||5);
      cfg.strength = _clampInt(cfg.strength, 1, 10);
      elStrVal.textContent = String(cfg.strength);

      cfg.hpMode = elHpMode ? elHpMode.value : (cfg.hpMode||"auto");
      const _hpCaps2 = getCustomHpCaps(cfg.kind||"shooter");
      if(cfg.hpMode!=="manual") cfg.hpMode = "auto";
      if(elHp){ elHp.disabled = (cfg.hpMode!=="manual"); }
      if(cfg.hpMode==="manual"){
        cfg.hp = elHp ? Number(elHp.value||cfg.hp||_hpCaps2.min) : (cfg.hp||_hpCaps2.min);
        cfg.hp = _clampInt(cfg.hp, _hpCaps2.min, _hpCaps2.max) || _hpCaps2.min;
        if(elHp) elHp.value = String(cfg.hp);
        if(elHpVal) elHpVal.textContent = String(cfg.hp);
      }

      const tmpDef = makeCustomPerfumeDef(cfg);
      // cad√™ncia: mostra o intervalo real e o m√≠nimo
      if(cadEnabled){
        if(elCadVal) elCadVal.textContent = (tmpDef && tmpDef.fireRate!=null && tmpDef.fireRate.toFixed) ? tmpDef.fireRate.toFixed(2) : String(tmpDef.fireRate||"");
        if(elCadMin) elCadMin.textContent = (tmpDef && tmpDef._minFireRate!=null && tmpDef._minFireRate.toFixed) ? tmpDef._minFireRate.toFixed(2) : (tmpDef && tmpDef._minFireRate!=null ? String(tmpDef._minFireRate) : "");
        if(elCad) elCad.disabled = !(elCadMode && elCadMode.value==="manual");
        if(elCadReason && tmpDef && tmpDef._minFireRate!=null && tmpDef._autoFireRate!=null && (tmpDef._minFireRate > tmpDef._autoFireRate + 0.001)){
          const rs = (tmpDef._cadenceReasons && tmpDef._cadenceReasons.length) ? tmpDef._cadenceReasons.join(", ") : "efeitos";
          elCadReason.textContent = "Cad√™ncia auto limitada pelo m√≠nimo ("+rs+")";
        }
      }
      // preview metrics (custom)
      const powerPct = (tmpDef && typeof tmpDef._pow==="number") ? (Math.round(tmpDef._pow*100) + "%") : "";
      let metricLabel = "";
      let metricVal = "";
      try{
        if(tmpDef.kind==="shooter" || tmpDef.kind==="slow" || tmpDef.kind==="homing"){
          const dps = (tmpDef.dmg * (tmpDef.shotCount||1)) / Math.max(0.01, tmpDef.fireRate||1);
          metricLabel = "DPS‚âà";
          metricVal = String(Math.round(dps));
        }else if(tmpDef.kind==="healer"){
          const hps = (tmpDef.healAmount||0) / Math.max(0.01, tmpDef.healRate||1);
          metricLabel = "HPS‚âà";
          metricVal = String(Math.round(hps));
        }else if(tmpDef.kind==="beam"){
          metricLabel = "DPS";
          metricVal = String(tmpDef.dps||0);
        }else if(tmpDef.kind==="charge"){
          metricLabel = "Dano";
          metricVal = String(tmpDef.dmg||0);
        }else if(tmpDef.kind==="infuse"){
          metricLabel = "Buff";
          const t = (tmpDef.infuse && tmpDef.infuse.type) ? tmpDef.infuse.type : "";
          metricVal = t ? t.toUpperCase() : "";
        }else if(tmpDef.kind==="cone"){
          const dps = (tmpDef.dmg * (tmpDef.hits||1)) / Math.max(0.01, tmpDef.fireRate||1);
          metricLabel = "DPS‚âà";
          metricVal = String(Math.round(dps));
        }else if(tmpDef.kind==="bomb"){
          metricLabel = "Burst";
          metricVal = String(tmpDef.dmg||0);
        }else{
          metricLabel = "";
          metricVal = "";
        }
      }catch(_e){ metricLabel=""; metricVal=""; }
      // quando em auto, exibe o HP calculado no label
      if(cfg.hpMode!=="manual"){
        if(elHpVal) elHpVal.textContent = String(tmpDef.hp);
        if(elHp){
          const _hv = _clampInt(tmpDef.hp, _hpCaps2.min, _hpCaps2.max) || _hpCaps2.min;
          elHp.value = String(_hv);
        }
      }

let extra = "";
      if(tmpDef.kind==="shooter") extra = `Dano: <b>${tmpDef.dmg}</b> ‚Ä¢ Tiro: <b>${tmpDef.fireRate.toFixed(2)}s</b> ‚Ä¢ Shots: <b>${tmpDef.shotCount||1}</b>` + ((tmpDef.effect && tmpDef.effect!=="none") ? ` ‚Ä¢ DoT: <b>${tmpDef.effect.toUpperCase()}</b>` : ``) + ((tmpDef.burn)?` (${tmpDef.burn.dps} DPS / ${tmpDef.burn.time.toFixed(1)}s)`: (tmpDef.poison?` (${tmpDef.poison.dps} DPS / ${tmpDef.poison.time.toFixed(1)}s)`:``)) + ((tmpDef.pierceHits && tmpDef.pierceHits>1) ? ` ‚Ä¢ Pierce: <b>${tmpDef.pierceHits}</b>` : ``) + (tmpDef.aoe ? ` ‚Ä¢ AoE: <b>${Math.round(tmpDef.aoe.radius)}</b>px` : ``);
      if(tmpDef.kind==="slow") extra = `Dano: <b>${tmpDef.dmg}</b> ‚Ä¢ Tiro: <b>${tmpDef.fireRate.toFixed(2)}s</b> ‚Ä¢ Shots: <b>${tmpDef.shotCount||1}</b> ‚Ä¢ Slow: <b>${Math.round((1-tmpDef.slowMult)*100)}%</b> por <b>${tmpDef.slowTime.toFixed(1)}s</b>` + ((tmpDef.effect && tmpDef.effect!=="none") ? ` ‚Ä¢ DoT: <b>${tmpDef.effect.toUpperCase()}</b>` : ``) + ((tmpDef.burn)?` (${tmpDef.burn.dps} DPS / ${tmpDef.burn.time.toFixed(1)}s)`: (tmpDef.poison?` (${tmpDef.poison.dps} DPS / ${tmpDef.poison.time.toFixed(1)}s)`:``)) + ((tmpDef.pierceHits && tmpDef.pierceHits>1) ? ` ‚Ä¢ Pierce: <b>${tmpDef.pierceHits}</b>` : ``) + (tmpDef.aoe ? ` ‚Ä¢ AoE: <b>${Math.round(tmpDef.aoe.radius)}</b>px` : ``);
      if(tmpDef.kind==="homing") extra = `Dano: <b>${tmpDef.dmg}</b> ‚Ä¢ Tiro: <b>${tmpDef.fireRate.toFixed(2)}s</b>${(tmpDef._minFireRate!=null) ? ` <span class="small" style="opacity:.85;">(min ${tmpDef._minFireRate.toFixed(2)}s)</span>` : ``} ‚Ä¢ Shots: <b>${tmpDef.shotCount||1}</b>` + ((tmpDef.effect && tmpDef.effect!=="none") ? ` ‚Ä¢ Efeito: <b>${tmpDef.effect.toUpperCase()}</b>` : ``) + ((tmpDef.pierceHits && tmpDef.pierceHits>1) ? ` ‚Ä¢ Pierce: <b>${tmpDef.pierceHits}</b>` : ``) + (tmpDef.aoe ? ` ‚Ä¢ AoE: <b>${Math.round(tmpDef.aoe.radius)}</b>px` : ``);

      if(tmpDef.kind==="charge") extra = `Dano: <b>${tmpDef.dmg}</b> ‚Ä¢ Carga: <b>${(tmpDef.chargeTime||1.8).toFixed ? (tmpDef.chargeTime||1.8).toFixed(1) : (tmpDef.chargeTime||1.8)}</b>s ‚Ä¢ <span class="small">clique na fase para atirar</span>`;

      if(tmpDef.kind==="infuse"){
        const it = (tmpDef.infuse && tmpDef.infuse.type) ? tmpDef.infuse.type : "resist";
        const is = (tmpDef.infuse && tmpDef.infuse.strength!=null) ? tmpDef.infuse.strength : (cfg.infuseStrength||5);
        const id = (tmpDef.infuse && tmpDef.infuse.duration!=null) ? tmpDef.infuse.duration : (cfg.infuseDuration||8.0);
        const ip = (tmpDef.infuse && tmpDef.infuse.permanent) ? true : false;
        extra = `Buff: <b>${String(it).toUpperCase()}</b> ‚Ä¢ Intensidade: <b>${is}</b>/10` + (ip ? ` ‚Ä¢ <b>Permanente</b>` : ` ‚Ä¢ Dura√ß√£o: <b>${(+id).toFixed ? (+id).toFixed(1) : id}</b>s`) + ` ‚Ä¢ <span class="small">usar em cima</span> ‚Ä¢ <span class="small">substitui o anterior</span>`;
      }

      if(tmpDef.kind==="cone") extra = `Dano por hit: <b>${tmpDef.dmg}</b> ‚Ä¢ Hits: <b>${tmpDef.hits}</b> ‚Ä¢ Tiro: <b>${tmpDef.fireRate.toFixed(2)}s</b>`;
      if(tmpDef.kind==="healer") extra = `Cura: <b>${tmpDef.healAmount}</b> ‚Ä¢ Tick: <b>${tmpDef.healRate.toFixed(2)}s</b>`;
      if(tmpDef.kind==="wall") extra = `HP: <b>${tmpDef.hp}</b>`;
      if(tmpDef.kind==="bomb") extra = `Dano: <b>${tmpDef.dmg}</b> ‚Ä¢ Fuse: <b>${tmpDef.fuse.toFixed(2)}s</b>`;

      elPrev.innerHTML = `
        <div class="chips" style="margin-top:6px;">
          <span class="chip">Nome: ${escapeHTML(tmpDef.name)}</span>
          <span class="chip">Emoji: ${escapeHTML(tmpDef.icon)}</span>
          <span class="chip warn">Custo: ${tmpDef.cost}</span>
          <span class="chip good">Cooldown: ${tmpDef.cooldown}s</span>
          <span class="chip">HP: ${tmpDef.hp}</span>
          ${powerPct ? `<span class="chip">Power: ${powerPct}</span>` : ``}
          ${metricLabel ? `<span class="chip">${metricLabel} ${metricVal}</span>` : ``}
          ${(tmpDef.kind==="infuse") ? `<span class="chip">Infuse: ${((tmpDef.infuse&&tmpDef.infuse.type)?String(tmpDef.infuse.type).toUpperCase():"")} ${((tmpDef.infuse&&tmpDef.infuse.permanent)?"(PERM)":"(" + ((tmpDef.infuse&&tmpDef.infuse.duration)!=null?tmpDef.infuse.duration:0) + "s)")}</span>` : ``}
          <span class="chip">Frasco: <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${tmpDef.tint};border:1px solid rgba(255,255,255,.25);margin-right:6px;vertical-align:-1px;"></span>${tmpDef.tint}</span>
          <span class="chip">Proj: <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${(tmpDef.projTint||tmpDef.tint)};border:1px solid rgba(255,255,255,.25);margin-right:6px;vertical-align:-1px;"></span>${(tmpDef.projTint||tmpDef.tint)}</span>
          ${(tmpDef.kind==="shooter"||tmpDef.kind==="slow") ? `<span class="chip">Shots: ${tmpDef.shotCount||1}</span>` : ``}
          ${(tmpDef.kind==="shooter"||tmpDef.kind==="slow") ? `<span class="chip">Efeito: ${(tmpDef.effect && tmpDef.effect!=="none") ? tmpDef.effect.toUpperCase() : "NONE"}</span>` : ``}
          ${(tmpDef.kind==="shooter"||tmpDef.kind==="slow") && (tmpDef.pierceHits && tmpDef.pierceHits>1) ? `<span class="chip">Pierce: ${tmpDef.pierceHits}</span>` : ``}
          ${(tmpDef.kind==="shooter"||tmpDef.kind==="slow") && tmpDef.aoe ? `<span class="chip">AoE: ${Math.round(tmpDef.aoe.radius)}px</span>` : ``}
          <span class="chip">Tipo: ${tmpDef.kind.toUpperCase()}</span>
        </div>
        <div style="margin-top:8px;">${extra}</div>
        <div style="margin-top:6px; opacity:.85;">Frasco: <b>${escapeHTML(cfg.bottleKey)}</b> ‚Ä¢ Texto no frasco: <b>${escapeHTML(String(cfg.label||'').toUpperCase().slice(0,6))}</b></div>
        <div class="small" style="opacity:.78; margin-top:6px;">Multi-shot, efeitos e HP manual elevam custo/cooldown para balancear.</div>
      `;
    }

    // safe html in preview
    function escapeHTML(s){
      return String(s??"").replace(/[&<>"']/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m]));
    }

    // listeners
    for(const el of [elName, elIcon, elLabel, elKind, elCharge, elBottle, elBottleTint, elProjTint, elShot, elEffect, elPierce, elPierceHits, elAoe, elAoeRad, elCadMode, elCad, elStr, elHpMode, elHp, elInfType, elInfStr, elInfPerm, elInfDur]){
      el.addEventListener("input", updatePreview);
      el.addEventListener("change", updatePreview);
    }
    updatePreview();

    form.querySelector("#cSave").addEventListener("click", ()=>{
      const finalCfg = _sanitizeCustomPerfumeCfg(cfg);
      progress.customPerfume = finalCfg;
      try{ applyCustomPerfumeDefFromProgress(); }catch(_e){}
      // garante que est√° comprado
      if(!progress.specialOwned) progress.specialOwned = new Set();
      progress.specialOwned.add("customPerfume");
      progress.lastLoadout = normalizeLoadout(progress.lastLoadout || []);
      rebuildSeedBank();
      saveProgress();
      flashOverlayToast("‚úÖ Perfume customizado salvo!", "good");

      overlayMode = "info";
      infoKind = "plants";
      infoSelectedId = "customPerfume";
      renderOverlay();
    });

    form.querySelector("#cReset").addEventListener("click", ()=>{
      const d = defaultCustomPerfumeCfg();
      _customTmpCfg = _sanitizeCustomPerfumeCfg(d);
      elName.value = _customTmpCfg.name;
      elIcon.value = _customTmpCfg.icon;
      elLabel.value = _customTmpCfg.label;
      elKind.value = _customTmpCfg.kind;
      elBottle.value = _customTmpCfg.bottleKey;
      elStr.value = String(_customTmpCfg.strength);
      elStrVal.textContent = String(_customTmpCfg.strength);
      if(elBottleTint) elBottleTint.value = _customTmpCfg.bottleTint || "#8DE1FF";
      if(elProjTint) elProjTint.value = _customTmpCfg.projTint || (_customTmpCfg.bottleTint || "#8DE1FF");
      if(elShot) elShot.value = String(_customTmpCfg.shotCount || 1);
      if(elShotVal) elShotVal.textContent = String(_customTmpCfg.shotCount || 1);
      if(elEffect) elEffect.value = _customTmpCfg.effect || "none";
      if(elPierce) elPierce.checked = !!_customTmpCfg.pierce;
      if(elPierceHits) elPierceHits.value = String(_customTmpCfg.pierceHits || 2);
      if(elPierceVal) elPierceVal.textContent = String(_clampInt(_customTmpCfg.pierceHits||2, 1, 5) || 1);
      if(elAoe) elAoe.checked = !!_customTmpCfg.aoe;
      if(elAoeRad) elAoeRad.value = String(_customTmpCfg.aoeRadius || 90);
      if(elAoeVal) elAoeVal.textContent = String(_clampInt(_customTmpCfg.aoeRadius||90, 40, 220) || 90);
      if(elCharge){ elCharge.value = String(_customTmpCfg.chargeTime!=null ? _customTmpCfg.chargeTime : 1.8); }
      if(elChargeVal){ elChargeVal.textContent = String((_customTmpCfg.chargeTime!=null ? _customTmpCfg.chargeTime : 1.8).toFixed ? (_customTmpCfg.chargeTime!=null ? _customTmpCfg.chargeTime : 1.8).toFixed(1) : (_customTmpCfg.chargeTime!=null ? _customTmpCfg.chargeTime : 1.8)); }
      if(elInfType) elInfType.value = _customTmpCfg.infuseType || "resist";
      if(elInfStr) elInfStr.value = String(_customTmpCfg.infuseStrength || 5);
      if(elInfStrVal) elInfStrVal.textContent = String(_customTmpCfg.infuseStrength || 5);
      if(elInfPerm) elInfPerm.checked = !!_customTmpCfg.infusePermanent;
      if(elInfDur){ elInfDur.value = String(_customTmpCfg.infuseDuration!=null ? _customTmpCfg.infuseDuration : 8.0); }
      if(elInfDurVal){ elInfDurVal.textContent = String((_customTmpCfg.infuseDuration!=null ? _customTmpCfg.infuseDuration : 8.0).toFixed ? (_customTmpCfg.infuseDuration!=null ? _customTmpCfg.infuseDuration : 8.0).toFixed(1) : (_customTmpCfg.infuseDuration!=null ? _customTmpCfg.infuseDuration : 8.0)); }
      if(elInfDurBox) elInfDurBox.style.display = (_customTmpCfg.infusePermanent ? "none" : "block");
      updatePreview();
      if(elHpMode) elHpMode.value = _customTmpCfg.hpMode || "auto";
      const _hpCapsR = getCustomHpCaps(_customTmpCfg.kind||"shooter");
      if(elHp){ elHp.min=String(_hpCapsR.min); elHp.max=String(_hpCapsR.max); elHp.step=String(_hpCapsR.step); elHp.value = String(_clampInt(_customTmpCfg.hp, _hpCapsR.min, _hpCapsR.max) || _hpCapsR.min); }
      if(elHpVal) elHpVal.textContent = String(_clampInt(_customTmpCfg.hp, _hpCapsR.min, _hpCapsR.max) || _hpCapsR.min);
      updatePreview();
      flashOverlayToast("‚Ü©Ô∏è Reset aplicado.", "warn");
    });

    form.querySelector("#cCancel").addEventListener("click", ()=>{
      overlayMode = "info";
      infoKind = "plants";
      infoSelectedId = "customPerfume";
      renderOverlay();
    });
  }


  // ================= Entities =================
  function resetGrid(){
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ plants[r][c]=null; cellLocks[r][c]=0; }
  }
  function resetMowers(){
    mowers.length = 0;
    for(let r=0;r<ROWS;r++){
      const c = cellCenter(r,0);
      mowers.push({ row:r, x: GRID_X-58, y: c.y, active:true, moving:false, speed:520 });
    }
  }

  function mowerHitEnemy(e, immediate){
    if(!e || !e.alive) return;
    const isBoss = (e.def.key==="boss1" || e.def.key==="boss2");

    if(isBoss){
      if(e.mowerHit) return;
      e.mowerHit = true;
      const dmg = (e.def.key==="boss2") ? 650 : 800;

      // se o boss2 ainda tem escudo, o dano vai primeiro no escudo
      if(e.def.key==="boss2" && (e.shieldHp||0) > 0){
        const before = e.shieldHp;
        e.shieldHp = Math.max(0, e.shieldHp - dmg);
        ring(e.x, e.y, "#A9B6FF", 10, 92, 0.40);
        puff(e.x, e.y, "#A9B6FF", 18);
        if(before > 0 && e.shieldHp <= 0){
          ring(e.x, e.y, "#FFFFFF", 14, 120, 0.45);
          puff(e.x, e.y, "#7CFFB2", 22);
        }
      }else{
        e.hp -= dmg;
        ring(e.x, e.y, "#FF6A6A", 10, 92, 0.40);
        puff(e.x, e.y, "#FF6A6A", 18);
        if(e.hp <= 0){
          e.hp = 0;
          if(immediate){
            SFX.play("bossDie");
            e.alive = false;
            ring(e.x, e.y, e.def.tint, 8, 70, 0.48);
            puff(e.x, e.y, e.def.tint, 44);
          }
        }
      }
      return;
    }

    // n√£o-boss: hit-kill
    e.hp = 0;
    if(immediate){
      SFX.play("enemyDie");
      tryDropCoin(e);
      e.alive = false;
      ring(e.x, e.y, e.def.tint, 8, 70, 0.48);
      puff(e.x, e.y, e.def.tint, 20);
    }
  }

  let _plantUid = 0;

  function makePlant(def, row, col){
    return {
      uid:(++_plantUid),
      def, row, col,
      hp:def.hp, maxHp:def.hp,
      // extras (Casa 214 / Botik Magnet)
      tDelay:0,
      magnetCd:0,
      magnetCoin:null,
      baseMaxHp:def.hp,
      upLv:0,
      upMul:1.18,
      tFire:0, tGen:0, tFuse:0, tHeal:0, tBeam:0,
      tPulse:0,
      chargeT:0,
      chargeReady:false,
      poisonT:0, poisonDps:0,
      buffT:0,
      // Etapa 12 (Infuse runtime)
      infuseT:0,
      infuseTMax:0,
      infusePerm:false,
      infuseType:null,
      infusePowerMul:1.0,
      infuseResistMul:1.0,
      infuseHasteMul:1.0,
      infuseRegenFrac:0.0,
      infuseCol:null,
      infuseShieldHp:0,
      infuseShieldCap:0,
      infuseShieldRegen:0.0,
            infuseApplyCd:0,
stickyT:0,
      pendingRefilT:0, pendingRefilDef:null,
      flashT:0, flashColor:"#7CFFB2",
      battery:(def.kind==="beam")?1:0,
      batteryMax:(def.kind==="beam")?1:0,
      shieldHp:0, shieldCap:0, shieldT:0,
      shieldPopKnock:0, shieldPopRange:0, shieldPopTint:"#8DE1FF",
      bob: rand(0,Math.PI*2),
      hurtPulse: 0,
      armT:0,
      armed: (def.kind!=="trap" || !(def.armTime>0))
    };

  // ===== Charge Shot (clique para disparar) =====
  function fireChargeShot(p){
    if(!p || !p.def) return;
    if(mode!=="playing" || won || lost) return;
    if(!p.chargeReady) return;

    const cc = cellCenter(p.row, p.col);
    const fromCata = ((p.cataT||0) > 0);
    const dmgMul = plantUpMul(p) * (p.buffT>0 ? 1.15 : 1.0) * (p.infusePowerMul||1.0);

    spawnProjectile(p.row, cc.x+16, cc.y-6, p.def, "normal", p.buffT>0, {fromCata, dmgMul});

    p.chargeReady = false;
    p.chargeT = 0;
    p.flashT = 0.18;
    p.flashColor = p.def.projTint || p.def.tint || "#FFD36A";

    ring(cc.x+18, cc.y-6, p.def.projTint||p.def.tint||"#FFD36A", 10, 84, 0.34);
    puff(cc.x+24, cc.y-6, p.def.projTint||p.def.tint||"#FFD36A", 18);
  }

  }

  

// ===== Charge Shot (clique para disparar) ‚Äî GLOBAL =====
// (Fix: o handler de clique no canvas precisa acessar isso fora do makePlant)
function fireChargeShot(p){
  if(!p || !p.def) return;
  if(p.def.kind!=="charge") return;
  if(mode!=="playing" || won || lost) return;
  if(!p.chargeReady) return;

  const cc = cellCenter(p.row, p.col);
  const fromCata = ((p.cataT||0) > 0);
  const dmgMul = plantUpMul(p) * (p.buffT>0 ? 1.15 : 1.0) * (p.infusePowerMul||1.0);

  // proj√©til grande (citron-like) ‚Äî usa par√¢metros do def quando existirem
  spawnProjectile(
    p.row,
    cc.x + (p.def.chargeMuzzleX!=null ? p.def.chargeMuzzleX : 16),
    cc.y + (p.def.chargeMuzzleY!=null ? p.def.chargeMuzzleY : -6),
    p.def,
    "normal",
    p.buffT>0,
    { fromCata, dmgMul }
  );

  p.chargeReady = false;
  p.chargeT = 0;

  p.flashT = 0.18;
  p.flashColor = p.def.projTint || p.def.tint || "#FFD36A";

  // feedback
  const col = p.def.projTint || p.def.tint || "#FFD36A";
  ring(cc.x+18, cc.y-6, col, 10, 84, 0.34);
  puff(cc.x+24, cc.y-6, col, 18);
  if(SFX && SFX.play) SFX.play("shoot");
}

  // ===== Upgrades (Refil) =====
  const REFIL_UP_MAX = 3;

  function plantUpMul(p){
    const mul = (p && p.upMul!=null) ? p.upMul : 1.18;
    const lv  = (p && p.upLv!=null) ? p.upLv : 0;
    return Math.pow(mul, lv);
  }

  function recalcPlantMaxHp(p){
    if(!p) return;
    const base = (p.baseMaxHp!=null) ? p.baseMaxHp : (p.def ? p.def.hp : (p.maxHp||1));
    const mul  = (p.upMul!=null) ? p.upMul : 1.18;
    const lv   = (p.upLv!=null) ? p.upLv : 0;
    const newMax = Math.max(1, Math.round(base * Math.pow(mul, lv)));
    const oldMax = p.maxHp || newMax;
    const extra = Math.max(0, newMax - oldMax);
    p.maxHp = newMax;
    p.hp = Math.min(newMax, (p.hp||0) + extra);
  }

  function applyRefilToPlant(target, refilDef){
    if(!target || !target.def) return false;
    const upMax = (refilDef && refilDef.upMax!=null) ? refilDef.upMax : REFIL_UP_MAX;
    const upMul = (refilDef && refilDef.upMul!=null) ? refilDef.upMul : 1.18;

    target.baseMaxHp = (target.baseMaxHp!=null) ? target.baseMaxHp : (target.def.hp || target.maxHp || 1);
    target.upMul = upMul;
    target.upLv = (target.upLv!=null) ? target.upLv : 0;

    if(target.upLv >= upMax) return false;

    const oldMax = target.maxHp || target.def.hp || 1;
    target.upLv += 1;

    const newMax = Math.max(1, Math.round(target.baseMaxHp * Math.pow(upMul, target.upLv)));
    const extra = Math.max(0, newMax - oldMax);

    target.maxHp = newMax;
    target.hp = Math.min(newMax, (target.hp||0) + extra); // cura proporcional ao HP extra (100% do extra)

    target.flashT = Math.max(target.flashT||0, 0.40);
    target.flashColor = "#7CFFB2";
    return true;
  }


  // ===== Infuse (Etapa 12.2/12.3) =====
  // permanente = s√≥ durante a fase (n√£o salva)
  function applyInfuseToPlant(target, infuseDef){
    if(!target || !target.def || !infuseDef || !infuseDef.infuse) return false;
    const inf = infuseDef.infuse;
    const type = inf.type || "resist";
    const str = Math.max(1, Math.min(10, inf.strength||5));
    const perm = !!inf.permanent;
    const dur = perm ? 999999 : Math.max(2, Math.min(20, inf.duration||8));

    // 12.8: anti-exploit/UX ‚Äî detectar infuse anterior (para "refresh" vs "replace")
    const hadInfuse = (target.infuseT||0) > 0;
    const prevType = target.infuseType;
    const prevShieldHp = (target.infuseShieldHp||0);
    const prevShieldCap = (target.infuseShieldCap||0);


    // regra: substitui o infuse anterior (n√£o acumula)
    target.infuseType = type;
    target.infusePerm = perm;
    target.infuseT = dur;

    target.infuseTMax = perm ? 0 : dur;

    // reset
    target.infusePowerMul = 1.0;
    target.infuseResistMul = 1.0;
    target.infuseHasteMul = 1.0;
    target.infuseRegenFrac = 0.0;
    target.infuseShieldHp = 0;
    target.infuseShieldCap = 0;
    target.infuseShieldRegen = 0.0;
    // cor da aura do infuse (cor do perfume que aplicou o buff)
    target.infuseCol = infuseDef.projTint || infuseDef.tint || "#B9FFD9";

    if(type==="power"){
      // 1..10 => 1.07..1.70 (dano/cura)
      target.infusePowerMul = clamp(1 + 0.07*str, 1.05, 1.75);
    }else if(type==="resist"){
      // 1..10 => ~0.97..0.65 (dano recebido)
      target.infuseResistMul = clamp(1 - 0.035*str, 0.60, 0.98);
    }else if(type==="haste"){
      // 1..10 => 1.06..1.60 (cad√™ncia)
      target.infuseHasteMul = clamp(1 + 0.06*str, 1.05, 1.75);
    }else if(type==="regen"){
      // 1..10 => ~0.66%..3.0% do maxHp por segundo
      target.infuseRegenFrac = clamp(0.004 + 0.0026*str, 0.006, 0.030);
    }else if(type==="shield"){
      // 1..10 => escudo baseado no maxHp, com regenera√ß√£o lenta
      const maxHp = (target.maxHp||target.def.hp||1);
      const cap = Math.max(60, Math.round(80 + maxHp*(0.08 + 0.02*str))); // ~0.10..0.28 do maxHp (+80)
      target.infuseShieldCap = cap;
      // 12.8: se j√° tinha escudo ativo e voc√™ reaplica ESCUDO, n√£o enche de volta (evita "heal" via spam)
      if(hadInfuse && prevType==="shield"){
        // mant√©m o valor atual (sem refill). Se o cap mudou, nunca aumenta acima do que j√° tinha.
        const keep = prevShieldHp;
        target.infuseShieldHp = Math.min(keep, cap);
      }else{
        target.infuseShieldHp = cap;
      }
      // regen: 1..10 => ~2.0%..5.0% do cap por segundo
      target.infuseShieldRegen = cap * clamp(0.017 + 0.003*str, 0.020, 0.050);
    }else{
      // mant√©m multiplicadores neutros
    }

    // feedback
    target.flashT = Math.max(target.flashT||0, 0.35);
    target.flashColor = infuseDef.projTint || infuseDef.tint || "#B9FFD9";

    // pequeno lock por alvo (anti-spam)
    target.infuseApplyCd = 0.65;
    return true;
  }



    // Perk: Free Coffee
  // Ao surgir o primeiro mal cheiro do mundo, planta Coffee Armadilha gr√°tis na mesma linha.
    // Perk: Free Coffee (consum√≠vel)
  // Ao surgir o primeiro mal cheiro do mundo, se houver token, gasta 1 e planta 1 Coffee Armadilha gr√°tis na mesma linha.
  function _tryPerkFreeCoffee(row){
    try{
      if(perkFreeCoffeeUsed) return;
      let tokens = perkCount("freeCoffee");
      if(tokens<=0) return;
      const def = plantById.get("coffeeTrap");
      if(!def) return;

      perkFreeCoffeeUsed = true;

      // tenta √∫ltima coluna; se ocupado/bloqueado, recua
      let col = COLS-1;
      while(col>=0 && (cellLocks[row][col] > 0 || plants[row][col])) col--;
      if(col<0) return;

      plants[row][col] = makePlant(def, row, col);

      // consome 1 token e salva
      tokens = Math.max(0, tokens-1);
      if(!progress.perks) progress.perks = {slotPlus:0, freeCoffee:0};
      progress.perks.freeCoffee = tokens;
      saveProgress();

      const cc = cellCenter(row, col);
      ring(cc.x, cc.y, def.tint, 10, 74, 0.38);
      puff(cc.x, cc.y+10, def.tint, 12);
      SFX.play("plant");
      flashOverlayToast(`‚òï Free Coffee usado! Tokens restantes: ${tokens}`, "good");
    }catch(_e){}
  }

function spawnEnemy(row, key){
    _tryPerkFreeCoffee(row);
    const def = EnemyDefs[key];
    const y = cellCenter(row, COLS-1).y;
    enemies.push({
      def, row,
      x: SPAWN_X + rand(-20, 30),
      y,
      hp:def.hp, maxHp:def.hp,
      baseSpeed:def.speed,
      slowT:0, slowMult:1,
      frostT:0, frostSeed: rand(0,Math.PI*2),
      saltSeed: rand(0,Math.PI*2),
      resinSeed: rand(0,Math.PI*2),
      purifiedT:0,
      saltT:0,
      resinT:0, resinMult:1,
      burnT:0, burnDps:0, burnSeed: rand(0,Math.PI*2),
      cleanseT:0,
      stunT:0,
      biteT:0,
      abilityT:0,
      alive:true,
      wob: rand(0,Math.PI*2),

      mowerHit:false,

      // boss2: escudo extra (barra de vida adicional)
      shieldHp:(def.key==="boss2")?1000:0,
      shieldMax:(def.key==="boss2")?1000:0
    });

    // Hardcore survival scaling: sobe HP/velocidade/dano conforme wave
    if(currentWorld && currentWorld.survival && currentWorld.hardcore){
      const wi = getWaveIndex();
      const d = survivalDifficultyForWave(wi, true);
      const e = enemies[enemies.length-1];
      const hpMult = clamp(1 + 0.65*d, 1, 1.85);
      const spdMult = clamp(1 + 0.22*d, 1, 1.32);
      const dmgMult = clamp(1 + 0.35*d, 1, 1.55);

      e.hp = Math.round(e.hp * hpMult);
      e.maxHp = Math.round(e.maxHp * hpMult);
      e.baseSpeed = e.baseSpeed * spdMult;
      e.dmgMult = dmgMult;

      if(e.shieldHp){
        e.shieldHp = Math.round(e.shieldHp * hpMult);
        e.shieldMax = Math.round(e.shieldMax * hpMult);
      }
    }
  }


function spawnEnemyAt(row, key, x){
  const def = EnemyDefs[key];
  const y = cellCenter(row, COLS-1).y;
  enemies.push({
    def, row,
    x: x,
    y,
    hp:def.hp, maxHp:def.hp,
    baseSpeed:def.speed,
    slowT:0, slowMult:1,
    frostT:0, frostSeed: rand(0,Math.PI*2),
    saltSeed: rand(0,Math.PI*2),
    resinSeed: rand(0,Math.PI*2),
    purifiedT:0,
    saltT:0,
    resinT:0, resinMult:1,
    burnT:0, burnDps:0, burnSeed: rand(0,Math.PI*2),
    cleanseT:0,
    stunT:0,
    biteT:0,
    abilityT:0,
    alive:true,
    wob: rand(0,Math.PI*2),

    mowerHit:false,

    // boss2: escudo extra (barra de vida adicional)
    shieldHp:(def.key==="boss2")?1000:0,
    shieldMax:(def.key==="boss2")?1000:0
  });

    // Hardcore survival scaling: sobe HP/velocidade/dano conforme wave
    if(currentWorld && currentWorld.survival && currentWorld.hardcore){
      const wi = getWaveIndex();
      const d = survivalDifficultyForWave(wi, true);
      const e = enemies[enemies.length-1];
      const hpMult = clamp(1 + 0.65*d, 1, 1.85);
      const spdMult = clamp(1 + 0.22*d, 1, 1.32);
      const dmgMult = clamp(1 + 0.35*d, 1, 1.55);

      e.hp = Math.round(e.hp * hpMult);
      e.maxHp = Math.round(e.maxHp * hpMult);
      e.baseSpeed = e.baseSpeed * spdMult;
      e.dmgMult = dmgMult;

      if(e.shieldHp){
        e.shieldHp = Math.round(e.shieldHp * hpMult);
        e.shieldMax = Math.round(e.shieldMax * hpMult);
      }
    }
}

  function spawnProjectile(row, x, y, def, kind, fromBuff=false, opts=null){
    const fromCata = !!(opts && opts.fromCata);
    const dmgMul = (opts && opts.dmgMul!=null) ? opts.dmgMul : 1.0;
    const salt = def.salt ? { time: (def.salt.time || 4.0) * (fromCata ? 1.4 : 1.0) } : null;
    const resin = def.resin ? { time: (def.resin.time || 5.0) * (fromCata ? 1.4 : 1.0), mult: (def.resin.mult || 0.86) } : null;
    const burn = def.burn ? { time: (def.burn.time || 4.0) * (fromCata ? 1.15 : 1.0), dps: (def.burn.dps || 8) * (fromCata ? 1.10 : 1.0) } : null;
    const poison = def.poison ? { time: (def.poison.time || 4.0) * (fromCata ? 1.15 : 1.0), dps: (def.poison.dps || 7) * (fromCata ? 1.08 : 1.0) } : null;
    const stun  = def.stun  ? { time: (def.stun.time || 0.60) * (fromCata ? 1.05 : 1.0) } : null;

    // SFX
    if(kind==="slow") SFX.play("shootSlow");
    else if(salt) SFX.play("shoot");
    else if(resin) SFX.play("shoot");
    else SFX.play("shoot");


const splash = def.splash ? {
  radius: (def.splash.radius || 80) * (fromCata ? 1.15 : 1.0),
  mult: (def.splash.mult || 0.45) * (fromCata ? 1.05 : 1.0)
} : null;

const pierceHits = Math.max(1, _clampInt(def.pierceHits||1, 1, 5) || 1);
const aoe = def.aoe ? {
  radius: (def.aoe.radius || def.aoeRadius || 90) * (fromCata ? 1.10 : 1.0),
  mult: (def.aoe.mult || def.aoeMult || 0.45) * (fromCata ? 1.05 : 1.0)
} : null;

const tint = def.projTint || ((kind==="slow") ? "#A9B6FF" : (salt ? "#B7F2FF" : (resin ? "#FFB36A" : (poison ? "#6BFF7A" : (burn ? "#FF6A3D" : "#8DE1FF")))));

    projectiles.push({
      row, x, y,
      vx: def.projSpeed || 320,
      vy: 0,
      speed: def.projSpeed || 320,
      homing: !!def.homing,
      turnRate: (def.homing && def.homing.turnRate!=null) ? def.homing.turnRate : 0,
      seekEvery: (def.homing && def.homing.seekEvery!=null) ? def.homing.seekEvery : 0.08,
      seekT: 0,
      target: null,
      originRow: row,
      dmg: (def.dmg || 20) * dmgMul,
      slow: (kind==="slow") ? { mult:(def.frost ? (def.frost.mult||def.slowMult) : def.slowMult), time:(def.frost ? (def.frost.time||def.slowTime) : def.slowTime) } : (def.frost ? { mult:(def.frost.mult||0.60), time:(def.frost.time||2.4) } : null),
      salt,
      resin,
      burn,
      poison,
      stun,
      splash,
      aoe,
      pierce: pierceHits,
      hitList: (pierceHits>1 ? [] : null),
      life: (def.projLife!=null ? def.projLife : 3.5),
      r: (def.projR!=null ? def.projR : (kind==="slow" ? 7 : 6)),
      tint,
      fromBuff,
      fromCata,
      seed: rand(0,Math.PI*2)
    });
  }

  function boomRow(row, x, dmg){
    ring(x, cellCenter(row,0).y, "#FFD36A", 10, 130, 0.55);
    puff(x, cellCenter(row,0).y, "#FFD36A", 34);
    for(const e of enemies){
      if(!e.alive || e.row!==row) continue;
      if(Math.abs(e.x - x) < 240){
        damageEnemy(e, dmg, {type:"bomb"});
        puff(e.x, e.y, "#FFD36A", 14);
        ring(e.x, e.y, "#FFD36A", 6, 46, 0.34);
      }
    }
  }

  function boomCircle(x, y, dmg, radius, tint){
    const R = radius || 240;
    const R2 = R*R;
    const t = tint || "#FFD36A";
    ring(x, y, t, 14, R*0.95, 0.70);
    puff(x, y, t, 60);
    for(const e of enemies){
      if(!e.alive) continue;
      const dx = e.x - x;
      const dy = e.y - y;
      if(dx*dx + dy*dy <= R2){
        damageEnemy(e, dmg, {type:"bomb"});
        puff(e.x, e.y, t, 16);
        ring(e.x, e.y, t, 6, 54, 0.36);
      }
    }
  }

  function hasBossShield(e){
    return (e.shieldHp||0) > 0;
  }

  function damageEnemy(e, amount, src){
    // src: {type:"proj"/"cone"/"beam"/"trap"/"clean"/"bomb", fromBuff?:boolean, hasPrism?:boolean, purifierBoost?:boolean}
    if(!e.alive) return;

    // Purifica√ß√£o geral (p√≥s-hist√≥ria)
    if(e.def.requiresPurify && e.purifiedT<=0){
      // beam do Purificador sempre entra (e purifica); beam custom "noPurify" deve se comportar como dano normal
      const isPurifierBeam = (src.type === "beam" && !src.noPurify);
      if(!isPurifierBeam && src.type !== "clean"){
        // reduz drasticamente
        amount *= 0.25;
      }
      // evasive = chance de falhar
      if(e.def.evasive && !isPurifierBeam && src.type !== "clean"){
        if(Math.random() < 0.45) return;
      }
      // armored extra reduction
      if(e.def.dmgReduction && !isPurifierBeam && src.type !== "clean"){
        amount *= (1 - e.def.dmgReduction);
      }
    }
// Campanha 2: lacres/isolamentos ‚Äî alguns inimigos s√≥ ficam vulner√°veis quando marcados
// Obs.: a imunidade do Purificador √© tratada no feixe (canBeamHit). Aqui √© s√≥ a "casca" defensiva geral.
if(e.def.purifierImmune){
  const t = e.def.purifierImmuneType || "salt";
  const broken = (t==="salt") ? ((e.saltT||0) > 0) : (t==="resin") ? ((e.resinT||0) > 0) : false;
  if(!broken){
    // enquanto o lacre estiver inteiro, o dano geral entra com resist√™ncia
    // (limpezas/espumas ainda funcionam um pouco melhor por serem 'qu√≠micas')
    if(src.type === "clean") amount *= 0.80;
    else amount *= 0.55;
  }
}

    // Boss2: escudo extra (barra de vida adicional)
    // Quebra MUITO mais r√°pido com: Purificador (beam) + buff do Arbo (purifierBuff) + Prisma na linha (hasPrism).
    // Sem o combo, ainda d√° pra quebrar ‚Äî s√≥ que bem mais devagar.
    if(e.def.key==="boss2" && hasBossShield(e))
    {
      let mult = 0.12;
      if(src.type==="beam") mult = 0.45;
      if(src.type==="trap") mult = 0.20;
      if(src.type==="clean") mult = 0.18;
      if(src.type==="bomb") mult = 0.14;
      if(src.type==="proj" || src.type==="cone") mult = (src.fromBuff ? 0.16 : 0.10);

      if(src.type==="beam" && src.hasPrism && src.purifierBuff)
        mult = 5.2;

      const dealt = amount * mult;
      const before = e.shieldHp;
      e.shieldHp = Math.max(0, e.shieldHp - dealt);

      // feedback visual
      if(mult > 1.0){
        ring(e.x, e.y, "#7CFFB2", 10, 84, 0.35);
        puff(e.x, e.y, "#7CFFB2", 10);
      }else{
        ring(e.x, e.y, "#A9B6FF", 8, 66, 0.22);
      }

      if(before > 0 && e.shieldHp <= 0){
        ring(e.x, e.y, "#FFFFFF", 14, 120, 0.45);
        puff(e.x, e.y, "#A9B6FF", 28);
      }
      return;
    }

    // dano normal
    e.hp -= amount;
  }

  // ================= Drawing: cen√°rios =================

  // ================= Drawing: cen√°rios =================
  // Backdrops mais l√∫dicos/imersivos (cache est√°tico + camada animada)
  const backdropCache = new Map();

  function rrCtx(g,x,y,w,h,r){
    g.beginPath();
    g.moveTo(x+r,y);
    g.arcTo(x+w,y,x+w,y+h,r);
    g.arcTo(x+w,y+h,x,y+h,r);
    g.arcTo(x,y+h,x,y,r);
    g.arcTo(x,y,x+w,y,r);
    g.closePath();
  }

  function softNoise(g, x, y, w, h, n, tint, aMin=0.03, aMax=0.10, rMin=1.2, rMax=3.6){
    g.save();
    for(let i=0;i<n;i++){
      const px = x + Math.random()*w;
      const py = y + Math.random()*h;
      const rr = rMin + Math.random()*(rMax-rMin);
      const aa = aMin + Math.random()*(aMax-aMin);
      g.fillStyle = rgba(tint, aa);
      g.beginPath();
      g.arc(px, py, rr, 0, Math.PI*2);
      g.fill();
    }
    g.restore();
  }

  function buildBackdrop(worldId){
    const c = document.createElement('canvas');
    c.width = BASE_W; c.height = BASE_H;
    const g = c.getContext('2d');

    const theme = {
      1:{top:'#B7FFD9', mid:'#2E67A8', bot:'#070A16', floor1:'#0E1430', floor2:'#0B1028', a1:'#7CFFB2', a2:'#FFD36A'},
      2:{top:'#FFD0F0', mid:'#3A2A6F', bot:'#070A16', floor1:'#130B2B', floor2:'#0B0820', a1:'#FF79C6', a2:'#FFD36A'},
      3:{top:'#FFE3A6', mid:'#2E3A7A', bot:'#070A16', floor1:'#141B3D', floor2:'#0C1028', a1:'#FFEFA8', a2:'#8DE1FF'},
      4:{top:'#2AF1FF', mid:'#102C7A', bot:'#030513', floor1:'#05071A', floor2:'#020313', a1:'#2AF1FF', a2:'#FF79C6'},
      5:{top:'#FF4B6E', mid:'#3C0F2A', bot:'#04010A', floor1:'#12040D', floor2:'#07020A', a1:'#FF6A6A', a2:'#FFD36A'},
      6:{top:'#A9B6FF', mid:'#2D2B77', bot:'#070A16', floor1:'#10143A', floor2:'#080A20', a1:'#A9B6FF', a2:'#9FFFD8'},
      7:{top:'#FFE6C8', mid:'#4A2A2A', bot:'#070A16', floor1:'#161019', floor2:'#0B0710', a1:'#D7A0FF', a2:'#FFD36A'},
      8:{top:'#C9FFEA', mid:'#1D4D8F', bot:'#070A16', floor1:'#0E1636', floor2:'#070A16', a1:'#7CFFB2', a2:'#9FFFD8'},
      9:{top:'#8DE1FF', mid:'#143B7A', bot:'#030513', floor1:'#071028', floor2:'#030513', a1:'#8DE1FF', a2:'#A9B6FF'},
      10:{top:'#FF4B6E', mid:'#2A0030', bot:'#04010A', floor1:'#0E0413', floor2:'#04010A', a1:'#FF6A6A', a2:'#FFD36A'},
      11:{top:'#B7F2FF', mid:'#1D4D8F', bot:'#070A16', floor1:'#0E1430', floor2:'#0B1028', a1:'#8DE1FF', a2:'#A9B6FF'},
      12:{top:'#FFD36A', mid:'#4A2A2A', bot:'#0B1020', floor1:'#17122B', floor2:'#0B1020', a1:'#FF6A6A', a2:'#B7F2FF'},
      13:{top:'#FFB36A', mid:'#3C0F2A', bot:'#050316', floor1:'#0E0413', floor2:'#050316', a1:'#FFD36A', a2:'#7CFFB2'},
      14:{top:'#FFF0B0', mid:'#2A0030', bot:'#04010A', floor1:'#101022', floor2:'#04010A', a1:'#FFD36A', a2:'#FF6A6A'},
      15:{top:'#FF4B6E', mid:'#0E0413', bot:'#04010A', floor1:'#0B1028', floor2:'#04010A', a1:'#A9B6FF', a2:'#FFD36A'},
      101:{top:'#8DE1FF', mid:'#1D2A4A', bot:'#050316', floor1:'#0E1430', floor2:'#050316', a1:'#FFD36A', a2:'#FF6A6A'},
      102:{top:'#FF4B6E', mid:'#1A001E', bot:'#02000A', floor1:'#12040D', floor2:'#02000A', a1:'#FF6A6A', a2:'#A9B6FF'}
    }[worldId] || {top:'#B7FFD9', mid:'#2E67A8', bot:'#070A16', floor1:'#0E1430', floor2:'#0B1028', a1:'#7CFFB2', a2:'#FFD36A'};

    // c√©u/parede
    const sky = g.createLinearGradient(0,0,0,BASE_H);
    sky.addColorStop(0, rgba(theme.top, 0.62));
    sky.addColorStop(0.42, rgba(theme.mid, 0.34));
    sky.addColorStop(1, rgba(theme.bot, 1.0));
    g.fillStyle = sky;
    g.fillRect(0,0,BASE_W,BASE_H);

    // vinheta suave
    const vg = g.createRadialGradient(BASE_W*0.55, BASE_H*0.40, 80, BASE_W*0.55, BASE_H*0.55, 680);
    vg.addColorStop(0, 'rgba(255,255,255,.07)');
    vg.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = vg;
    g.fillRect(0,0,BASE_W,BASE_H);

    // piso (abaixo do grid)
    const floorY = GRID_Y + GRID_H - 20;
    const floor = g.createLinearGradient(0,floorY,0,BASE_H);
    floor.addColorStop(0, rgba(theme.floor1, 0.10));
    floor.addColorStop(0.18, rgba(theme.floor1, 0.55));
    floor.addColorStop(1, rgba(theme.floor2, 0.92));
    g.fillStyle = floor;
    g.fillRect(0,floorY,BASE_W,BASE_H-floorY);

    // ladrilhos sutis no piso
    g.save();
    g.globalAlpha = 0.45;
    g.strokeStyle = 'rgba(255,255,255,.06)';
    for(let y=floorY+10;y<BASE_H;y+=28){
      g.beginPath();
      g.moveTo(0,y);
      g.lineTo(BASE_W,y);
      g.stroke();
    }
    for(let x=0;x<BASE_W;x+=42){
      g.beginPath();
      g.moveTo(x,floorY);
      g.lineTo(x,BASE_H);
      g.stroke();
    }
    g.restore();

    // moldura do ‚Äúpalco‚Äù (deixa o grid parecer parte do cen√°rio)
    g.save();
    g.fillStyle = 'rgba(0,0,0,.18)';
    rrCtx(g, 18, 110, BASE_W-36, 546, 26); g.fill();
    g.strokeStyle = 'rgba(255,255,255,.10)';
    g.stroke();
    g.restore();

    // textura geral
    softNoise(g, 18, 110, BASE_W-36, 546, 220, theme.a1, 0.015, 0.06, 1.2, 3.2);

    // props por mundo (est√°ticos)
    if(worldId===1){
      // vitrine-jardim: vidra√ßa + plantas pendentes + prateleira
      g.save();
      // vidra√ßas
      g.fillStyle = 'rgba(255,255,255,.06)';
      for(let i=0;i<3;i++){
        rrCtx(g, 56 + i*152, 44, 136, 156, 22); g.fill();
        g.strokeStyle = 'rgba(255,255,255,.10)';
        g.stroke();
        // reflexo diagonal
        const grad = g.createLinearGradient(56+i*152, 44, 56+i*152+136, 44+156);
        grad.addColorStop(0, 'rgba(255,255,255,0)');
        grad.addColorStop(0.45, 'rgba(255,255,255,.10)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        g.fillStyle = grad;
        rrCtx(g, 56+i*152+10, 54, 116, 136, 18); g.fill();
      }
      // plantas pendentes
      g.fillStyle = rgba('#7CFFB2', 0.18);
      for(let i=0;i<12;i++){
        const x = 70 + i*70;
        const y = 40 + (i%3)*10;
        g.beginPath();
        g.moveTo(x, y);
        g.quadraticCurveTo(x-10, y+24, x-4, y+44);
        g.quadraticCurveTo(x+8, y+34, x+6, y+56);
        g.quadraticCurveTo(x-2, y+54, x-10, y+70);
        g.quadraticCurveTo(x+10, y+64, x+16, y+84);
        g.strokeStyle = rgba('#7CFFB2', 0.16);
        g.lineWidth = 2;
        g.stroke();
        g.lineWidth = 1;
        g.beginPath();
        g.ellipse(x+18, y+86, 10, 6, 0.3, 0, Math.PI*2);
        g.fill();
      }
      // prateleira de perfumes
      g.fillStyle = 'rgba(0,0,0,.22)';
      rrCtx(g, 60, 212, 420, 34, 14); g.fill();
      g.fillStyle = rgba('#FFD36A', 0.16);
      for(let i=0;i<9;i++){
        const bx = 88 + i*44;
        rrCtx(g, bx, 190, 22, 42, 10); g.fill();
        g.fillStyle = 'rgba(255,255,255,.10)';
        rrCtx(g, bx+4, 196, 14, 10, 6); g.fill();
        g.fillStyle = rgba('#FFD36A', 0.16);
      }
      g.restore();
    }

    if(worldId===2){
      // corredor do provador: cortinas + espelhos + luzes
      g.save();
      // cortinas laterais
      const curt = g.createLinearGradient(0,0,0,260);
      curt.addColorStop(0, rgba('#FF79C6', 0.20));
      curt.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = curt;
      rrCtx(g, 26, 34, 78, 240, 26); g.fill();
      rrCtx(g, BASE_W-104, 34, 78, 240, 26); g.fill();

      // espelhos
      for(let i=0;i<4;i++){
        const x = 142 + i*170;
        rrCtx(g, x, 56, 120, 168, 22);
        g.fillStyle = 'rgba(255,255,255,.05)'; g.fill();
        g.strokeStyle = 'rgba(255,255,255,.12)'; g.stroke();
        // brilho
        const gl = g.createLinearGradient(x, 56, x+120, 56);
        gl.addColorStop(0, 'rgba(255,255,255,0)');
        gl.addColorStop(0.6, 'rgba(255,255,255,.12)');
        gl.addColorStop(1, 'rgba(255,255,255,0)');
        g.fillStyle = gl;
        rrCtx(g, x+10, 70, 30, 144, 16); g.fill();
      }

      // luzes quentinhas
      for(let i=0;i<10;i++){
        const x = 120 + i*78;
        g.fillStyle = 'rgba(255,211,106,.13)';
        g.beginPath();
        g.arc(x, 34, 14, 0, Math.PI*2);
        g.fill();
      }
      g.restore();
    }

    if(worldId===3){
      // dep√≥sito: caixas, pallets e etiquetas
      g.save();
      for(let i=0;i<9;i++){
        const x = 44 + (i%3)*150;
        const y = 52 + Math.floor(i/3)*74;
        g.fillStyle = 'rgba(0,0,0,.22)';
        rrCtx(g, x, y, 130, 60, 14); g.fill();
        g.fillStyle = rgba('#FFEFA8', 0.10);
        rrCtx(g, x+10, y+12, 70, 12, 8); g.fill();
        g.fillStyle = 'rgba(255,255,255,.06)';
        rrCtx(g, x+88, y+10, 32, 18, 8); g.fill();
      }
      // faixa de ‚Äúpallet‚Äù
      g.strokeStyle = 'rgba(255,255,255,.07)';
      for(let i=0;i<MAX_LOADOUT;i++){
        g.beginPath();
        g.moveTo(50, 278+i*10);
        g.lineTo(430, 278+i*10);
        g.stroke();
      }
      g.restore();
    }

    if(worldId===4){
      // loja fechada: porta met√°lica + neon + postes
      g.save();
      // persiana
      g.fillStyle = 'rgba(0,0,0,.26)';
      rrCtx(g, 34, 42, BASE_W-68, 210, 26); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.08)';
      for(let y=56;y<236;y+=14){
        g.beginPath();
        g.moveTo(50,y);
        g.lineTo(BASE_W-50,y);
        g.stroke();
      }
      // neon
      const neon = g.createLinearGradient(0,0,BASE_W,0);
      neon.addColorStop(0,'rgba(42,241,255,0)');
      neon.addColorStop(0.5,'rgba(42,241,255,.22)');
      neon.addColorStop(1,'rgba(42,241,255,0)');
      g.fillStyle = neon;
      rrCtx(g, 80, 60, BASE_W-160, 16, 10); g.fill();

      // postes
      g.fillStyle = 'rgba(255,255,255,.06)';
      rrCtx(g, 72, 60, 16, 290, 10); g.fill();
      rrCtx(g, BASE_W-88, 60, 16, 290, 10); g.fill();
      g.restore();
    }

    if(worldId===5){
      // c√¢mara do miasma: colunas + runas + ‚Äúcoroa‚Äù no c√©u
      g.save();
      // colunas
      g.fillStyle = 'rgba(0,0,0,.24)';
      for(let i=0;i<5;i++){
        rrCtx(g, 46+i*182, 112, 64, 210, 18); g.fill();
        g.fillStyle = 'rgba(255,255,255,.05)';
        rrCtx(g, 54+i*182, 124, 48, 26, 14); g.fill();
        g.fillStyle = 'rgba(0,0,0,.24)';
      }
      // runas no piso (sob o palco)
      g.strokeStyle = 'rgba(255,211,106,.10)';
      g.lineWidth = 2;
      g.beginPath();
      g.arc(BASE_W*0.54, GRID_Y+GRID_H+6, 120, 0, Math.PI*2);
      g.stroke();
      g.lineWidth = 1;
      // coroa
      const crown = g.createRadialGradient(BASE_W-120, 86, 10, BASE_W-120, 86, 110);
      crown.addColorStop(0,'rgba(255,211,106,.26)');
      crown.addColorStop(1,'rgba(255,211,106,0)');
      g.fillStyle = crown;
      g.fillRect(0,0,BASE_W,220);
      g.fillStyle = 'rgba(255,211,106,.72)';
      g.font = '1000 26px system-ui,Segoe UI,Roboto,Arial';
      g.fillText('üëë', BASE_W-135, 96);
      g.restore();
    }

    if(worldId===6){
      // galeria de espelhos: pain√©is inclinados e ‚Äúcacos‚Äù prism√°ticos
      g.save();
      for(let i=0;i<MAX_LOADOUT;i++){
        const x = 44 + i*150;
        const y = 54 + (i%2)*26;
        rrCtx(g, x, y, 120, 178, 20);
        g.fillStyle = 'rgba(255,255,255,.045)'; g.fill();
        g.strokeStyle = 'rgba(255,255,255,.12)'; g.stroke();
        // brilho vertical
        const gl = g.createLinearGradient(x, y, x+120, y);
        gl.addColorStop(0,'rgba(255,255,255,0)');
        gl.addColorStop(0.6,'rgba(169,182,255,.16)');
        gl.addColorStop(1,'rgba(255,255,255,0)');
        g.fillStyle = gl;
        rrCtx(g, x+14, y+16, 22, 144, 14); g.fill();
      }
      // cacos
      g.fillStyle = 'rgba(169,182,255,.10)';
      for(let i=0;i<16;i++){
        const x = 80 + (i*54 % (BASE_W-160));
        const y = 240 + (i*37 % 120);
        g.beginPath();
        g.moveTo(x,y);
        g.lineTo(x+18,y+8);
        g.lineTo(x+6,y+22);
        g.closePath();
        g.fill();
      }
      g.restore();
    }

    if(worldId===7){
      // cafeteria do estoque: quadro, balc√£o, copos
      g.save();
      g.fillStyle = 'rgba(0,0,0,.22)';
      rrCtx(g, 60, 56, 320, 160, 22); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.10)'; g.stroke();
      g.fillStyle = 'rgba(255,255,255,.06)';
      g.font = '1000 16px system-ui,Segoe UI,Roboto,Arial';
      g.fillText('MENU ‚Ä¢ CAF√â', 90, 92);
      g.fillText('‚òï  energia  ‚Ä¢  foco', 90, 118);

      // balc√£o
      g.fillStyle = 'rgba(0,0,0,.26)';
      rrCtx(g, 40, 232, 460, 46, 18); g.fill();
      g.fillStyle = rgba('#FFD36A', 0.12);
      for(let i=0;i<7;i++){
        rrCtx(g, 70+i*60, 206, 28, 36, 12); g.fill();
      }
      g.restore();
    }

    if(worldId===8){
      // jardim sensorial: canteiros, flores e luzes
      g.save();
      g.fillStyle = rgba('#7CFFB2', 0.10);
      for(let i=0;i<10;i++){
        rrCtx(g, 50+i*86, 60+(i%2)*22, 70, 30, 14); g.fill();
      }
      // flores e pontinhos
      for(let i=0;i<34;i++){
        const x = 60 + (i*28 % (BASE_W-120));
        const y = 118 + (i*41 % 190);
        g.fillStyle = rgba('#9FFFD8', 0.12);
        g.beginPath(); g.arc(x,y, 7, 0, Math.PI*2); g.fill();
        g.fillStyle = rgba('#FFD36A', 0.09);
        g.beginPath(); g.arc(x+8,y-6, 3, 0, Math.PI*2); g.fill();
      }
      g.restore();
    }

    if(worldId===9){
      // neutraliza√ß√£o: dutos, filtros, faixas de seguran√ßa
      g.save();
      // dutos
      g.strokeStyle = 'rgba(142,225,255,.10)';
      g.lineWidth = 2;
      for(let i=0;i<10;i++){
        const y = 60 + i*20;
        g.beginPath();
        g.moveTo(46, y);
        g.bezierCurveTo(260, y-10, 520, y+10, BASE_W-46, y);
        g.stroke();
      }
      g.lineWidth = 1;
      // filtros laterais
      g.fillStyle = 'rgba(0,0,0,.20)';
      rrCtx(g, 34, 90, 86, 160, 22); g.fill();
      rrCtx(g, BASE_W-120, 90, 86, 160, 22); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.10)'; g.stroke();
      // hazard tape
      g.strokeStyle = 'rgba(255,211,106,.12)';
      for(let i=0;i<14;i++){
        g.beginPath();
        g.moveTo(130+i*56, 260);
        g.lineTo(160+i*56, 240);
        g.stroke();
      }
      g.restore();
    }

    if(worldId===10){
      // eclipse final: disco, runas e fragmentos
      g.save();
      const disc = g.createRadialGradient(BASE_W*0.78, BASE_H*0.42, 40, BASE_W*0.78, BASE_H*0.42, 180);
      disc.addColorStop(0,'rgba(255,211,106,.18)');
      disc.addColorStop(0.5,'rgba(255,75,110,.18)');
      disc.addColorStop(1,'rgba(255,75,110,0)');
      g.fillStyle = disc;
      g.fillRect(0,0,BASE_W,BASE_H);

      g.fillStyle = 'rgba(0,0,0,.24)';
      g.beginPath();
      g.arc(BASE_W*0.80, BASE_H*0.40, 66, 0, Math.PI*2);
      g.fill();
      g.strokeStyle = 'rgba(255,255,255,.08)';
      g.stroke();

      // runas
      g.strokeStyle = 'rgba(255,211,106,.10)';
      for(let i=0;i<9;i++){
        const r = 44 + i*10;
        g.beginPath();
        g.arc(BASE_W*0.80, BASE_H*0.40, r, 0.2, Math.PI*1.6);
        g.stroke();
      }
      // fragmentos
      g.fillStyle = 'rgba(255,211,106,.10)';
      for(let i=0;i<12;i++){
        const x = 620 + (i*26 % 280);
        const y = 120 + (i*29 % 160);
        g.beginPath();
        g.moveTo(x,y);
        g.lineTo(x+14,y+6);
        g.lineTo(x+4,y+20);
        g.closePath();
        g.fill();
      }
      g.restore();
    }

    // === CAMPANHA 2 ‚Äî CONTRA-LACRE (11‚Äì15): props mais ricos ===
    if(worldId===11){
      // corredor salino: pain√©is frios, sacos de sal e cristais no piso
      g.save();

      // pain√©is de parede
      g.fillStyle = 'rgba(255,255,255,.04)';
      for(let i=0;i<7;i++){
        const x = 44 + i*124;
        rrCtx(g, x, 50, 104, 160, 18); g.fill();
        g.strokeStyle = 'rgba(255,255,255,.10)'; g.stroke();

        // faixa luminosa vertical
        const gl = g.createLinearGradient(x, 50, x, 210);
        gl.addColorStop(0, rgba(theme.a1, 0.0));
        gl.addColorStop(0.45, rgba(theme.a1, 0.16));
        gl.addColorStop(1, rgba(theme.a1, 0.0));
        g.fillStyle = gl;
        rrCtx(g, x+10, 62, 10, 136, 8); g.fill();

        g.fillStyle = 'rgba(255,255,255,.04)';
      }

      // duto no teto
      g.strokeStyle = rgba(theme.a1, 0.10);
      g.lineWidth = 2;
      g.beginPath();
      g.moveTo(50, 42);
      g.bezierCurveTo(260, 18, 520, 66, BASE_W-50, 34);
      g.stroke();
      g.lineWidth = 1;

      // placa
      g.fillStyle = 'rgba(0,0,0,.24)';
      rrCtx(g, 56, 56, 276, 44, 14); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.12)'; g.stroke();
      g.fillStyle = 'rgba(255,255,255,.08)';
      g.font = '1000 16px system-ui,Segoe UI,Roboto,Arial';
      g.fillText('CORREDOR SALINO', 76, 86);

      // prateleira com sacos
      g.fillStyle = 'rgba(0,0,0,.22)';
      rrCtx(g, 520, 214, 420, 38, 16); g.fill();
      g.fillStyle = 'rgba(255,255,255,.06)';
      for(let i=0;i<8;i++){
        const bx = 540 + i*48;
        rrCtx(g, bx, 180, 30, 44, 10); g.fill();
        g.fillStyle = 'rgba(255,255,255,.10)';
        rrCtx(g, bx+6, 188, 18, 10, 6); g.fill();
        g.fillStyle = 'rgba(255,255,255,.06)';
      }

      // cristais e p√≥ no ch√£o
      g.fillStyle = rgba(theme.a1, 0.14);
      for(let i=0;i<22;i++){
        const x = 70 + (i*64 % (BASE_W-140));
        const y = floorY + 38 + (i*37 % 122);
        g.beginPath();
        g.moveTo(x, y);
        g.lineTo(x+12, y-18);
        g.lineTo(x+22, y-6);
        g.lineTo(x+12, y+12);
        g.closePath();
        g.fill();
      }
      g.fillStyle = 'rgba(255,255,255,.04)';
      for(let i=0;i<26;i++){
        const x = 64 + (i*52 % (BASE_W-128));
        const y = floorY + 24 + (i*29 % 170);
        g.beginPath();
        g.arc(x, y, 2.2, 0, Math.PI*2);
        g.fill();
      }

      // faixa de seguran√ßa
      g.strokeStyle = 'rgba(255,211,106,.10)';
      for(let i=0;i<12;i++){
        g.beginPath();
        g.moveTo(60+i*78, floorY+18);
        g.lineTo(92+i*78, floorY-2);
        g.stroke();
      }

      g.restore();
    }

    if(worldId===12){
      // oficina do catalisador: bancada, ferramentas, frascos e ilumina√ß√£o quente
      g.save();

      // painel perfurado (parede)
      g.fillStyle = 'rgba(0,0,0,.18)';
      rrCtx(g, 54, 52, BASE_W-108, 164, 22); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.10)'; g.stroke();

      // "furos" do painel
      g.fillStyle = 'rgba(255,255,255,.03)';
      for(let y=72;y<196;y+=18){
        for(let x=74;x<BASE_W-74;x+=18){
          g.beginPath();
          g.arc(x, y, 1.2, 0, Math.PI*2);
          g.fill();
        }
      }

      // lumin√°ria pendente
      const lamp = g.createRadialGradient(320, 58, 8, 320, 58, 140);
      lamp.addColorStop(0, 'rgba(255,211,106,.22)');
      lamp.addColorStop(1, 'rgba(255,211,106,0)');
      g.fillStyle = lamp;
      g.fillRect(0,0,BASE_W,240);

      g.strokeStyle = 'rgba(255,255,255,.08)';
      g.beginPath();
      g.moveTo(320, 0);
      g.lineTo(320, 34);
      g.stroke();
      g.fillStyle = 'rgba(0,0,0,.22)';
      rrCtx(g, 288, 34, 64, 26, 12); g.fill();

      // bancada
      g.fillStyle = 'rgba(0,0,0,.28)';
      rrCtx(g, 40, 224, 560, 54, 18); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.10)'; g.stroke();

      // frascos / b√©queres
      g.fillStyle = rgba(theme.a2, 0.14);
      for(let i=0;i<10;i++){
        const x = 70 + i*48;
        rrCtx(g, x, 192, 26, 38, 10); g.fill();
        g.fillStyle = 'rgba(255,255,255,.09)';
        rrCtx(g, x+6, 196, 14, 10, 6); g.fill();
        g.fillStyle = rgba(theme.a2, 0.14);
      }

      // bobina / catalisador
      g.strokeStyle = rgba(theme.a1, 0.14);
      g.lineWidth = 2;
      for(let i=0;i<5;i++){
        const x = 680 + i*34;
        g.beginPath();
        g.arc(x, 180, 14, 0, Math.PI*2);
        g.stroke();
      }
      g.lineWidth = 1;
      g.fillStyle = 'rgba(0,0,0,.20)';
      rrCtx(g, 640, 206, 300, 38, 16); g.fill();

      // etiquetas
      g.fillStyle = 'rgba(255,255,255,.07)';
      g.font = '1000 14px system-ui,Segoe UI,Roboto,Arial';
      g.fillText('OFICINA ‚Ä¢ CATALISADOR', 78, 94);
      g.fillText('‚öóÔ∏é  reagir  ‚Ä¢  abrir janelas', 78, 118);

      g.restore();
    }

    if(worldId===13){
      // dep√≥sito de resinas: estantes, tambores e goteira pegajosa
      g.save();

      // estantes
      g.fillStyle = 'rgba(0,0,0,.20)';
      for(let row=0;row<2;row++){
        const y = 58 + row*88;
        rrCtx(g, 54, y, BASE_W-108, 66, 20); g.fill();
        g.strokeStyle = 'rgba(255,255,255,.10)'; g.stroke();
      }

      // tambores/resina
      for(let i=0;i<12;i++){
        const x = 84 + i*74;
        const y = 78 + (i%2)*88;
        g.fillStyle = rgba(theme.a2, 0.10);
        rrCtx(g, x, y, 38, 54, 14); g.fill();
        g.fillStyle = 'rgba(255,255,255,.08)';
        rrCtx(g, x+6, y+8, 26, 8, 6); g.fill();
        g.fillStyle = 'rgba(0,0,0,.20)';
        rrCtx(g, x, y+50, 38, 10, 10); g.fill();
      }

      // placas de "resina"
      g.fillStyle = 'rgba(0,0,0,.24)';
      rrCtx(g, 56, 56, 260, 44, 14); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.12)'; g.stroke();
      g.fillStyle = 'rgba(255,255,255,.08)';
      g.font = '1000 16px system-ui,Segoe UI,Roboto,Arial';
      g.fillText('DEP√ìSITO ‚Ä¢ RESINAS', 76, 86);

      // goteira e po√ßas
      g.fillStyle = rgba(theme.a2, 0.10);
      for(let i=0;i<8;i++){
        const x = 140 + i*110;
        g.beginPath();
        g.moveTo(x, 46);
        g.quadraticCurveTo(x+6, 70, x+2, 98);
        g.quadraticCurveTo(x-2, 118, x+8, 132);
        g.strokeStyle = rgba(theme.a2, 0.10);
        g.lineWidth = 2;
        g.stroke();
        g.lineWidth = 1;

        const px = x + 6;
        const py = floorY + 64 + (i%3)*18;
        g.beginPath();
        g.ellipse(px, py, 34, 14, 0.2, 0, Math.PI*2);
        g.fill();
      }

      // setas de empilhadeira
      g.strokeStyle = 'rgba(255,255,255,.06)';
      for(let i=0;i<7;i++){
        const x = 90 + i*120;
        g.beginPath();
        g.moveTo(x, floorY+24);
        g.lineTo(x+46, floorY+24);
        g.lineTo(x+38, floorY+16);
        g.moveTo(x+46, floorY+24);
        g.lineTo(x+38, floorY+32);
        g.stroke();
      }

      g.restore();
    }

    if(worldId===14){
      // c√¢mara autolimpante: filtros, bicos de spray e luz UV
      g.save();

      // colunas/filtros laterais
      g.fillStyle = 'rgba(0,0,0,.22)';
      rrCtx(g, 34, 70, 110, 170, 26); g.fill();
      rrCtx(g, BASE_W-144, 70, 110, 170, 26); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.10)'; g.stroke();

      // grelhas
      g.strokeStyle = 'rgba(255,255,255,.07)';
      for(let i=0;i<7;i++){
        const y = 92 + i*22;
        g.beginPath(); g.moveTo(52, y); g.lineTo(124, y); g.stroke();
        g.beginPath(); g.moveTo(BASE_W-124, y); g.lineTo(BASE_W-52, y); g.stroke();
      }

      // tubos UV no teto
      g.strokeStyle = rgba(theme.a1, 0.12);
      g.lineWidth = 3;
      for(let i=0;i<4;i++){
        const x = 200 + i*200;
        g.beginPath();
        g.moveTo(x, 54);
        g.lineTo(x+140, 54);
        g.stroke();
      }
      g.lineWidth = 1;

      // bicos de spray
      g.fillStyle = 'rgba(0,0,0,.22)';
      for(let i=0;i<8;i++){
        const x = 140 + i*108;
        rrCtx(g, x, 72, 34, 20, 10); g.fill();
        g.fillStyle = 'rgba(255,255,255,.06)';
        g.beginPath(); g.arc(x+17, 82, 4, 0, Math.PI*2); g.fill();
        g.fillStyle = 'rgba(0,0,0,.22)';
      }

      // placa
      g.fillStyle = 'rgba(0,0,0,.24)';
      rrCtx(g, 56, 56, 300, 44, 14); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.12)'; g.stroke();
      g.fillStyle = 'rgba(255,255,255,.08)';
      g.font = '1000 16px system-ui,Segoe UI,Roboto,Arial';
      g.fillText('C√ÇMARA ‚Ä¢ AUTOLIMPANTE', 76, 86);

      // drenos no piso
      g.strokeStyle = 'rgba(255,255,255,.08)';
      for(let i=0;i<5;i++){
        const x = 180 + i*180;
        const y = floorY + 120;
        rrCtx(g, x, y, 90, 22, 12);
        g.stroke();
        for(let k=0;k<5;k++){
          g.beginPath();
          g.moveTo(x+12+k*16, y+6);
          g.lineTo(x+12+k*16, y+16);
          g.stroke();
        }
      }

      // setas/fluxo
      g.strokeStyle = rgba(theme.a1, 0.08);
      for(let i=0;i<8;i++){
        const y = 160 + i*26;
        const off = (i%2)*40;
        g.beginPath();
        g.moveTo(160+off, y);
        g.bezierCurveTo(340, y-10, 640, y+10, BASE_W-160, y);
        g.stroke();
      }

      g.restore();
    }

    if(worldId===15){
      // protocolo zero (boss): port√£o/vault lacrado, sirenes e selos
      g.save();

      // luz dram√°tica
      const halo = g.createRadialGradient(BASE_W*0.56, BASE_H*0.34, 40, BASE_W*0.56, BASE_H*0.38, 320);
      halo.addColorStop(0, 'rgba(255,75,110,.18)');
      halo.addColorStop(1, 'rgba(255,75,110,0)');
      g.fillStyle = halo;
      g.fillRect(0,0,BASE_W,BASE_H);

      // porta do cofre
      g.fillStyle = 'rgba(0,0,0,.28)';
      rrCtx(g, 560, 66, 380, 210, 28); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.12)'; g.stroke();

      // rebites
      g.fillStyle = 'rgba(255,255,255,.06)';
      for(let i=0;i<18;i++){
        const x = 580 + (i%6)*56;
        const y = 88 + Math.floor(i/6)*60;
        g.beginPath(); g.arc(x, y, 3.2, 0, Math.PI*2); g.fill();
      }

      // selo central
      g.strokeStyle = 'rgba(255,211,106,.14)';
      g.lineWidth = 2;
      g.beginPath();
      g.moveTo(748, 122);
      g.lineTo(816, 162);
      g.lineTo(748, 202);
      g.lineTo(680, 162);
      g.closePath();
      g.stroke();
      g.lineWidth = 1;

      // trincas
      g.strokeStyle = 'rgba(169,182,255,.08)';
      for(let i=0;i<6;i++){
        const x = 620 + i*58;
        g.beginPath();
        g.moveTo(x, 256);
        g.lineTo(x+24, 214);
        g.lineTo(x+46, 236);
        g.stroke();
      }

      // pain√©is de sirene
      for(let i=0;i<2;i++){
        const x = 70 + i*420;
        g.fillStyle = 'rgba(0,0,0,.22)';
        rrCtx(g, x, 56, 360, 74, 22); g.fill();
        g.strokeStyle = 'rgba(255,255,255,.10)'; g.stroke();
        g.fillStyle = 'rgba(255,255,255,.07)';
        g.font = '1000 14px system-ui,Segoe UI,Roboto,Arial';
        g.fillText(i===0?'PROTOCOLO ZERO':'SELAGEM ATIVA', x+22, 86);
        g.fillStyle = 'rgba(255,75,110,.10)';
        for(let k=0;k<6;k++){
          g.beginPath();
          g.arc(x+46+k*52, 108, 10, 0, Math.PI*2);
          g.fill();
        }
      }

      // cacos no piso
      g.fillStyle = 'rgba(169,182,255,.10)';
      for(let i=0;i<18;i++){
        const x = 80 + (i*54 % (BASE_W-160));
        const y = floorY + 40 + (i*37 % 140);
        g.beginPath();
        g.moveTo(x,y);
        g.lineTo(x+18,y+8);
        g.lineTo(x+6,y+22);
        g.closePath();
        g.fill();
      }

      g.restore();
    }


    // ===== Sobreviv√™ncia (101) ‚Äî ‚Äúguerra constante‚Äù =====
    if(worldId===101){
      g.save();

      // holofotes de emerg√™ncia
      for(let i=0;i<2;i++){
        const sx = i===0 ? 40 : BASE_W-40;
        const beam = g.createLinearGradient(sx, 34, BASE_W*0.5, 320);
        beam.addColorStop(0, 'rgba(255,211,106,.10)');
        beam.addColorStop(1, 'rgba(255,211,106,0)');
        g.fillStyle = beam;
        g.beginPath();
        g.moveTo(sx, 34);
        g.lineTo(sx + (i===0?220:-220), 110);
        g.lineTo(BASE_W*0.5, 360);
        g.lineTo(sx, 160);
        g.closePath();
        g.fill();
      }

      // vitrine quebrada / tapumes
      g.fillStyle = 'rgba(0,0,0,.28)';
      rrCtx(g, 58, 48, 560, 204, 30); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.12)'; g.stroke();

      // vidro (rachaduras)
      g.strokeStyle = 'rgba(142,225,255,.08)';
      for(let i=0;i<9;i++){
        const x0 = 78 + i*62;
        const y0 = 66 + (i%3)*8;
        g.beginPath();
        g.moveTo(x0, y0);
        g.lineTo(x0+46, y0+58);
        g.lineTo(x0+18, y0+112);
        g.stroke();
      }

      // t√°buas cruzadas
      g.lineWidth = 10;
      g.strokeStyle = 'rgba(0,0,0,.22)';
      for(let i=0;i<4;i++){
        const x = 100 + i*120;
        g.beginPath();
        g.moveTo(x, 230);
        g.lineTo(x+220, 64);
        g.stroke();
      }
      g.lineWidth = 1;
      g.strokeStyle = 'rgba(255,255,255,.10)';
      for(let i=0;i<4;i++){
        const x = 100 + i*120;
        g.beginPath();
        g.moveTo(x, 230);
        g.lineTo(x+220, 64);
        g.stroke();
      }

      // placa ‚ÄúEVACUAR‚Äù
      g.fillStyle = 'rgba(0,0,0,.22)';
      rrCtx(g, BASE_W-292, 54, 224, 62, 18); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.12)'; g.stroke();
      g.fillStyle = 'rgba(255,75,110,.14)';
      rrCtx(g, BASE_W-276, 66, 192, 38, 14); g.fill();
      g.fillStyle = 'rgba(255,255,255,.86)';
      g.font = '1200 16px system-ui,Segoe UI,Roboto,Arial';
      g.fillText('√ÅREA EM CONFLITO', BASE_W-264, 90);
      g.font = '1000 12px system-ui,Segoe UI,Roboto,Arial';
      g.fillStyle = 'rgba(255,255,255,.70)';
      g.fillText('EVACUAR ‚Ä¢ BRUMA INFINITA', BASE_W-264, 108);

      // barricada / sacos de areia no piso
      const by = floorY + 46;
      g.fillStyle = 'rgba(0,0,0,.20)';
      rrCtx(g, 58, floorY+18, BASE_W-116, 18, 10); g.fill();
      g.fillStyle = 'rgba(255,255,255,.06)';
      for(let i=0;i<18;i++){
        const x = 86 + i*52;
        g.beginPath();
        g.ellipse(x, by, 22, 11, 0.12, 0, Math.PI*2);
        g.fill();
      }

      // estilha√ßos / detritos
      g.fillStyle = 'rgba(255,211,106,.06)';
      for(let i=0;i<26;i++){
        const x = 70 + (i*54 % (BASE_W-140));
        const y = floorY + 22 + (i*31 % 170);
        g.beginPath();
        g.moveTo(x,y);
        g.lineTo(x+14,y+6);
        g.lineTo(x+6,y+18);
        g.closePath();
        g.fill();
      }

      g.restore();
    }

    // ===== Sobreviv√™ncia HARDCORE (102) ‚Äî ‚Äúapocalipse‚Äù =====
    if(worldId===102){
      g.save();

      // eclipse no c√©u
      const e = g.createRadialGradient(BASE_W*0.58, 110, 26, BASE_W*0.58, 120, 220);
      e.addColorStop(0, 'rgba(0,0,0,.45)');
      e.addColorStop(0.35, 'rgba(255,75,110,.14)');
      e.addColorStop(1, 'rgba(0,0,0,0)');
      g.fillStyle = e;
      g.fillRect(0,0,BASE_W,300);

      // ru√≠nas (pilares rachados)
      g.fillStyle = 'rgba(0,0,0,.30)';
      rrCtx(g, 40, 56, 90, 232, 26); g.fill();
      rrCtx(g, BASE_W-130, 56, 90, 232, 26); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.10)'; g.stroke();

      g.strokeStyle = 'rgba(169,182,255,.08)';
      for(let i=0;i<10;i++){
        const x = 58 + (i%2)* (BASE_W-188);
        const y = 72 + i*18;
        g.beginPath();
        g.moveTo(x, y);
        g.lineTo(x+64, y+32);
        g.lineTo(x+26, y+78);
        g.stroke();
      }

      // port√£o negro ao fundo (pra ‚Äúcara de boss‚Äù constante)
      g.fillStyle = 'rgba(0,0,0,.28)';
      rrCtx(g, 520, 62, 430, 226, 30); g.fill();
      g.strokeStyle = 'rgba(255,255,255,.12)'; g.stroke();

      // runas/selos
      g.strokeStyle = 'rgba(255,75,110,.12)';
      for(let i=0;i<3;i++){
        const cx = 616 + i*108;
        const cy = 150;
        g.beginPath();
        g.arc(cx, cy, 28, 0, Math.PI*2);
        g.stroke();
        g.beginPath();
        g.moveTo(cx-18, cy);
        g.lineTo(cx, cy-20);
        g.lineTo(cx+18, cy);
        g.lineTo(cx, cy+20);
        g.closePath();
        g.stroke();
      }

      // fita de perigo (listras)
      g.save();
      g.globalAlpha = 0.55;
      for(let i=0;i<22;i++){
        const x = 50 + i*46;
        g.fillStyle = (i%2===0) ? 'rgba(255,211,106,.12)' : 'rgba(0,0,0,.22)';
        rrCtx(g, x, 268, 34, 12, 6); g.fill();
      }
      g.restore();

      // cacos/fragmentos no piso
      g.fillStyle = 'rgba(255,75,110,.06)';
      for(let i=0;i<26;i++){
        const x = 70 + (i*54 % (BASE_W-140));
        const y = floorY + 30 + (i*29 % 160);
        g.beginPath();
        g.moveTo(x,y);
        g.lineTo(x+18,y+8);
        g.lineTo(x+6,y+22);
        g.closePath();
        g.fill();
      }

      g.restore();
    }


    // brilho extra (bem leve)
    const g2 = g.createLinearGradient(0, 110, BASE_W, 656);
    g2.addColorStop(0, 'rgba(255,255,255,.04)');
    g2.addColorStop(1, 'rgba(0,0,0,0)');
    g.fillStyle = g2;
    g.fillRect(0,0,BASE_W,BASE_H);

    return c;
  }

  function drawWorldAmbience(worldId){
    const t = visualTime;

    // part√≠culas ‚Äúfixas‚Äù (posi√ß√µes determin√≠sticas por mundo) ‚Äî baratas e agrad√°veis
    const baseN = 14;
    for(let i=0;i<baseN;i++){
      const a = i*0.47 + worldId*0.9;
      const x = 40 + (Math.sin(a*3.1)*0.5+0.5) * (BASE_W-80);
      const y = 120 + (Math.cos(a*2.3)*0.5+0.5) * 220;
      const p = 0.5 + 0.5*Math.sin(t*0.9 + a*2.0);
      ctx.fillStyle = (worldId===4||worldId===9) ? 'rgba(255,255,255,.05)' : 'rgba(255,255,255,.06)';
      ctx.beginPath();
      ctx.arc(x, y, 1.3 + 1.0*p, 0, Math.PI*2);
      ctx.fill();
    }

    // efeitos espec√≠ficos
    if(worldId===1 || worldId===8){
      // vaga-lumes
      for(let i=0;i<10;i++){
        const a = i*0.9;
        const x = 60 + ((i*97 + (t*22)) % (BASE_W-120));
        const y = 150 + 60*Math.sin(t*0.8 + a) + (i%3)*46;
        const pulse = 0.35 + 0.35*Math.sin(t*3.2 + a);
        ctx.fillStyle = `rgba(124,255,178,${0.10 + 0.18*pulse})`;
        ctx.beginPath();
        ctx.arc(x, y, 4.2, 0, Math.PI*2);
        ctx.fill();
      }
    }

    if(worldId===4){
      // chuva fininha (bem sutil)
      ctx.strokeStyle = 'rgba(255,255,255,.05)';
      for(let i=0;i<14;i++){
        const x = 40 + (i*68 + (t*80)) % (BASE_W-80);
        const y = 116 + (i*43 + (t*120)) % 320;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x+8, y+22);
        ctx.stroke();
      }
    }

    if(worldId===5 || worldId===10){
      // n√©voa/brasas
      for(let i=0;i<12;i++){
        const x = 50 + (i*83 + t*18) % (BASE_W-100);
        const y = 130 + (i*49 + t*12) % 260;
        const w = 46 + 12*Math.sin(t*0.7 + i);
        const h = 18 + 6*Math.cos(t*0.6 + i);
        ctx.fillStyle = (worldId===10) ? 'rgba(255,75,110,.06)' : 'rgba(255,75,110,.05)';
        ctx.beginPath();
        ctx.ellipse(x, y, w, h, 0.2, 0, Math.PI*2);
        ctx.fill();
      }
      for(let i=0;i<10;i++){
        const x = 560 + (i*36 + t*46) % 360;
        const y = 200 + (i*26 + t*30) % 240;
        ctx.fillStyle = 'rgba(255,211,106,.06)';
        ctx.beginPath();
        ctx.arc(x, y, 2.0, 0, Math.PI*2);
        ctx.fill();
      }
    }

    if(worldId===7){
      // vapor de caf√©
      for(let i=0;i<8;i++){
        const x = 90 + i*56;
        const y = 222 - (t*22 + i*18) % 70;
        ctx.strokeStyle = 'rgba(255,255,255,.06)';
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.quadraticCurveTo(x+10, y-12, x+2, y-26);
        ctx.stroke();
      }
    }

    if(worldId===6){
      // brilhos prism√°ticos
      for(let i=0;i<10;i++){
        const x = 70 + (i*88 + t*30) % (BASE_W-140);
        const y = 90 + (i*56 + t*18) % 220;
        const a = 0.05 + 0.06*(0.5+0.5*Math.sin(t*2.6+i));
        ctx.fillStyle = `rgba(169,182,255,${a})`;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x+16, y+6);
        ctx.lineTo(x+6, y+18);
        ctx.closePath();
        ctx.fill();
      }
    }

    if(worldId===9){
      // ‚Äúfluxo de ar‚Äù
      ctx.strokeStyle = 'rgba(142,225,255,.05)';
      for(let i=0;i<8;i++){
        const y = 120 + i*28;
        const off = (t*90 + i*90) % (BASE_W);
        ctx.beginPath();
        ctx.moveTo(40 - off*0.2, y);
        ctx.bezierCurveTo(220, y-12, 520, y+12, BASE_W-40, y);
        ctx.stroke();
      }
    }

    // === CAMPANHA 2 (11‚Äì15): ambience dedicado ===
    if(worldId===11){
      // poeira salina + got√≠culas frias
      for(let i=0;i<18;i++){
        const x = 60 + (i*77 + t*26) % (BASE_W-120);
        const y = 150 + (i*53 + t*14) % 260;
        const a = 0.03 + 0.05*(0.5+0.5*Math.sin(t*2.1+i));
        ctx.fillStyle = `rgba(255,255,255,${a})`;
        ctx.beginPath();
        ctx.arc(x, y, 2.2, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.strokeStyle = 'rgba(255,255,255,.05)';
      for(let i=0;i<10;i++){
        const x = 60 + (i*96 + (t*92)) % (BASE_W-120);
        const y = 120 + (i*52 + (t*130)) % 300;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x+10, y+26);
        ctx.stroke();
      }
    }

    if(worldId===12){
      // vapor qu√≠mico + fa√≠scas de bancada
      for(let i=0;i<10;i++){
        const x = 90 + (i*92 + t*18) % (BASE_W-180);
        const y = 140 + (i*60 + t*10) % 220;
        const w = 44 + 12*Math.sin(t*0.7 + i);
        const h = 16 + 6*Math.cos(t*0.6 + i);
        ctx.fillStyle = 'rgba(255,211,106,.05)';
        ctx.beginPath();
        ctx.ellipse(x, y, w, h, 0.15, 0, Math.PI*2);
        ctx.fill();
      }
      for(let i=0;i<12;i++){
        const x = 640 + (i*34 + t*90) % 300;
        const y = 150 + (i*26 + t*50) % 180;
        ctx.fillStyle = 'rgba(255,255,255,.06)';
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x+12, y+5);
        ctx.lineTo(x+4, y+16);
        ctx.closePath();
        ctx.fill();
      }
    }

    if(worldId===13){
      // pingos de resina + brilho pegajoso
      for(let i=0;i<10;i++){
        const x = 120 + (i*118) % (BASE_W-240);
        const y = 120 + ((t*56 + i*90) % 240);
        ctx.strokeStyle = 'rgba(255,211,106,.06)';
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x+2, y+18);
        ctx.stroke();

        ctx.fillStyle = 'rgba(255,211,106,.05)';
        ctx.beginPath();
        ctx.ellipse(x+4, y+20, 6, 3, 0.3, 0, Math.PI*2);
        ctx.fill();
      }
      for(let i=0;i<14;i++){
        const x = 80 + (i*66 + t*22) % (BASE_W-160);
        const y = 240 + (i*38 + t*12) % 200;
        const a = 0.03 + 0.04*(0.5+0.5*Math.sin(t*1.8+i));
        ctx.fillStyle = `rgba(255,211,106,${a})`;
        ctx.beginPath();
        ctx.arc(x, y, 1.9, 0, Math.PI*2);
        ctx.fill();
      }
    }

    if(worldId===14){
      // jatos finos + fluxo de ar
      ctx.strokeStyle = 'rgba(169,182,255,.06)';
      for(let i=0;i<14;i++){
        const x = 150 + (i*108) % (BASE_W-300);
        const y0 = 96;
        const y1 = 210 + 40*Math.sin(t*0.9+i);
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x+4, y1);
        ctx.stroke();
      }
      ctx.strokeStyle = 'rgba(255,255,255,.04)';
      for(let i=0;i<8;i++){
        const y = 130 + i*28;
        const off = (t*110 + i*90) % (BASE_W);
        ctx.beginPath();
        ctx.moveTo(40 - off*0.15, y);
        ctx.bezierCurveTo(240, y-10, 560, y+10, BASE_W-40, y);
        ctx.stroke();
      }
      // bolhas/espuma leve
      for(let i=0;i<12;i++){
        const x = 70 + (i*78 + t*30) % (BASE_W-140);
        const y = 240 + (i*46 + t*18) % 240;
        ctx.fillStyle = 'rgba(255,255,255,.05)';
        ctx.beginPath();
        ctx.arc(x, y, 4.0, 0, Math.PI*2);
        ctx.fill();
      }
    }

    if(worldId===15){
      // ‚Äúsweep‚Äù de sirene + part√≠culas
      const sweepX = (t*120) % (BASE_W+260) - 260;
      const grad = ctx.createLinearGradient(sweepX, 0, sweepX+260, 0);
      grad.addColorStop(0, 'rgba(255,75,110,0)');
      grad.addColorStop(0.5, 'rgba(255,75,110,.05)');
      grad.addColorStop(1, 'rgba(255,75,110,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, BASE_W, 220);

      for(let i=0;i<16;i++){
        const x = 70 + (i*66 + t*34) % (BASE_W-140);
        const y = 120 + (i*48 + t*18) % 260;
        ctx.fillStyle = 'rgba(169,182,255,.05)';
        ctx.beginPath();
        ctx.arc(x, y, 2.2, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // ===== Sobreviv√™ncia normal (101): ‚Äúguerra constante‚Äù =====
    if(worldId===101){
      // fuma√ßa de batalha
      for(let i=0;i<14;i++){
        const x = 60 + (i*92 + t*18) % (BASE_W-120);
        const y = 130 + (i*60 + t*10) % 240;
        const w = 52 + 14*Math.sin(t*0.65 + i);
        const h = 18 + 6*Math.cos(t*0.55 + i);
        ctx.fillStyle = 'rgba(255,255,255,.035)';
        ctx.beginPath();
        ctx.ellipse(x, y, w, h, 0.15, 0, Math.PI*2);
        ctx.fill();
      }

      // cinzas / poeira
      for(let i=0;i<28;i++){
        const x = 60 + (i*64 + t*34) % (BASE_W-120);
        const y = 120 + (i*38 + t*22) % 320;
        const a = 0.03 + 0.04*(0.5+0.5*Math.sin(t*1.7+i));
        ctx.fillStyle = `rgba(255,211,106,${a})`;
        ctx.beginPath();
        ctx.arc(x, y, 1.6, 0, Math.PI*2);
        ctx.fill();
      }

      // flashes de explos√£o (ocasionais)
      const boom = 0.5 + 0.5*Math.sin(t*0.85 + 1.7);
      if(boom>0.94){
        const a = (boom-0.94)/0.06 * 0.11;
        ctx.fillStyle = `rgba(255,211,106,${a})`;
        ctx.fillRect(0, 110, BASE_W, 260);
      }

      // varredura de holofote
      const sweepX = (t*140) % (BASE_W+320) - 320;
      const grad = ctx.createLinearGradient(sweepX, 0, sweepX+320, 0);
      grad.addColorStop(0, 'rgba(255,255,255,0)');
      grad.addColorStop(0.5, 'rgba(255,255,255,.05)');
      grad.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, BASE_W, 240);
    }

    // ===== Sobreviv√™ncia HARDCORE (102): ‚Äúapocalipse‚Äù =====
    if(worldId===102){
      // sirene mais forte
      const sweepX = (t*160) % (BASE_W+300) - 300;
      const grad = ctx.createLinearGradient(sweepX, 0, sweepX+300, 0);
      grad.addColorStop(0, 'rgba(255,75,110,0)');
      grad.addColorStop(0.5, 'rgba(255,75,110,.08)');
      grad.addColorStop(1, 'rgba(255,75,110,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, BASE_W, 260);

      // chuva t√≥xica
      ctx.strokeStyle = 'rgba(124,255,178,.05)';
      for(let i=0;i<20;i++){
        const x = 40 + (i*68 + (t*110)) % (BASE_W-80);
        const y = 116 + (i*43 + (t*180)) % 360;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x+10, y+30);
        ctx.stroke();
      }

      // brasas/part√≠culas pesadas
      for(let i=0;i<20;i++){
        const x = 60 + (i*76 + t*40) % (BASE_W-120);
        const y = 130 + (i*52 + t*26) % 300;
        ctx.fillStyle = 'rgba(255,75,110,.05)';
        ctx.beginPath();
        ctx.arc(x, y, 2.2, 0, Math.PI*2);
        ctx.fill();
      }

      // rel√¢mpago (ocasionais)
      const flash = 0.5 + 0.5*Math.sin(t*0.72 + 2.4);
      if(flash>0.965){
        const a = (flash-0.965)/0.035 * 0.14;
        ctx.fillStyle = `rgba(255,255,255,${a})`;
        ctx.fillRect(0, 0, BASE_W, 260);

        const seed = Math.floor(t*2.0) + 102*13;
        let x = 220 + (Math.sin(seed)*0.5+0.5)*560;
        let y = 112;
        ctx.strokeStyle = 'rgba(255,255,255,.18)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        for(let s=0;s<8;s++){
          x += Math.sin(seed*3.1 + s*2.7)*18;
          y += 30 + Math.sin(seed*1.7 + s)*10;
          ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.lineWidth = 1;
      }
    }


  }

  function drawWorldBackdrop(worldId){
    let bg = backdropCache.get(worldId);
    if(!bg){
      bg = buildBackdrop(worldId);
      backdropCache.set(worldId, bg);
    }
    ctx.drawImage(bg, 0, 0);
    drawWorldAmbience(worldId);
  }

  function drawBackground(){
    const wId = currentWorld ? currentWorld.id : 1;
    drawWorldBackdrop(wId);

    ctx.fillStyle = "rgba(238,242,255,.95)";
    ctx.font = "1000 22px system-ui,Segoe UI,Roboto,Arial";
    ctx.fillText("Defenda a vitrine do mal cheiro!", GRID_X, 82);
    ctx.fillStyle = "rgba(238,242,255,.80)";
    ctx.font = "900 14px system-ui,Segoe UI,Roboto,Arial";
    ctx.fillText(currentWorld ? currentWorld.name : "‚Äî", GRID_X, 106);

    ctx.fillStyle = "rgba(255,255,255,.05)";
    rr(GRID_X-14, GRID_Y-14, GRID_W+28, GRID_H+28, 20);
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.stroke();

    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const x = GRID_X + c*CELL_W;
        const y = GRID_Y + r*CELL_H;
        const alt = (r+c)%2===0;
        ctx.fillStyle = alt ? "rgba(34,48,98,.40)" : "rgba(42,58,122,.28)";
        rr(x+4, y+4, CELL_W-8, CELL_H-8, 16);
        ctx.fill();

        
// cratera (tile bloqueado) ‚Äî bem percept√≠vel
const lockT = cellLocks[r][c] || 0;
if(lockT > 0){
  const cx = x + CELL_W/2;
  const cy = y + CELL_H/2;
  const k = clamp(lockT / 60, 0, 1);
  ctx.save();

  // base escura + borda "queimada"
  ctx.globalAlpha = 0.90;
  ctx.fillStyle = "rgba(0,0,0,.72)";
  ctx.beginPath();
  ctx.ellipse(cx, cy+3, CELL_W*0.38, CELL_H*0.30, 0, 0, Math.PI*2);
  ctx.fill();

  ctx.globalAlpha = 0.75;
  ctx.strokeStyle = "rgba(255,106,106,.45)";
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.ellipse(cx, cy+3, CELL_W*0.40, CELL_H*0.32, 0, 0, Math.PI*2);
  ctx.stroke();

  // rachaduras
  ctx.globalAlpha = 0.55;
  ctx.strokeStyle = "rgba(255,255,255,.12)";
  ctx.lineWidth = 1.4;
  for(let i=0;i<5;i++){
    const ang = (i*1.2 + r*0.7 + c*0.9);
    const x1 = cx + Math.cos(ang)* (CELL_W*0.06);
    const y1 = cy + 3 + Math.sin(ang)* (CELL_H*0.05);
    const x2 = cx + Math.cos(ang+0.6)* (CELL_W*0.18);
    const y2 = cy + 3 + Math.sin(ang+0.6)* (CELL_H*0.14);
    const x3 = cx + Math.cos(ang+1.1)* (CELL_W*0.28);
    const y3 = cy + 3 + Math.sin(ang+1.1)* (CELL_H*0.22);
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.lineTo(x3,y3);
    ctx.stroke();
  }

  // √≠cone + tempo
  ctx.globalAlpha = 0.95;
  ctx.fillStyle = "rgba(238,242,255,.90)";
  ctx.font = "1000 13px system-ui,Segoe UI,Roboto,Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("‚õî", cx, cy+2);
  ctx.font = "900 11px system-ui,Segoe UI,Roboto,Arial";
  ctx.fillText(`${Math.ceil(lockT)}s`, cx, cy+18);

  ctx.restore();
}

        ctx.fillStyle = "rgba(255,255,255,.03)";
        for(let i=0;i<3;i++){
          ctx.beginPath();
          ctx.arc(x+14+i*16, y+14+(i%2)*6, 1.2, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    ctx.fillStyle = "rgba(255,255,255,.05)";
    rr(GRID_X+GRID_W+30, GRID_Y-10, 260, GRID_H+20, 18);
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.stroke();
  }

  
  // frascos √∫nicos por perfume (silhuetas diferentes)
  const BottleStyles = {
    sun:        {shape:'lily',     cap:'flower',  label:'oval'},
    shooter:    {shape:'drop',     cap:'flat',    label:'band'},
    cone:       {shape:'spray',    cap:'nozzle',  label:'band'},
    wall:       {shape:'square',   cap:'heavy',   label:'plate'},
    slow:       {shape:'ice',      cap:'frost',   label:'band'},
    healer:     {shape:'round',    cap:'cork',    label:'cross'},
    bomb:       {shape:'canister', cap:'pin',     label:'band'},
    beam:       {shape:'tube',     cap:'lens',    label:'plate'},
    prismLens:  {shape:'prism',    cap:'gem',     label:'plate'},
    coffeeTrap: {shape:'mug',      cap:'lid',     label:'band'},
    arboBoost:  {shape:'tall',     cap:'wood',    label:'leaf'},
    nativaClean:{shape:'bubble',   cap:'pump',    label:'band'},
    kaiakSal:   {shape:'canister', cap:'pump',   label:'band'},
    zaadCat:    {shape:'tube',     cap:'gem',    label:'plate'},
    ekosResin:  {shape:'square',   cap:'wood',   label:'leaf'},
    cremeLily:     {shape:'stout',     cap:'doubleflower', label:'ribbon'},
    lizAura:       {shape:'aura',      cap:'crown',        label:'cross'},
    quasarFire:    {shape:'inferno',   cap:'vent',         label:'ember'},
    florattaDuplo: {shape:'duo',      cap:'heart',        label:'ribbon'},
    lunaNova:      {shape:'moon',     cap:'lens',         label:'ribbon'},
    glamourVortex: {shape:'vortex',   cap:'gem',          label:'sigil'},
    prismaSupreme: {shape:'supreme',  cap:'crown',        label:'crest'},
    malbecLegend:  {shape:'legend',   cap:'steel',        label:'crest'},
    refil:         {shape:'refill',    cap:'pump',         label:'band'},
    egeoBombBlack: {shape:'doom',     cap:'skullpin',     label:'hazard'},
    casa214:       {shape:'house',    cap:'roof',         label:'plate'},
    botikMagnet:   {shape:'magnet',   cap:'gem',          label:'sigil'},
    // presets livres para o Perfume Customizado
    presetDrop:   {shape:'drop',     cap:'flat',         label:'band'},
    presetStout:  {shape:'stout',    cap:'doubleflower', label:'ribbon'},
    presetTube:   {shape:'tube',     cap:'lens',         label:'plate'},
    presetSquare: {shape:'square',   cap:'steel',        label:'crest'},
    presetSpray:  {shape:'spray',    cap:'nozzle',       label:'band'},
    presetRound:  {shape:'round',    cap:'cork',         label:'cross'},
    customPerfume:{shape:'drop',     cap:'gem',          label:'crest'}
  };

  function bottleGradient(tint){
    const bg = ctx.createLinearGradient(-26,-42, 26, 44);
    bg.addColorStop(0, rgba(tint, .98));
    bg.addColorStop(0.45, 'rgba(255,255,255,.26)');
    bg.addColorStop(1, rgba(tint, .70));
    return bg;
  }

  function drawBottle(x,y,def,label, shake=0, flash=null){
    const tint = def.tint;
    let styleKey = def.id;
    if(def.id==="customPerfume"){
      const bk = (progress && progress.customPerfume && progress.customPerfume.bottleKey) ? progress.customPerfume.bottleKey : null;
      styleKey = bk || "presetDrop";
    }
    const style = BottleStyles[styleKey] || BottleStyles[def.id] || {shape:'tall', cap:'flat', label:'band'};

    ctx.save();
    ctx.translate(x + shake, y);

    // sombra
    ctx.fillStyle = 'rgba(0,0,0,.26)';
    ctx.beginPath();
    ctx.ellipse(0, 34, 26, 10, 0, 0, Math.PI*2);
    ctx.fill();

    // corpo
    ctx.fillStyle = bottleGradient(tint);
    ctx.strokeStyle = 'rgba(255,255,255,.18)';

    // path por forma
    ctx.beginPath();
    if(style.shape==='lily'){
      // alto e delicado
      rr(-20,-36, 40, 74, 18);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = bottleGradient(tint);
      rr(-12,-50, 24, 18, 10);
      ctx.fill(); ctx.stroke();
    } else if(style.shape==='drop'){
      // gota (mais arredondado)
      rr(-22,-30, 44, 58, 22);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = bottleGradient(tint);
      rr(-10,-48, 20, 22, 10);
      ctx.fill(); ctx.stroke();
    } else if(style.shape==='spray'){
      // atomizador (mais alto)
      rr(-18,-40, 36, 78, 14);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,.12)';
      rr(-10,-56, 20, 18, 8);
      ctx.fill(); ctx.strokeStyle='rgba(255,255,255,.14)'; ctx.stroke();
      ctx.fillStyle = bottleGradient(tint);
    } else if(style.shape==='square'){
      // robusto
      rr(-24,-28, 48, 58, 10);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,.10)';
      rr(-12,-46, 24, 18, 8);
      ctx.fill(); ctx.strokeStyle='rgba(255,255,255,.12)'; ctx.stroke();
      ctx.fillStyle = bottleGradient(tint);
    } else if(style.shape==='ice'){
      // facetas geladas
      rr(-20,-38, 40, 76, 12);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = rgba('#A9B6FF', 0.16);
      for(let i=0;i<5;i++){
        ctx.beginPath();
        ctx.moveTo(-14+i*7, -34);
        ctx.lineTo(-10+i*7, 30);
        ctx.strokeStyle = 'rgba(255,255,255,.10)';
        ctx.stroke();
      }
      ctx.fillStyle = bottleGradient(tint);
    } else if(style.shape==='round'){
      // botik: ‚Äúfrasco de cuidado‚Äù
      rr(-22,-30, 44, 62, 20);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = bottleGradient(tint);
      rr(-11,-50, 22, 20, 10);
      ctx.fill(); ctx.stroke();
    } else if(style.shape==='canister'){
      // quasar: cilindro com cintura
      rr(-20,-36, 40, 72, 12);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = 'rgba(0,0,0,.12)';
      rr(-22,-6, 44, 14, 10);
      ctx.fill();
      ctx.fillStyle = bottleGradient(tint);
    } else if(style.shape==='tube'){
      // purificador: tubo t√©cnico
      rr(-16,-44, 32, 88, 12);
      ctx.fill(); ctx.stroke();
      // janela
      ctx.fillStyle = 'rgba(255,255,255,.08)';
      rr(-10,-18, 20, 40, 10);
      ctx.fill();
      ctx.fillStyle = bottleGradient(tint);
    } else if(style.shape==='prism'){
      // elys√©e: prisma
      ctx.moveTo(0,-50);
      ctx.lineTo(22,-16);
      ctx.lineTo(10,36);
      ctx.lineTo(-10,36);
      ctx.lineTo(-22,-16);
      ctx.closePath();
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,.10)';
      ctx.beginPath();
      ctx.moveTo(0,-42);
      ctx.lineTo(12,-18);
      ctx.lineTo(0,8);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = bottleGradient(tint);
    } else if(style.shape==='mug'){
      // coffee trap: caneca
      rr(-20,-26, 40, 56, 16);
      ctx.fill(); ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,.16)';
      ctx.beginPath();
      ctx.arc(18, 4, 12, -0.6, 0.8);
      ctx.stroke();
      ctx.fillStyle = bottleGradient(tint);
      rr(-12,-44, 24, 18, 10);
      ctx.fill();
    } else if(style.shape==='bubble'){
      // nativa clean: bolhas
      rr(-20,-34, 40, 66, 18);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,.10)';
      for(let i=0;i<5;i++){
        ctx.beginPath();
        ctx.arc(-10+i*6, -6+i*4, 4, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.fillStyle = bottleGradient(tint);
    
} else if(style.shape==='stout'){
      // stout: gordinho e baixinho (Creme Lily)
      rr(-24,-24, 48, 52, 18);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = bottleGradient(tint);
      rr(-12,-42, 24, 18, 10);
      ctx.fill(); ctx.stroke();
    } else if(style.shape==='moon'){
      // moon: frasco com meia-lua (Luna Nova)
      rr(-20,-38, 40, 76, 16);
      ctx.fill(); ctx.stroke();
      // meia-lua
      ctx.fillStyle = 'rgba(255,255,255,.12)';
      ctx.beginPath();
      ctx.arc(-2, -6, 18, 0.2, Math.PI*1.85);
      ctx.arc(6, -6, 14, 0.2, Math.PI*1.85, true);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = bottleGradient(tint);
    } else if(style.shape==='vortex'){
      // vortex: frasco torcido (Glamour Vortex)
      rr(-18,-40, 36, 78, 14);
      ctx.fill(); ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,.12)';
      for(let i=0;i<3;i++){
        ctx.beginPath();
        ctx.moveTo(-16, -26 + i*18);
        ctx.bezierCurveTo(-6, -36 + i*18, 6, -16 + i*18, 16, -26 + i*18);
        ctx.stroke();
      }
      ctx.fillStyle = bottleGradient(tint);
    } else if(style.shape==='supreme'){
      // supreme: prisma alto com base (Prisma Supreme)
      ctx.beginPath();
      ctx.moveTo(0,-52);
      ctx.lineTo(22,-20);
      ctx.lineTo(14,34);
      ctx.lineTo(-14,34);
      ctx.lineTo(-22,-20);
      ctx.closePath();
      ctx.fill(); ctx.stroke();
      // base
      ctx.fillStyle = 'rgba(0,0,0,.10)';
      rr(-18, 24, 36, 14, 8);
      ctx.fill();
      ctx.fillStyle = bottleGradient(tint);
    } else if(style.shape==='twin'){
  // twin: dois frascos colados (Creme Lily)
  rr(-24,-30, 22, 60, 16); ctx.fill(); ctx.stroke();
  rr(2,-30, 22, 60, 16); ctx.fill(); ctx.stroke();
  ctx.fillStyle = bottleGradient(tint);
  rr(-10,-50, 20, 20, 10); ctx.fill(); ctx.stroke();
  rr(6,-50, 14, 20, 9); ctx.fill(); ctx.stroke();
} else if(style.shape==='aura'){
  // aura: frasco redondo com halo (Liz Aura)
  rr(-22,-30, 44, 58, 22); ctx.fill(); ctx.stroke();
  ctx.strokeStyle = 'rgba(255,255,255,.18)';
  ctx.beginPath(); ctx.arc(0, -2, 26, 0, Math.PI*2); ctx.stroke();
} else if(style.shape==='inferno'){
  // inferno: frasco alto com ombros (Quasar Fire)
  rr(-18,-40, 36, 78, 12); ctx.fill(); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-18,-18); ctx.lineTo(-28,-10); ctx.lineTo(-18,-2);
  ctx.moveTo(18,-18); ctx.lineTo(28,-10); ctx.lineTo(18,-2);
  ctx.strokeStyle = 'rgba(255,255,255,.14)';
  ctx.stroke();
} else if(style.shape==='duo'){
  // duo: frasco "dupla press√£o" (Floratta Duplo)
  rr(-20,-34, 40, 66, 18); ctx.fill(); ctx.stroke();
  ctx.strokeStyle = 'rgba(255,255,255,.16)';
  ctx.beginPath(); ctx.moveTo(0,-32); ctx.lineTo(0,30); ctx.stroke();
} else if(style.shape==='legend'){
  // legend: bloco robusto (Malbec Legend)
  rr(-26,-26, 52, 60, 14); ctx.fill(); ctx.stroke();
  ctx.strokeStyle = 'rgba(255,255,255,.14)';
  ctx.beginPath(); rr(-18,-18, 36, 44, 12); ctx.stroke();
} else if(style.shape==='refill'){
  // refill: cilindro fino com cinta (Refil)
  rr(-16,-40, 32, 78, 14); ctx.fill(); ctx.stroke();
  ctx.fillStyle = 'rgba(0,0,0,.18)';
  rr(-18,-4, 36, 18, 10); ctx.fill();
} else if(style.shape==='doom'){
  // doom: barril/‚Äúcogumelo‚Äù (Egeo Bomb Black)
  rr(-24,-22, 48, 54, 16); ctx.fill(); ctx.stroke();
  ctx.beginPath(); ctx.ellipse(0,-24, 26, 12, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
} else if(style.shape==='house'){
  // house: silhueta de casinha (Casa 214)
  ctx.beginPath();
  ctx.moveTo(-22, 26);
  ctx.lineTo(-22, -6);
  ctx.lineTo(0, -34);
  ctx.lineTo(22, -6);
  ctx.lineTo(22, 26);
  ctx.closePath();
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = 'rgba(255,255,255,.10)';
  rr(-8, -4, 16, 18, 6); ctx.fill();
} else if(style.shape==='magnet'){
  // magnet: angular (Botik Magnet)
  ctx.beginPath();
  ctx.moveTo(0, -40);
  ctx.lineTo(22, -22);
  ctx.lineTo(22, 18);
  ctx.lineTo(0, 34);
  ctx.lineTo(-22, 18);
  ctx.lineTo(-22, -22);
  ctx.closePath();
  ctx.fill(); ctx.stroke();
} else {
      // padr√£o alto
      rr(-20,-38, 40, 76, 14);
      ctx.fill(); ctx.stroke();
    }

    // tampa por tipo
    ctx.fillStyle = 'rgba(0,0,0,.28)';
    ctx.strokeStyle = 'rgba(255,255,255,.10)';
    if(style.cap==='flower'){
      rr(-12,-62, 24, 14, 10); ctx.fill(); ctx.stroke();
      ctx.fillStyle = rgba('#FFD36A', 0.14);
      for(let i=0;i<5;i++){
        const a = i* (Math.PI*2/5);
        ctx.beginPath();
        ctx.ellipse(Math.cos(a)*10, -68+Math.sin(a)*4, 6, 3.5, a, 0, Math.PI*2);
        ctx.fill();
      }
    } else if(style.cap==='nozzle'){
      rr(-10,-62, 20, 14, 8); ctx.fill(); ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,.12)';
      rr(2,-66, 18, 10, 6); ctx.fill();
    } else if(style.cap==='lens'){
      rr(-10,-64, 20, 16, 8); ctx.fill(); ctx.stroke();
      const lg = ctx.createRadialGradient(0,-56, 2, 0,-56, 18);
      lg.addColorStop(0, 'rgba(159,255,216,.22)');
      lg.addColorStop(1, 'rgba(159,255,216,0)');
      ctx.fillStyle = lg;
      ctx.beginPath();
      ctx.arc(0,-56, 14, 0, Math.PI*2);
      ctx.fill();
    } else if(style.cap==='pump'){
      rr(-10,-62, 20, 14, 8); ctx.fill(); ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,.10)';
      rr(-6,-70, 26, 10, 6); ctx.fill();
    } else if(style.cap==='wood'){
      ctx.fillStyle = 'rgba(58,35,24,.55)';
      rr(-12,-62, 24, 14, 8); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.08)'; ctx.stroke();
    } else if(style.cap==='frost'){
      ctx.fillStyle = 'rgba(169,182,255,.22)';
      rr(-12,-62, 24, 14, 8); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.10)'; ctx.stroke();
    } else if(style.cap==='pin'){
      rr(-10,-62, 20, 14, 8); ctx.fill(); ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,.10)';
      ctx.beginPath();
      ctx.arc(0,-66, 5, 0, Math.PI*2);
      ctx.fill();
    } else if(style.cap==='heavy'){
      rr(-14,-56, 28, 18, 10); ctx.fill(); ctx.stroke();
    } else if(style.cap==='gem'){
      ctx.fillStyle = 'rgba(169,182,255,.18)';
      ctx.beginPath();
      ctx.moveTo(0,-66);
      ctx.lineTo(12,-56);
      ctx.lineTo(0,-46);
      ctx.lineTo(-12,-56);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,.10)'; ctx.stroke();
    } else if(style.cap==='lid'){
      rr(-12,-52, 24, 12, 8); ctx.fill(); ctx.stroke();
    
} else if(style.cap==='doubleflower'){
  rr(-14,-62, 28, 14, 10); ctx.fill(); ctx.stroke();
  ctx.fillStyle = rgba('#FFD36A', 0.14);
  ctx.beginPath(); ctx.ellipse(-7, -68, 6, 3.5, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(7, -68, 6, 3.5, 0, 0, Math.PI*2); ctx.fill();
} else if(style.cap==='crown'){
  ctx.beginPath();
  ctx.moveTo(-14,-60); ctx.lineTo(-10,-70); ctx.lineTo(-4,-62); ctx.lineTo(0,-72);
  ctx.lineTo(4,-62); ctx.lineTo(10,-70); ctx.lineTo(14,-60);
  ctx.closePath(); ctx.fill(); ctx.stroke();
} else if(style.cap==='vent'){
  rr(-14,-62, 28, 14, 8); ctx.fill(); ctx.stroke();
  ctx.strokeStyle = 'rgba(255,255,255,.18)';
  for(let i=-8;i<=8;i+=4){ ctx.beginPath(); ctx.moveTo(i,-60); ctx.lineTo(i,-50); ctx.stroke(); }
  ctx.strokeStyle = 'rgba(255,255,255,.10)';
} else if(style.cap==='heart'){
  rr(-12,-62, 24, 14, 8); ctx.fill(); ctx.stroke();
  ctx.fillStyle = rgba('#FF8AD6', 0.22);
  ctx.beginPath();
  ctx.arc(-5,-67,4,0,Math.PI*2);
  ctx.arc(5,-67,4,0,Math.PI*2);
  ctx.moveTo(-9,-66);
  ctx.lineTo(0,-58);
  ctx.lineTo(9,-66);
  ctx.closePath(); ctx.fill();
} else if(style.cap==='steel'){
  rr(-16,-62, 32, 14, 6); ctx.fill(); ctx.stroke();
  ctx.strokeStyle = 'rgba(255,255,255,.18)';
  ctx.beginPath(); ctx.moveTo(-12,-55); ctx.lineTo(12,-55); ctx.stroke();
  ctx.strokeStyle = 'rgba(255,255,255,.10)';
} else if(style.cap==='skullpin'){
  rr(-12,-62, 24, 14, 8); ctx.fill(); ctx.stroke();
  ctx.fillStyle = 'rgba(238,242,255,.70)';
  ctx.font = "900 12px system-ui,Segoe UI,Roboto,Arial";
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText("‚ò†", 0, -55);
  ctx.textAlign="left"; ctx.textBaseline="alphabetic";
} else if(style.cap==='roof'){
  ctx.beginPath();
  ctx.moveTo(-16,-56); ctx.lineTo(0,-72); ctx.lineTo(16,-56); ctx.closePath();
  ctx.fill(); ctx.stroke();
} else {
      rr(-12,-60, 24, 14, 8); ctx.fill(); ctx.stroke();
    }

    // r√≥tulo
    const plate = (style.label==='plate');
    ctx.fillStyle = plate ? 'rgba(0,0,0,.34)' : 'rgba(0,0,0,.28)';
    if(style.label==='oval'){
      ctx.beginPath();
      ctx.ellipse(0, 10, 18, 11, 0, 0, Math.PI*2);
      ctx.fill();
    
} else if(style.label==='ribbon'){
  // fita
  rr(-20, 2, 40, 18, 10); ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,.10)';
  ctx.beginPath(); ctx.moveTo(-20,11); ctx.lineTo(-30,6); ctx.lineTo(-20,6); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(20,11); ctx.lineTo(30,6); ctx.lineTo(20,6); ctx.closePath(); ctx.fill();
  ctx.fillStyle = plate ? 'rgba(0,0,0,.34)' : 'rgba(0,0,0,.28)';
} else if(style.label==='ember'){
  rr(-18, 2, 36, 20, 10); ctx.fill();
  ctx.fillStyle = 'rgba(255,106,61,.16)';
  ctx.beginPath(); ctx.arc(0,12,10,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = plate ? 'rgba(0,0,0,.34)' : 'rgba(0,0,0,.28)';
} else if(style.label==='crest'){
  rr(-18, 2, 36, 20, 10); ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,.12)';
  ctx.beginPath(); ctx.moveTo(-10,6); ctx.lineTo(0,2); ctx.lineTo(10,6); ctx.lineTo(6,18); ctx.lineTo(-6,18); ctx.closePath(); ctx.stroke();
  ctx.strokeStyle = 'rgba(255,255,255,.10)';
} else if(style.label==='hazard'){
  rr(-18, 2, 36, 20, 10); ctx.fill();
  ctx.strokeStyle = 'rgba(255,211,106,.18)';
  for(let i=-18;i<=18;i+=6){ ctx.beginPath(); ctx.moveTo(i,2); ctx.lineTo(i+12,22); ctx.stroke(); }
  ctx.strokeStyle = 'rgba(255,255,255,.10)';
} else if(style.label==='sigil'){
  ctx.beginPath(); ctx.ellipse(0, 12, 18, 12, 0, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,.14)';
  ctx.beginPath(); ctx.arc(0,12,7,0,Math.PI*2); ctx.stroke();
  ctx.strokeStyle = 'rgba(255,255,255,.10)';
} else {
      rr(-18, 2, 36, 20, 10); ctx.fill();
    }

    // √≠cone + texto
    ctx.fillStyle = 'rgba(238,242,255,.92)';
    ctx.font = '1000 11px system-ui,Segoe UI,Roboto,Arial';
    const txt = label;
    ctx.fillText(txt, -ctx.measureText(txt).width/2, 14);
    ctx.font = '1000 13px system-ui,Segoe UI,Roboto,Arial';
    ctx.fillText(def.icon || '', -ctx.measureText(def.icon||'').width/2, -4);

    // brilho
    ctx.strokeStyle = 'rgba(255,255,255,.20)';
    ctx.beginPath();
    ctx.moveTo(-10,-22);
    ctx.quadraticCurveTo(-18, 2, -8, 22);
    ctx.stroke();

    // flash (cura/buff)
    if(flash && flash.t > 0){
      const a = clamp(flash.t/0.24, 0, 1);
      ctx.fillStyle = rgba(flash.color, 0.18*a);
      ctx.beginPath();
      ctx.arc(0, 2, 48, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = rgba(flash.color, 0.35*a);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 2, 44, 0, Math.PI*2);
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    ctx.restore();
  }

  function drawPlant(p){
    const cc = cellCenter(p.row,p.col);
    const bob = Math.sin(gameTime*2 + p.bob) * 1.3;
    const hpPct = clamp(p.hp/p.maxHp, 0, 1);
    const low = hpPct < 0.25;

    let shake = 0;
    if(low){
      shake = Math.sin(gameTime*24) * 1.2;
      const pulse = 0.35 + 0.35*Math.sin(gameTime*8);
      ctx.strokeStyle = `rgba(255,106,106,${pulse})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(cc.x, cc.y+bob, 42, 0, Math.PI*2);
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    if(p.buffT > 0){
      ctx.beginPath();
      ctx.fillStyle = rgba("#7CFFB2", 0.10);
      ctx.arc(cc.x, cc.y+bob, 42, 0, Math.PI*2);
      ctx.fill();
    }
    if(p.stickyT > 0){
      ctx.beginPath();
      ctx.fillStyle = rgba("#D7A0FF", 0.10);
      ctx.arc(cc.x, cc.y+bob, 42, 0, Math.PI*2);
      ctx.fill();
    }


    // infuse: aura da cor do perfume que aplicou o buff (12.0+)
    if((p.infuseT||0) > 0){
      const col = p.infuseCol || "#B9FFD9";
      const pulse = 0.35 + 0.35*Math.sin(gameTime*5 + p.bob);
      ctx.beginPath();
      ctx.fillStyle = rgba(col, 0.08 + 0.06*pulse);
      ctx.arc(cc.x, cc.y+bob, 46, 0, Math.PI*2);
      ctx.fill();
      ctx.lineWidth = 2.2;
      ctx.strokeStyle = rgba(col, 0.18 + 0.18*pulse);
      ctx.beginPath();
      ctx.arc(cc.x, cc.y+bob, 44, 0, Math.PI*2);
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    // infuse shield: anel extra + barra (12.6)
    if((p.infuseT||0) > 0 && p.infuseType==="shield" && (p.infuseShieldHp||0) > 0){
      const col = p.infuseCol || "#B9FFD9";
      const cap = (p.infuseShieldCap||p.infuseShieldHp||1);
      const sp = clamp((p.infuseShieldHp||0)/cap, 0, 1);
      ctx.strokeStyle = rgba(col, 0.20 + 0.55*sp);
      ctx.lineWidth = 3.1;
      ctx.beginPath();
      ctx.arc(cc.x, cc.y+bob, 50, 0, Math.PI*2);
      ctx.stroke();
      ctx.lineWidth = 1;

      // barra pequena (topo)
      ctx.fillStyle = rgba("#000", 0.22);
      rr(cc.x-24, cc.y-78+bob, 48, 6, 3); ctx.fill();
      ctx.fillStyle = rgba(col, 0.70);
      rr(cc.x-24, cc.y-78+bob, 48*sp, 6, 3); ctx.fill();
    }


    // infuse: badge + timer ring (12.9)
    if((p.infuseT||0) > 0){
      const col = p.infuseCol || "#B9FFD9";

      // ring de tempo (s√≥ tempor√°rio)
      if(!p.infusePerm){
        const tmax = Math.max(0.01, p.infuseTMax || p.infuseT);
        const pct = clamp((p.infuseT||0)/tmax, 0, 1);

        ctx.lineWidth = 3.4;
        // fundo
        ctx.strokeStyle = rgba(col, 0.14);
        ctx.beginPath();
        ctx.arc(cc.x, cc.y+bob, 58, -Math.PI/2, -Math.PI/2 + Math.PI*2);
        ctx.stroke();
        // progresso
        ctx.strokeStyle = rgba(col, 0.62);
        ctx.beginPath();
        ctx.arc(cc.x, cc.y+bob, 58, -Math.PI/2, -Math.PI/2 + Math.PI*2*pct);
        ctx.stroke();
        ctx.lineWidth = 1;
      }

      // badge (lado esquerdo para n√£o bater com o badge do Refil)
      const icon = (p.infuseType==="power") ? "üí™" :
                   (p.infuseType==="resist") ? "üõ°" :
                   (p.infuseType==="haste") ? "‚ö°" :
                   (p.infuseType==="regen") ? "üíö" :
                   (p.infuseType==="shield") ? "ü´ß" : "‚òÖ";

      ctx.save();
      const bx = cc.x - 34;
      const by = cc.y - 28 + bob;

      ctx.fillStyle = "rgba(0,0,0,.45)";
      rr(bx-18, by-10, 36, 20, 10); ctx.fill();

      ctx.strokeStyle = rgba(col, 0.55);
      ctx.lineWidth = 1.8;
      rr(bx-18, by-10, 36, 20, 10); ctx.stroke();

      ctx.fillStyle = rgba(col, 0.95);
      ctx.font = "700 13px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(icon, bx, by+1);

      if(p.infusePerm){
        ctx.font = "800 10px system-ui";
        ctx.fillText("‚àû", bx+12, by-6);
      }
      ctx.restore();
      ctx.lineWidth = 1;
    }

    // refil: aura de n√≠vel (quanto mais lvl, mais forte)
    if((p.upLv||0) > 0){
      
// refil: aura no alvo upado (n√≠veis bem vis√≠veis)
const upMax = REFIL_UP_MAX;
const lv = Math.max(0, Math.min(upMax, p.upLv||0));
if(lv>0){
  const pulse = 0.35 + 0.35*Math.sin(gameTime*5 + p.bob);
  // cor/for√ßa por n√≠vel
  const col = (lv===1) ? "#7CFFB2" : (lv===2 ? "#8DE1FF" : "#D7A0FF");
  const col2 = (lv===1) ? "#B9FFD9" : (lv===2 ? "#C8F4FF" : "#F0C9FF");

  // aura base (mais opaca)
  const aFill = (lv===1?0.10:lv===2?0.16:0.22) + 0.05*pulse;
  ctx.fillStyle = rgba(col, aFill);
  ctx.beginPath();
  ctx.arc(cc.x, cc.y+bob, 54, 0, Math.PI*2);
  ctx.fill();

  // m√∫ltiplos an√©is para diferenciar n√≠veis
  ctx.lineWidth = 2.5;
  ctx.strokeStyle = rgba(col2, (lv===1?0.22:lv===2?0.32:0.42) + 0.10*pulse);
  ctx.beginPath();
  ctx.arc(cc.x, cc.y+bob, 50, 0, Math.PI*2);
  ctx.stroke();

  if(lv>=2){
    ctx.strokeStyle = rgba("#FFFFFF", 0.10 + 0.10*pulse);
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(cc.x, cc.y+bob, 44, 0, Math.PI*2);
    ctx.stroke();
  }
  if(lv>=3){
    // fa√≠scas orbitando
    const n = 6;
    for(let i=0;i<n;i++){
      const aa = (p.bob||0) + visualTime*2.6 + i*(Math.PI*2/n);
      const rx = Math.cos(aa)*30;
      const ry = Math.sin(aa)*18;
      ctx.fillStyle = rgba(col2, 0.35 + 0.25*pulse);
      ctx.beginPath();
      ctx.arc(cc.x+rx, cc.y+bob+ry, 2.6, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // badge de n√≠vel (1/3, 2/3, 3/3)
  ctx.save();
  const bx = cc.x + 34;
  const by = cc.y - 28 + bob;
  ctx.fillStyle = "rgba(0,0,0,.45)";
  rr(bx-18, by-10, 36, 20, 10); ctx.fill();
  ctx.strokeStyle = rgba(col2, 0.55);
  ctx.lineWidth = 1.5;
  rr(bx-18, by-10, 36, 20, 10); ctx.stroke();
  ctx.fillStyle = "rgba(238,242,255,.92)";
  ctx.font = "1000 12px system-ui,Segoe UI,Roboto,Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(`${lv}/${upMax}`, bx, by);
  ctx.restore();
}
}

    // refil pendurado (2s): indicador em cima do frasco
    if((p.pendingRefilT||0) > 0){
      const t = clamp((p.pendingRefilT||0)/2.0, 0, 1);
      ctx.fillStyle = `rgba(0,0,0,${0.18 + 0.18*(1-t)})`;
      rr(cc.x-18, cc.y-68+bob, 36, 22, 10); ctx.fill();
      ctx.fillStyle = `rgba(238,242,255,${0.90})`;
      ctx.font = "1000 14px system-ui,Segoe UI,Roboto,Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("‚ôªÔ∏è", cc.x, cc.y-57+bob);
      ctx.textAlign = "left";
      ctx.textBaseline = "alphabetic";
    }

    // escudo de espuma (visual)
    if((p.shieldHp||0) > 0 && (p.shieldT||0) > 0){
      const cap = (p.shieldCap||120);
      const sp = Math.max(0, Math.min(1, (p.shieldHp||0) / cap));
      ctx.strokeStyle = rgba("#8DE1FF", 0.18 + 0.50*sp);
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(cc.x, cc.y+bob, 44, 0, Math.PI*2);
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    const label = (p.def.id==="customPerfume")
      ? (String(progress?.customPerfume?.label || "CUSTOM").toUpperCase().slice(0,6))
      :
      p.def.kind==="wall" ? "GUARD" :
      p.def.kind==="sun" ? "AROMA" :
      p.def.kind==="slow" ? "MINT" :
      p.def.kind==="bomb" ? "BOOM" :
      p.def.kind==="beam" ? "BEAM" :
      p.def.kind==="healer" ? "HEAL" :
      p.def.kind==="lens" ? "PRISM" :
      p.def.kind==="trap" ? "TRAP" :
      p.def.kind==="booster" ? "BOOST" :
      p.def.kind==="cleanser" ? "CLEAN" : "SPRAY";

    drawBottle(cc.x, cc.y+bob, p.def, label, shake, (p.flashT>0?{t:p.flashT,color:p.flashColor||p.def.tint}:null));

    // trap arming visual (Coffee Armadilha)
    if(p.def.kind==="trap" && (p.def.armTime||0)>0 && !p.armed){
      const t = clamp((p.armT||0) / p.def.armTime, 0, 1);
      const pulse = 0.35 + 0.35*Math.sin(gameTime*6);
      ctx.strokeStyle = rgba("#FFD36A", 0.22 + 0.45*pulse);
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(cc.x, cc.y+bob, 40, -Math.PI/2, -Math.PI/2 + 2*Math.PI*t);
      ctx.stroke();
      ctx.lineWidth = 1;

      ctx.fillStyle = "rgba(0,0,0,.26)";
      ctx.beginPath();
      ctx.arc(cc.x, cc.y+bob, 28, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "rgba(238,242,255,.90)";
      ctx.font = "900 10px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ARMANDO", cc.x, cc.y+bob);
      ctx.textAlign = "left";
      ctx.textBaseline = "alphabetic";
    }


    if(p.def.kind==="bomb"){
      const t = clamp(p.tFuse / p.def.fuse, 0, 1);
      ctx.strokeStyle = `rgba(255,106,106,${0.25+0.55*t})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(cc.x, cc.y+bob, 40, 0, Math.PI*2);
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    // bateria (Purificador)
    if(p.def.kind==="beam"){
      const b = clamp((p.battery||0), 0, 1);
      ctx.fillStyle = "rgba(0,0,0,.32)";
      rr(cc.x-24, cc.y+31, 48, 5, 4); ctx.fill();
      ctx.fillStyle = rgba((p.def.projTint||p.def.tint||"#9FFFD8"), 0.92);
      rr(cc.x-24, cc.y+31, 48*b, 5, 4); ctx.fill();
    }

    // charge shot (barra de carga)
    if(p.def.kind==="charge"){
      const ct = (p.def.chargeTime!=null ? p.def.chargeTime : 1.8);
      const t = clamp((p.chargeReady ? 1 : ((p.chargeT||0)/Math.max(0.01, ct))), 0, 1);
      ctx.fillStyle = "rgba(0,0,0,.32)";
      rr(cc.x-24, cc.y+31, 48, 5, 4); ctx.fill();
      const col = (p.def.projTint||p.def.tint||"#FFD36A");
      ctx.fillStyle = rgba(col, 0.92);
      rr(cc.x-24, cc.y+31, 48*t, 5, 4); ctx.fill();
      if(p.chargeReady){
        ctx.strokeStyle = rgba(col, 0.85);
        ctx.lineWidth = 2;
        rr(cc.x-25, cc.y+30, 50, 7, 4); ctx.stroke();
        ctx.lineWidth = 1;
      }
    }

    // hp bar
    ctx.fillStyle = "rgba(0,0,0,.40)";
    rr(cc.x-24, cc.y+40, 48, 8, 5); ctx.fill();
    ctx.fillStyle = hpPct>0.5 ? "rgba(124,255,178,.95)" : (hpPct>0.25 ? "rgba(255,211,106,.95)" : "rgba(255,106,106,.95)");
    rr(cc.x-24, cc.y+40, 48*hpPct, 8, 5); ctx.fill();
  }

  function drawEnemy(e){
    const wob = Math.sin(gameTime*3 + e.wob) * 1.8;
    const s = e.def.size;
    const coreR = 18 * s;
    const t = visualTime;

    ctx.fillStyle = "rgba(0,0,0,.22)";
    ctx.beginPath();
    ctx.ellipse(e.x, e.y+26, 22*s, 8*s, 0, 0, Math.PI*2);
    ctx.fill();

    const tint = e.def.tint;
    const baseA = (e.def.key==="boss1" || e.def.key==="boss2") ? 0.88 : 0.80;
    ctx.fillStyle = rgba(tint, baseA);

    const blobs = e.def.key==="dense" ? 9 : (e.def.key==="fast" ? 5 : 6);
    for(let i=0;i<blobs;i++){
      const a = e.wob + i*0.8;
      const rx = Math.cos(a*1.7)*(10*s);
      const ry = Math.sin(a*1.3)*(8*s);
      const r = (15 + ((i%2)*3)) * s;
      ctx.beginPath();
      ctx.arc(e.x+rx, e.y+wob+ry, r, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.fillStyle = rgba(tint, 0.93);
    ctx.beginPath();
    ctx.arc(e.x, e.y+wob, coreR, 0, Math.PI*2);
    ctx.fill();

    // gelo (Egeo Mint): overlay quando slow/frost ativo
    if((e.frostT||0) > 0){
      const a = clamp((e.frostT||0)/3.0, 0, 1);
      // leve desatura√ß√£o + brilho gelado
      ctx.fillStyle = `rgba(169,182,255,${0.10 + 0.10*a})`;
      ctx.beginPath();
      ctx.arc(e.x, e.y+wob, 32*s, 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = `rgba(255,255,255,${0.10 + 0.10*a})`;
      ctx.beginPath();
      ctx.arc(e.x, e.y+wob, 30*s, 0, Math.PI*2);
      ctx.stroke();

      // flocos
      for(let i=0;i<MAX_LOADOUT;i++){
        const aa = i*1.2 + e.frostSeed + visualTime*1.1;
        const rx = Math.cos(aa)* (18*s);
        const ry = Math.sin(aa*1.3)* (12*s);
        ctx.fillStyle = `rgba(159,255,216,${0.06 + 0.10*a})`;
        ctx.beginPath();
        ctx.arc(e.x+rx, e.y+wob+ry, 2.2*s, 0, Math.PI*2);
        ctx.fill();
      }
    }


    // sal (Kaiak Sal): part√≠culas de sal caindo
    if((e.saltT||0) > 0){
      const a = clamp((e.saltT||0)/4.0, 0, 1);

      // halo leve
      ctx.strokeStyle = `rgba(183,242,255,${0.10 + 0.10*a})`;
      ctx.beginPath();
      ctx.arc(e.x, e.y+wob, 30*s, 0, Math.PI*2);
      ctx.stroke();

      const n = 12;
      for(let i=0;i<n;i++){
        const seed = (e.saltSeed||0) + i*0.71;
        const ph = fract(t*(1.25 + 0.15*Math.sin(seed*2.0)) + i*0.17);
        const rx = Math.cos(seed*1.9 + t*0.6) * (20*s) + Math.sin(seed*3.1)*6*s;
        const ry = (-34*s) + ph*(84*s);
        const x = e.x + rx;
        const y = e.y + wob + ry;
        const r = (1.1 + 0.9*fract(seed*7.3)) * s;
        const alpha = (0.10 + 0.22*a) * (1.0 - ph) * 0.95;
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fill();

        // brilho frio suave
        if(i%4===0){
          ctx.fillStyle = `rgba(183,242,255,${0.08 + 0.10*a})`;
          ctx.beginPath();
          ctx.arc(x+2.0*s, y-2.0*s, r*0.65, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    // resina (Ekos Resina): brilho pegajoso + pingos
    if((e.resinT||0) > 0){
      const a = clamp((e.resinT||0)/6.0, 0, 1);

      ctx.fillStyle = `rgba(255,179,106,${0.06 + 0.10*a})`;
      ctx.beginPath();
      ctx.arc(e.x, e.y+wob, 32*s, 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = `rgba(255,211,106,${0.08 + 0.12*a})`;
      ctx.beginPath();
      ctx.arc(e.x, e.y+wob, 30*s, 0, Math.PI*2);
      ctx.stroke();

      // fios / pingos
      const n = 6;
      ctx.lineWidth = 2*s;
      for(let i=0;i<n;i++){
        const seed = (e.resinSeed||0) + i*1.13;
        const ang = seed + Math.sin(t*0.7 + seed)*0.25;
        const x0 = e.x + Math.cos(ang) * (18*s);
        const y0 = e.y + wob - 16*s + Math.sin(seed*3.2)*3*s;
        const ph = fract(t*0.55 + i*0.21 + seed*0.13);
        const len = (16 + 30*ph) * s;

        ctx.strokeStyle = `rgba(255,179,106,${0.12 + 0.16*a})`;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x0 + Math.sin(seed*2.4)*2*s, y0 + len);
        ctx.stroke();

        ctx.fillStyle = `rgba(255,140,70,${0.16 + 0.18*a})`;
        ctx.beginPath();
        ctx.arc(x0, y0 + len, 2.8*s, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.lineWidth = 1;
    }
    
// burn (Quasar Fire): fogo vis√≠vel (l√≠nguas de chama + brasas)
if((e.burnT||0) > 0){
  const a = clamp((e.burnT||0)/4.0, 0, 1);
  const pulse = 0.35 + 0.35*Math.sin(visualTime*10 + (e.burnSeed||0));

  // halo quente
  ctx.fillStyle = `rgba(255,106,61,${0.08 + 0.16*a + 0.10*pulse})`;
  ctx.beginPath();
  ctx.arc(e.x, e.y+wob, 38*s, 0, Math.PI*2);
  ctx.fill();

  // anel externo
  ctx.strokeStyle = `rgba(255,211,106,${0.16 + 0.26*a})`;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(e.x, e.y+wob, 36*s, 0, Math.PI*2);
  ctx.stroke();

  // l√≠nguas de chama (teardrops subindo)
  const flames = 5;
  for(let i=0;i<flames;i++){
    const seed = (e.burnSeed||0) + i*1.77;
    const ang = seed + visualTime*1.3;
    const fx = e.x + Math.cos(ang)*(18*s);
    const fy = e.y + wob - 10*s + Math.sin(ang*1.1)*(10*s);
    const h  = (18 + 10*pulse + 8*Math.sin(seed*3 + visualTime*2.2)) * s;
    const w  = (8 + 4*pulse) * s;

    ctx.save();
    ctx.translate(fx, fy);
    ctx.rotate(Math.sin(seed + visualTime*1.8)*0.12);
    ctx.beginPath();
    ctx.moveTo(0, -h);
    ctx.quadraticCurveTo(w, -h*0.35, 0, 0);
    ctx.quadraticCurveTo(-w, -h*0.35, 0, -h);
    ctx.closePath();
    ctx.fillStyle = `rgba(255,211,106,${0.20 + 0.26*a})`;
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(0, -h*0.78);
    ctx.quadraticCurveTo(w*0.65, -h*0.30, 0, 0);
    ctx.quadraticCurveTo(-w*0.65, -h*0.30, 0, -h*0.78);
    ctx.closePath();
    ctx.fillStyle = `rgba(255,106,61,${0.22 + 0.30*a})`;
    ctx.fill();
    ctx.restore();
  }

  // brasas orbitando
  const n = 7;
  for(let i=0;i<n;i++){
    const seed = (e.burnSeed||0) + i*1.37;
    const aa = seed + visualTime*2.0;
    const rx = Math.cos(aa)* (22*s);
    const ry = Math.sin(aa*1.25)* (14*s);
    ctx.fillStyle = `rgba(255,211,106,${0.18 + 0.28*a})`;
    ctx.beginPath();
    ctx.arc(e.x+rx, e.y+wob+ry, (2.2+1.4*pulse)*s, 0, Math.PI*2);
    ctx.fill();
  }

  ctx.lineWidth = 1;
}


    // purified ring
    if(e.purifiedT > 0){
      ctx.strokeStyle = "rgba(159,255,216,.72)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(e.x, e.y+wob, 28*s, 0, Math.PI*2);
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.font = `${1000} ${Math.round(14*s)}px system-ui,Segoe UI,Roboto,Arial`;
    ctx.fillText(e.def.glyph, e.x - ctx.measureText(e.def.glyph).width/2, e.y + 6*wob/2);

    // hp bar
    const hpPct = clamp(e.hp/e.maxHp,0,1);
    ctx.fillStyle = "rgba(0,0,0,.36)";
    rr(e.x-26*s, e.y-40*s+wob, 52*s, 8, 5); ctx.fill();
    ctx.fillStyle = hpPct>0.5 ? "rgba(124,255,178,.95)" : (hpPct>0.25 ? "rgba(255,211,106,.95)" : "rgba(255,106,106,.95)");
    rr(e.x-26*s, e.y-40*s+wob, 52*s*hpPct, 8, 5); ctx.fill();

    // boss2: barra de escudo (vida extra)
    if(e.def.key==="boss2" && (e.shieldMax||0) > 0){
      const v = clamp((e.shieldHp||0)/(e.shieldMax||1), 0, 1);
      if(v > 0){
        const totalW = 150;
        const x0 = e.x - totalW/2;
        const y0 = e.y-62*s + wob;

        ctx.fillStyle = "rgba(0,0,0,.36)";
        rr(x0, y0, totalW, 10, 6); ctx.fill();

        ctx.fillStyle = rgba("#A9B6FF", 0.88);
        rr(x0+1, y0+1, (totalW-2)*v, 8, 6); ctx.fill();
      }
    }
  }

  function drawMower(m){
    if(!m.active) return;
    ctx.fillStyle = "rgba(255,211,106,.92)";
    rr(m.x-18, m.y-16, 36, 32, 12);
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.16)";
    ctx.stroke();
    ctx.fillStyle = "rgba(0,0,0,.42)";
    ctx.font = "1000 14px system-ui,Segoe UI,Roboto,Arial";
    ctx.fillText("‚ú¶", m.x-5, m.y+6);
  }


  function drawCoins(){
    for(const c of coins){
      if(c.collected) continue;
      const pulse = 0.6 + 0.4*Math.sin(gameTime*3 + c.bob);

      ctx.beginPath();
      ctx.fillStyle = `rgba(255,211,106,${0.62 + 0.24*pulse})`;
      ctx.arc(c.x, c.y, COIN_R, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,.26)";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.lineWidth = 1;

      ctx.fillStyle = "rgba(0,0,0,.28)";
      ctx.beginPath();
      ctx.arc(c.x+2, c.y+2, COIN_R-6, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "1000 14px system-ui,Segoe UI,Roboto,Arial";
      ctx.fillText("ü™ô", c.x-8, c.y+6);

      if((c.value||1) > 1){
        ctx.fillStyle = "rgba(255,255,255,.88)";
        ctx.font = "1000 12px system-ui,Segoe UI,Roboto,Arial";
        ctx.fillText(String(c.value), c.x+8, c.y-10);
      }
    }
  }

  function drawOrbs(){
    for(const s of aromas){
      if(s.collected) continue;
      const def = AromaTypes[s.typeId] || AromaTypes.gold;
      const pulse = 0.6 + 0.4*Math.sin(gameTime*3 + s.bob);

      ctx.beginPath();
      ctx.fillStyle = rgba(def.tint, 0.60 + 0.28*pulse);
      ctx.arc(s.x, s.y, ORB_R, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,.24)";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.lineWidth = 1;

      ctx.fillStyle = "rgba(255,255,255,.18)";
      ctx.beginPath();
      ctx.arc(s.x-8, s.y-8, 6, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.font = "1000 14px system-ui,Segoe UI,Roboto,Arial";
      ctx.fillText(def.icon, s.x-6, s.y+6);
    }
  }

  function drawProjectiles(){
    const t = visualTime;
    for(const pr of projectiles){
      // ===== catalisado (Zaad Catalisador): brilho dourado + fa√≠scas =====
      if(pr.fromCata){
        const a = 0.16 + 0.10*Math.sin(t*10 + (pr.seed||0));
        ctx.fillStyle = `rgba(255,211,106,${a})`;
        ctx.beginPath();
        ctx.arc(pr.x-6, pr.y, pr.r+6, 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = `rgba(255,211,106,${0.26 + 0.10*Math.sin(t*8 + (pr.seed||0))})`;
        ctx.lineWidth = 2;
        for(let i=0;i<3;i++){
          const aa = (pr.seed||0) + i*2.1 + t*7.0;
          const lx = pr.x + Math.cos(aa) * (pr.r+6);
          const ly = pr.y + Math.sin(aa) * (pr.r+6);
          const lx2 = pr.x + Math.cos(aa) * (pr.r+12);
          const ly2 = pr.y + Math.sin(aa) * (pr.r+12);
          ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx2, ly2); ctx.stroke();
        }
        ctx.lineWidth = 1;
      }

      // ===== sal (Kaiak Sal): brilhinhos ‚Äúgranulados‚Äù =====
      if(pr.salt){
        for(let i=0;i<2;i++){
          const aa = (pr.seed||0)*3 + i*1.7 + t*12.0;
          const rx = Math.cos(aa) * (pr.r+6);
          const ry = Math.sin(aa*1.15) * (pr.r+4);
          ctx.fillStyle = `rgba(255,255,255,${0.22})`;
          ctx.beginPath();
          ctx.arc(pr.x+rx, pr.y+ry, 1.6, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = `rgba(183,242,255,${0.10})`;
          ctx.beginPath();
          ctx.arc(pr.x+rx+1.6, pr.y+ry-1.2, 1.0, 0, Math.PI*2);
          ctx.fill();
        }
      }

      // ===== resina (Ekos Resina): cauda viscosa =====
      if(pr.resin){
        const wob = 0.5 + 0.5*Math.sin(t*9.0 + (pr.seed||0)*2.0);
        ctx.fillStyle = `rgba(255,179,106,${0.16 + 0.12*wob})`;
        ctx.beginPath();
        ctx.ellipse(pr.x-10, pr.y, pr.r+6, pr.r+2, 0, 0, Math.PI*2);
        ctx.fill();
      }

      // n√∫cleo do proj√©til
      ctx.beginPath();
      ctx.fillStyle = pr.tint;
      ctx.arc(pr.x, pr.y, pr.r, 0, Math.PI*2);
      ctx.fill();

      // contorno (dourado se catalisado)
      ctx.strokeStyle = pr.fromCata ? "rgba(255,211,106,.26)" : "rgba(255,255,255,.14)";
      ctx.stroke();

      // aro extra suave
      if(pr.fromCata){
        ctx.strokeStyle = "rgba(255,255,255,.10)";
        ctx.beginPath();
        ctx.arc(pr.x, pr.y, pr.r+2, 0, Math.PI*2);
        ctx.stroke();
      }
    }
  }

  function drawParticles(){
    for(const p of particles){
      ctx.beginPath();
      ctx.fillStyle = rgba(p.tint, p.a);
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawRings(){
    for(const r of rings){
      ctx.strokeStyle = rgba(r.tint, r.a);
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
      ctx.stroke();
      ctx.lineWidth = 1;
    }
  }

  function drawBeams(){
    for(const b of beams){
      const col = b.col || "#9FFFD8";
      ctx.strokeStyle = rgba(col, (0.18 + 0.26*b.a));
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(b.x1, b.y1);
      ctx.lineTo(b.x2, b.y2);
      ctx.stroke();

      ctx.strokeStyle = `rgba(255,255,255,${0.08 + 0.18*b.a})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(b.x1, b.y1);
      ctx.lineTo(b.x2, b.y2);
      ctx.stroke();

      ctx.lineWidth = 1;
    }
  }

  function drawHover(){
    if(!hoverCell || won || lost) return;
    if(!selectedId) return;
    let def = plantById.get(selectedId);
    if(mode==="playing" && selectedId==="customPerfume" && matchCustomPerfumeDef) def = matchCustomPerfumeDef;
    if(!def || def.kind==="tool") return;

    const locked = (cellLocks[hoverCell.row][hoverCell.col] > 0);
    const occupied = !!plants[hoverCell.row][hoverCell.col];
    const ok = !locked && ((def.kind==="refil" || def.kind==="infuse") ? occupied : !occupied);

    const cc = cellCenter(hoverCell.row, hoverCell.col);
    ctx.save();
    ctx.globalAlpha = ok ? 0.28 : 0.14;
    drawBottle(cc.x, cc.y, def, "----", 0, null);
    ctx.restore();

    ctx.strokeStyle = ok ? "rgba(255,211,106,.55)" : "rgba(255,106,106,.60)";
    ctx.lineWidth = 2;
    rr(GRID_X + hoverCell.col*CELL_W + 4, GRID_Y + hoverCell.row*CELL_H + 4, CELL_W-8, CELL_H-8, 16);
    ctx.stroke();

    if(locked){
      ctx.fillStyle = "rgba(255,106,106,.85)";
      ctx.font = "1000 16px system-ui,Segoe UI,Roboto,Arial";
      ctx.textAlign = "center";
      ctx.fillText("‚õî", cc.x, cc.y+6);
    }

    ctx.lineWidth = 1;
  }

  function drawPrepHint(){
    if(paused || won || lost || !currentWorld) return;

    if(isPreparation()){
      const left = Math.max(0, currentWorld.prepTime - gameTime);
      ctx.fillStyle = "rgba(0,0,0,.36)";
      rr(GRID_X, GRID_Y+GRID_H+14, GRID_W, 42, 14);
      ctx.fill();
      ctx.fillStyle = "rgba(238,242,255,.90)";
      ctx.font = "1000 16px system-ui,Segoe UI,Roboto,Arial";
      ctx.fillText(`Prepara√ß√£o: ${left.toFixed(0)}s ‚Äî colete e plante`, GRID_X+12, GRID_Y+GRID_H+42);
    }else{
      const introEnd = currentWorld.prepTime + (currentWorld.introDelay||0);
      if(gameTime < introEnd){
        const left = Math.max(0, introEnd - gameTime);
        ctx.fillStyle = "rgba(0,0,0,.32)";
        rr(GRID_X, GRID_Y+GRID_H+14, GRID_W, 42, 14);
        ctx.fill();
        ctx.fillStyle = "rgba(238,242,255,.86)";
        ctx.font = "1000 16px system-ui,Segoe UI,Roboto,Arial";
        ctx.fillText(`Respira‚Ä¶ a primeira leva chega em ${left.toFixed(0)}s`, GRID_X+12, GRID_Y+GRID_H+42);
      }
    }
  }

  function drawAlert(){
    const cur = currentAlert();
    if(!cur || paused || won || lost) return;

    const { a, p } = cur;
    const inT = Math.min(1, p / 0.18);
    const outT = Math.min(1, Math.max(0, (p - 0.78) / 0.22));
    const alpha = clamp(inT * (1-outT), 0, 1);

    const shake = (Math.sin(gameTime*28) + Math.sin(gameTime*17))*2.2;
    const scale = 1.0 + 0.14*(1-inT) + 0.04*Math.sin(gameTime*10);

    ctx.save();
    ctx.globalAlpha = 0.30 * alpha;
    ctx.fillStyle = "rgba(0,0,0,.85)";
    ctx.fillRect(0,0,BASE_W,BASE_H);
    ctx.restore();

    ctx.save();
    ctx.translate(BASE_W/2 + shake, BASE_H/2 - 30);
    ctx.scale(scale, scale);

    const tint = (a.kind==="bad") ? "#FF6A6A" : "#FFD36A";

    ctx.fillStyle = rgba(tint, 0.22 * alpha);
    rr(-260, -60, 520, 120, 22); ctx.fill();
    ctx.strokeStyle = rgba(tint, 0.55 * alpha);
    ctx.lineWidth = 3;
    rr(-260, -60, 520, 120, 22); ctx.stroke();
    ctx.lineWidth = 1;

    ctx.fillStyle = rgba("#ffffff", 0.92 * alpha);
    ctx.font = "1000 44px system-ui,Segoe UI,Roboto,Arial";
    const w = ctx.measureText(a.text).width;
    ctx.fillText(a.text, -w/2, 16);

    ctx.restore();
  }

  function drawEndOverlay(){
    if(!won && !lost) return;
    ctx.fillStyle = "rgba(0,0,0,.62)";
    ctx.fillRect(0,0,BASE_W,BASE_H);

    const msg = won ? "VIT√ìRIA!" : "DERROTA!";
    const sub = won ? "A vitrine ficou cheirosa üòå‚ú®" : "O mal cheiro invadiu‚Ä¶ üòµ";
    ctx.fillStyle = won ? "rgba(124,255,178,.95)" : "rgba(255,106,106,.95)";
    ctx.font = "1000 56px system-ui,Segoe UI,Roboto,Arial";
    ctx.fillText(msg, (BASE_W-ctx.measureText(msg).width)/2, BASE_H/2 - 18);

    ctx.fillStyle = "rgba(238,242,255,.90)";
    ctx.font = "900 18px system-ui,Segoe UI,Roboto,Arial";
    ctx.fillText(sub, (BASE_W-ctx.measureText(sub).width)/2, BASE_H/2 + 18);

    ctx.fillStyle = "rgba(238,242,255,.70)";
    ctx.font = "900 14px system-ui,Segoe UI,Roboto,Arial";
    const tip = "Pressione M para voltar ao mapa.";
    ctx.fillText(tip, (BASE_W-ctx.measureText(tip).width)/2, BASE_H/2 + 46);
  }

  function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    drawBackground();

    for(const m of mowers) drawMower(m);

    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const p = plants[r][c];
        if(p) drawPlant(p);
      }
    }

    drawCoins();
    drawOrbs();
    drawProjectiles();
    drawBeams();

    for(const e of enemies) if(e.alive) drawEnemy(e);

    drawRings();
    drawParticles();
    drawHover();
    drawPrepHint();
    drawAlert();

    // flash sutil de tela
    if(screenFlashT > 0){
      const a = Math.min(0.22, screenFlashT*0.22);
      ctx.fillStyle = rgba(screenFlashColor, a);
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    drawEndOverlay();
  }

  // ================= Gameplay update =================
  function update(dt){
    if(!running || paused || won || lost || !currentWorld) return;

    gameTime += dt;

    // tela: flash sutil
    if(screenFlashT > 0) screenFlashT = Math.max(0, screenFlashT - dt);

    // survival: estender o plano conforme o tempo passa
    if(currentWorld && currentWorld.survival){
      extendSurvivalPlanIfNeeded(currentWorld);
    }

    beams.length = 0;

    // tocar sons de alertas (3,2,1,Perfumar! / √öltima Horda)
    for(const a of alerts){
      if(!a.played && gameTime >= a.t){
        a.played = true;
        if(a.sfx) SFX.play(a.sfx);
      }
    }

    // global buffs
    globalBuffs.enemySlowAllT = Math.max(0, globalBuffs.enemySlowAllT - dt);
    globalBuffs.beamBoostT = Math.max(0, globalBuffs.beamBoostT - dt);

    // cooldown
    for(const id of cooldowns.keys()){
      const rem = cooldowns.get(id);
      const n = Math.max(0, rem - dt);
      if(n<=0) cooldowns.delete(id);
      else cooldowns.set(id,n);
    }

    // cellLocks (cratera / tile indispon√≠vel)
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(cellLocks[r][c] > 0) cellLocks[r][c] = Math.max(0, cellLocks[r][c] - dt);
      }
    }

    // spawn enemies (throttle por cap)
    const cap = maxEnemiesForWorld(currentWorld.id);
    while(spawnQueue.length && spawnQueue[0].t <= gameTime){
      if(enemies.length >= cap){
        spawnQueue[0].t += 1.1;
        break;
      }
      const ev = spawnQueue.shift();
      spawnEnemy(ev.row, ev.type);
    }

    // sky aroma spawn
    nextSkyAroma -= dt;
    if(nextSkyAroma <= 0){
      const x = rand(GRID_X+30, GRID_X+GRID_W-30);
      const y = rand(GRID_Y+20, GRID_Y+GRID_H-20);

      const types = (currentWorld.skyAroma && currentWorld.skyAroma.types) ? currentWorld.skyAroma.types : ["gold"];
      const typeId = pickAromaType(types);
      const did = trySpawnAromaOrb(x, y, typeId, true);

      if(!did){
        nextSkyAroma = 1.4;
      }else{
        const min = isPreparation() ? currentWorld.skyAroma.prepMin : currentWorld.skyAroma.gameMin;
        const max = isPreparation() ? currentWorld.skyAroma.prepMax : currentWorld.skyAroma.gameMax;
        nextSkyAroma = rand(min,max) * (0.95 + 0.05*WAVE_TIME_SCALE);
      }
    }

    // plants tick
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const p = plants[r][c];
        if(!p) continue;

        // timers
        p.buffT = Math.max(0, p.buffT - dt);
        p.stickyT = Math.max(0, p.stickyT - dt);
        p.cataT = Math.max(0, (p.cataT||0) - dt);
        p.flashT = Math.max(0, (p.flashT||0) - dt);

        
        // anti-exploit: pequeno lock para evitar spam de Infuse (12.8)
        p.infuseApplyCd = Math.max(0, (p.infuseApplyCd||0) - dt);
// Infuse tick (12.2/12.3)
        if((p.infuseT||0) > 0){
          if(!p.infusePerm) p.infuseT = Math.max(0, p.infuseT - dt);
          if(p.infuseT <= 0){
            p.infuseT = 0;
            p.infusePerm = false;
            p.infuseType = null;
            p.infusePowerMul = 1.0;
            p.infuseResistMul = 1.0;
            p.infuseHasteMul = 1.0;
            p.infuseRegenFrac = 0.0;
            p.infuseCol = null;
            p.infuseShieldHp = 0;
            p.infuseShieldCap = 0;
            p.infuseShieldRegen = 0.0;
            p.infuseTMax = 0;
          }
        }

        
        // Infuse: Recover HP (12.5)
        if((p.infuseT||0) > 0 && p.infuseType==="regen"){
          const frac = (p.infuseRegenFrac||0);
          if(frac > 0 && p.hp < p.maxHp){
            p.hp = Math.min(p.maxHp, p.hp + p.maxHp*frac*dt);
          }
        }
        // Infuse: Escudo (12.6)
        if((p.infuseT||0) > 0 && p.infuseType==="shield"){
          const cap = (p.infuseShieldCap||0);
          if(cap > 0){
            const rg = (p.infuseShieldRegen||0);
            if(rg > 0 && (p.infuseShieldHp||0) < cap){
              p.infuseShieldHp = Math.min(cap, (p.infuseShieldHp||0) + rg*dt);
            }
          }else if((p.infuseShieldHp||0) > 0){
            p.infuseShieldCap = p.infuseShieldHp;
          }
        }

// escudo de espuma (Nativa Clean)
        if((p.shieldT||0) > 0){
          p.shieldT = Math.max(0, p.shieldT - dt);
          if(p.shieldT <= 0){
            p.shieldT = 0;
            p.shieldHp = 0;
          }
        }

        // poison tick
        if(p.poisonT > 0){
          p.poisonT -= dt;
          p.hp -= p.poisonDps * dt;
          if(p.poisonT <= 0){
            p.poisonT = 0;
            p.poisonDps = 0;
          }
        }

        // refil pendurado (2s) -> aplica upgrade ao finalizar
        if((p.pendingRefilT||0) > 0){
          p.pendingRefilT = Math.max(0, p.pendingRefilT - dt);
          if(p.pendingRefilT<=0){
            const ok = applyRefilToPlant(p, p.pendingRefilDef);
            p.pendingRefilDef = null;
            if(ok){
              const cc = cellCenter(r,c);
              ring(cc.x, cc.y, "#7CFFB2", 10, 76, 0.36);
              puff(cc.x, cc.y-8, "#7CFFB2", 16);
              SFX.play("buff");
            }else{
              SFX.play("ui");
            }
          }
        }

        // sun
        if(p.def.kind==="sun"){
          p.tGen += dt;
          const genRate = p.def.genRate * (1/(p.infuseHasteMul||1.0));
          if(p.tGen >= genRate){
            p.tGen = 0;
            const cc = cellCenter(r,c);

            const n = Math.max(1, Math.floor(p.def.twin||1));
            let any = false;
            for(let i=0;i<n;i++){
              const ox = rand(-14,14) + (i-(n-1)/2)*10;
              const oy = -24 + rand(-2,2);
              const did = trySpawnAromaOrb(cc.x + ox, cc.y + oy, "gold", false);
              any = any || did;
            }

            if(any){
              puff(cc.x, cc.y-10, "#7CFFB2", 10);
              ring(cc.x, cc.y-10, "#7CFFB2", 6, 36, 0.32);
            }
          }
        }

        // healer
        if(p.def.kind==="healer"){
          p.tHeal += dt;
          const healRate = p.def.healRate * (1/(p.infuseHasteMul||1.0));
          if(p.tHeal >= healRate){
            p.tHeal = 0;
            const neigh = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
            let did = false;
            for(const [rrr,ccc] of neigh){
              if(rrr<0||rrr>=ROWS||ccc<0||ccc>=COLS) continue;
              const q = plants[rrr][ccc];
              if(!q) continue;
              const before = q.hp;
              q.hp = Math.min(q.maxHp, q.hp + p.def.healAmount * (p.infusePowerMul||1.0));
              if(q.hp > before){
                did = true;
                // pisca verde claro quando recebe cura do Botik Breeze
                q.flashColor = "#B9FFD9";
                q.flashT = Math.max(q.flashT||0, 0.22);
                const qc = cellCenter(rrr, ccc);
                ring(qc.x, qc.y, "#B9FFD9", 6, 34, 0.20);
              }
            }
            if(did){
              SFX.play("heal");
              const cc = cellCenter(r,c);
              puff(cc.x, cc.y-10, "#7CFFB2", 12);
              ring(cc.x, cc.y-10, "#7CFFB2", 6, 44, 0.34);
            }
          }
        }


        // booster (buff adjacentes)
        if(p.def.kind==="booster"){
          p.tPulse += dt;
          if(p.tPulse >= p.def.pulse){
            p.tPulse = 0;
            let any = false;
            const neigh = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
            for(const [rrr,ccc] of neigh){
              if(rrr<0||rrr>=ROWS||ccc<0||ccc>=COLS) continue;
              const q = plants[rrr][ccc];
              if(!q) continue;
              any = true;
              if(p.def.id==="zaadCat"){
                q.cataT = Math.max((q.cataT||0), p.def.cataTime || 4.0);
                // pisca dourado quando recebe catalisa√ß√£o
                q.flashColor = "#FFD36A";
                q.flashT = Math.max(q.flashT||0, 0.20);
                const qc = cellCenter(rrr, ccc);
                ring(qc.x, qc.y, "#FFD36A", 8, 40, 0.22);
              } else {
                q.buffT = Math.max(q.buffT, p.def.buffTime);
                // pisca verde escuro quando recebe buff do Arbo Booster
                q.flashColor = "#1F8F52";
                q.flashT = Math.max(q.flashT||0, 0.20);
                const qc = cellCenter(rrr, ccc);
                ring(qc.x, qc.y, "#1F8F52", 8, 40, 0.22);
              }
            }
            const cc = cellCenter(r,c);
            ring(cc.x, cc.y, p.def.tint, 8, 56, 0.28);
            if(any) SFX.play("buff");
          }
        }

        // cleanser (Nativa Clean): limpa veneno/grude e gera escudo de espuma
        if(p.def.kind==="cleanser"){
          p.tPulse += dt;
          if(p.tPulse >= p.def.pulse){
            p.tPulse = 0;
            SFX.play("shieldUp");
            let did = false;
            // √°rea: si pr√≥prio + adjacentes
            const area = [[r,c],[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
            for(const [rrr,ccc] of area){
              if(rrr<0||rrr>=ROWS||ccc<0||ccc>=COLS) continue;
              const q = plants[rrr][ccc];
              if(!q) continue;

              const hadPoison = q.poisonT > 0;
              const hadSticky = q.stickyT > 0;
              q.poisonT = 0; q.poisonDps = 0;
              q.stickyT = 0;

              const before = q.hp;
              q.hp = Math.min(q.maxHp, q.hp + (p.def.heal||0) * (p.infusePowerMul||1.0));
              if(q.hp > before || hadPoison || hadSticky) did = true;

              // escudo de espuma (absorve dano)
              const add = (p.def.shieldAdd!=null ? p.def.shieldAdd : 55);
              const cap = (p.def.shieldCap!=null ? p.def.shieldCap : 120);
              const time = (p.def.shieldTime!=null ? p.def.shieldTime : 7.0);
              q.shieldCap = cap;
              q.shieldHp = Math.min(cap, (q.shieldHp||0) + add);
              q.shieldT = Math.max(q.shieldT||0, time);
              q.shieldPopKnock = (p.def.popKnock!=null ? p.def.popKnock : 26);
              q.shieldPopRange = (p.def.popRange!=null ? p.def.popRange : 160);
              q.shieldPopTint = "#8DE1FF";

              const qc = cellCenter(rrr, ccc);
              ring(qc.x, qc.y, "#8DE1FF", 8, 54, 0.22);
              puff(qc.x, qc.y, "#8DE1FF", 8);
            }

            if(did){
              SFX.play("heal");
              const cc = cellCenter(r,c);
              puff(cc.x, cc.y-6, "#8DE1FF", 16);
              ring(cc.x, cc.y-6, "#8DE1FF", 10, 78, 0.36);
            }
          }
        }


        // shooter / slow
        if(p.def.kind==="shooter" || p.def.kind==="slow" || p.def.kind==="homing"){
          p.tFire += dt;
          const px = cellCenter(r,c).x;
          const hasTarget = (p.def.kind==="homing")
            ? enemies.some(e => e.alive && e.x > px)
            : enemies.some(e => e.alive && e.row===r && e.x > px);
          const fireRate = p.def.fireRate * (p.buffT>0 ? 0.70 : 1.0) * (p.stickyT>0 ? 1.35 : 1.0) * (1 / (p.infuseHasteMul||1.0));
          if(hasTarget && p.tFire >= fireRate){
            p.tFire = 0;
            const cc = cellCenter(r,c);
            const fromCata = ((p.cataT||0)>0);
            const kind = (p.def.kind==="slow" ? "slow" : "normal");
            const dmgMul = plantUpMul(p) * (p.buffT>0 ? 1.15 : 1.0) * (p.infusePowerMul||1.0);
            const shots = Math.max(1, Math.min(5, (p.def.shotCount||1)));
            if(shots>1){
              const spread = 10;
              const mid = (shots-1)/2;
              for(let si=0; si<shots; si++){
                const yo = (si-mid)*spread;
                spawnProjectile(r, cc.x+16, cc.y-6 + yo, p.def, kind, p.buffT>0, {fromCata, dmgMul});
                puff(cc.x+20, cc.y-6 + yo, p.def.tint, 5);
              }
            }else{
              spawnProjectile(r, cc.x+16, cc.y-6, p.def, kind, p.buffT>0, {fromCata, dmgMul});
              puff(cc.x+20, cc.y-6, p.def.tint, 6);

              if(p.def.doubleShot && kind==="normal"){
                // segundo tiro (mesmo alvo) ‚Äî pequena varia√ß√£o visual
                spawnProjectile(r, cc.x+18, cc.y+6, p.def, "normal", p.buffT>0, {fromCata, dmgMul});
                puff(cc.x+24, cc.y+6, p.def.tint, 6);
              }
            }
}
        }

        // charge shot (carrega sozinho; clique na planta para disparar)
        if(p.def.kind==="charge"){
          const ct = (p.def.chargeTime!=null ? p.def.chargeTime : 1.8);
          if(!p.chargeReady){
            const speedMul = (p.buffT>0 ? 1.25 : 1.0) * (p.stickyT>0 ? 0.75 : 1.0) * (p.infuseHasteMul||1.0);
            p.chargeT = (p.chargeT||0) + dt * speedMul;
            if(p.chargeT >= ct){
              p.chargeT = ct;
              p.chargeReady = true;
              // feedback visual discreto de "pronto"
              const cc = cellCenter(r,c);
              ring(cc.x, cc.y-6, p.def.projTint||p.def.tint||"#FFD36A", 6, 60, 0.22);
              SFX.play("ui");
            }
          }else{
            p.chargeT = ct;
          }
        }


        // cone
        if(p.def.kind==="cone"){
          p.tFire += dt;
          const px = cellCenter(r,c).x;
          const targets = enemies.filter(e => e.alive && e.row===r && e.x > px && e.x < px + p.def.range);
          const fireRate = p.def.fireRate * (p.buffT>0 ? 0.72 : 1.0) * (p.stickyT>0 ? 1.35 : 1.0);
          if(targets.length && p.tFire >= fireRate){
            p.tFire = 0;
            SFX.play("spray");
            targets.sort((a,b)=>a.x-b.x);
            const hitN = Math.min(p.def.hits, targets.length);
            for(let i=0;i<hitN;i++){
              const dmg = p.def.dmg * plantUpMul(p) * (p.buffT>0 ? 1.15 : 1.0) * (p.infusePowerMul||1.0);
              damageEnemy(targets[i], dmg, {type:"cone", fromBuff:(p.buffT>0)});
              puff(targets[i].x, targets[i].y, p.def.tint, 8);
            }
            const cc = cellCenter(r,c);
            puff(cc.x+20, cc.y-6, p.def.tint, 12);
          }
        }        // beam (Purificador)
        if(p.def.kind==="beam"){
          // bateria recarrega em pulsos (a cada 5s: +25% | com Arbo: +40%)
          p.batPulseT = (p.batPulseT || 0) + dt;
          const pulseEvery = (p.def.batteryPulseEvery!=null ? p.def.batteryPulseEvery : 5);
          if(p.batPulseT >= pulseEvery){
            const pulses = Math.floor(p.batPulseT / pulseEvery);
            p.batPulseT -= pulses * pulseEvery;
            const amtBase  = (p.def.batteryPulseAmount!=null ? p.def.batteryPulseAmount : 0.25);
            const amtBoost = (p.def.batteryPulseAmountBoost!=null ? p.def.batteryPulseAmountBoost : 0.40);
            const amt = (p.buffT>0 ? amtBoost : amtBase);
            p.battery = Math.min(1, (p.battery||0) + pulses * amt);
          }

          const px = cellCenter(r,c).x;
          const target = enemies
            .filter(e => e.alive && e.row===r && e.x > px && e.x < px + p.def.range)
            .sort((a,b)=>a.x-b.x)[0];

          if(target){
            const cc = cellCenter(r,c);
            const beamCol = (p.def.projTint || p.def.tint || "#9FFFD8");

            // prisma na mesma linha, entre o purificador e o alvo?
            let hasPrism = false;
            let prismBoost = 1.0;
            let prismSplit = 0.45;
            for(let cc2=0; cc2<COLS; cc2++){
              const q = plants[r][cc2];
              if(!q || q.def.kind!=="lens") continue;
              const qx = cellCenter(r,cc2).x;
              if(qx > cc.x && qx < target.x){
                hasPrism = true;
                if(q.def.beamMult) prismBoost = Math.max(prismBoost, q.def.beamMult);
                if(q.def.splitMult) prismSplit = Math.max(prismSplit, q.def.splitMult);
              }
            }

            // beam principal
            beams.push({ x1: cc.x+16, y1: cc.y-6, x2: target.x-16, y2: target.y, a: 1, col: beamCol });

            // refrata para linhas vizinhas (efeito visual + dano reduzido)
            if(hasPrism){
              const up = r-1, dn = r+1;
              const findNeighbor = (row) => enemies.filter(e=>e.alive && e.row===row && e.x>cc.x && e.x < cc.x + p.def.range).sort((a,b)=>a.x-b.x)[0];
              if(up>=0){
                const t2 = findNeighbor(up);
                if(t2){
                  beams.push({ x1: cc.x+16, y1: cc.y-6, x2: t2.x-16, y2: t2.y, a: 0.8, col: beamCol });
                }
              }
              if(dn<ROWS){
                const t3 = findNeighbor(dn);
                if(t3){
                  beams.push({ x1: cc.x+16, y1: cc.y-6, x2: t3.x-16, y2: t3.y, a: 0.8, col: beamCol });
                }
              }
            }

            p.tBeam += dt;
            if(p.tBeam >= p.def.tickRate){
              p.tBeam = 0;

              SFX.play("beamTick");
              // consumo da bateria por tick
              let drainPerSec = (p.def.batteryDrain!=null ? p.def.batteryDrain : 0.030);
              // Arbo Booster reduz ainda mais o consumo
              if(p.buffT>0) drainPerSec *= 0.55;
              const drain = drainPerSec * p.def.tickRate;

              const boost = (globalBuffs.beamBoostT > 0) ? 1.25 : 1.0;
              const baseDmg = (p.def.dps * p.def.tickRate) * boost * (p.buffT>0 ? 1.12 : 1.0) * plantUpMul(p) * (p.infusePowerMul||1.0);

              // quanto menor a bateria, menor o dano
              const bat = clamp((p.battery||0), 0, 1);
              const batMult = 0.25 + 0.75*bat;
              const dmg = baseDmg * batMult * prismBoost;

              // purifica alvo (com suporte a "imune ao Purificador")
              const canBeamHit = (e) => {
                if(!e.def.purifierImmune) return true;
                const t = e.def.purifierImmuneType || "salt";
                if(t==="salt") return (e.saltT||0) > 0;
                if(t==="resin") return (e.resinT||0) > 0;
                return false;
              };

              // alvo principal
              if(canBeamHit(target)){
                if(!p.def.noPurify){
                  const wasReactive = !!target.def.requiresPurify;
                  const wasUnpurified = (target.purifiedT<=0);
                  target.purifiedT = Math.max(target.purifiedT, 6.0);

                  // AoE pequeno: quando o raio toca um mal cheiro reativo, a purifica√ß√£o respinga ao redor (ponto de impacto)
                  if(wasReactive){
                  const R = (p.def.purifyAOE!=null ? p.def.purifyAOE : 78);
                  const R2 = R*R;
                  for(const e2 of enemies){
                    if(!e2.alive) continue;
                    const dx = e2.x - target.x;
                    const dy = e2.y - target.y;
                    if(dx*dx + dy*dy <= R2){
                      e2.purifiedT = Math.max(e2.purifiedT, 3.0);
                    }
                  }
                  ring(target.x, target.y, beamCol, 8, 64, 0.18);
                }

                  // se purificou um reativo "do zero", gasta metade da bateria
                  if(wasReactive && wasUnpurified){
                    p.battery = Math.max(0, bat - 0.5);
                    SFX.play("purify");
                  }
                }

                damageEnemy(target, dmg, {type:"beam", hasPrism, purifierBuff:(p.buffT>0), noPurify: !!p.def.noPurify});
                puff(target.x, target.y, beamCol, 4);
              } else {
                // feixe bate, mas n√£o entra
                puff(target.x, target.y, "rgba(255,255,255,.10)", 2);
              }

              // refracted damage
              if(hasPrism){
                const up = r-1, dn = r+1;
                const findNeighbor = (row) => enemies.filter(e=>e.alive && e.row===row && e.x>cc.x && e.x < cc.x + p.def.range).sort((a,b)=>a.x-b.x)[0];
                if(up>=0){
                  const t2 = findNeighbor(up);
                  if(t2){
                    if(canBeamHit(t2)){
                      if(!p.def.noPurify) t2.purifiedT = Math.max(t2.purifiedT, 4.0);
                      damageEnemy(t2, dmg*prismSplit, {type:"beam", hasPrism:true, purifierBuff:(p.buffT>0), noPurify: !!p.def.noPurify});
                      puff(t2.x, t2.y, beamCol, 3);
                    } else {
                      puff(t2.x, t2.y, "rgba(255,255,255,.10)", 2);
                    }
                  }
                }
                if(dn<ROWS){
                  const t3 = findNeighbor(dn);
                  if(t3){
                    if(canBeamHit(t3)){
                      if(!p.def.noPurify) t3.purifiedT = Math.max(t3.purifiedT, 4.0);
                      damageEnemy(t3, dmg*prismSplit, {type:"beam", hasPrism:true, purifierBuff:(p.buffT>0), noPurify: !!p.def.noPurify});
                      puff(t3.x, t3.y, beamCol, 3);
                    } else {
                      puff(t3.x, t3.y, "rgba(255,255,255,.10)", 2);
                    }
                  }
                }
              }

// drena por uso do beam
              p.battery = Math.max(0, (p.battery||0) - drain);

              puff(target.x, target.y, beamCol, 4);
            }
          } else {
            p.tBeam = 0;
          }
        }
        // global trap (Casa 214): 2s ap√≥s plantar -> STUN global + SLOW curto, depois some
        if(p.def.kind==="globalTrap"){
          p.tDelay = (p.tDelay||0) + dt;
          if(p.tDelay >= (p.def.delay||2.0)){
            const cc = cellCenter(r,c);
            try{ SFX.play("trapBoom"); }catch(_e){}
            screenFlashT = Math.max(screenFlashT, 0.22);
            screenFlashColor = "#A9B6FF";
            const stunT = (p.def.stun!=null) ? p.def.stun : 2.2;
            const postT = (p.def.postSlowTime!=null) ? p.def.postSlowTime : 2.8;
            const postM = (p.def.postSlowMult!=null) ? p.def.postSlowMult : 0.55;

            for(const e of enemies){
              if(!e.alive) continue;
              e.stunT = Math.max(e.stunT||0, stunT);
              const total = stunT + postT;
              e.slowT = Math.max(e.slowT||0, total);
              e.slowMult = Math.min(e.slowMult||1, postM);
              e.frostT = Math.max(e.frostT||0, total);
            }

            // VFX global
            const mx = GRID_X + GRID_W/2;
            const my = GRID_Y + GRID_H/2;
            ring(mx, my, "#A9B6FF", 18, 300, 0.75);
            ring(cc.x, cc.y, "#A9B6FF", 10, 120, 0.55);
            puff(mx, my, "#A9B6FF", 64);

            plants[r][c] = null;
            continue;
          }
        }

        // Botik Magnet: puxa e coleta a moeda mais pr√≥xima (meta currency)
        if(p.def.kind==="magnet"){
          p.magnetCd = Math.max(0, (p.magnetCd||0) - dt);

          // limpa alvo inv√°lido
          if(p.magnetCoin && (p.magnetCoin.collected || p.magnetCoin.life<=0)){
            if(p.magnetCoin.pulledBy===p.uid) p.magnetCoin.pulledBy = null;
            p.magnetCoin = null;
          }

          const cc = cellCenter(r,c);
          const tx = cc.x;
          const ty = cc.y - 18;

          // adquire moeda se estiver livre
          if(!p.magnetCoin && p.magnetCd<=0){
            let best=null, bestD=1e18;
            for(const c2 of coins){
              if(c2.collected) continue;
              if(c2.pulledBy!=null) continue;
              const dx = c2.x - tx, dy = c2.y - ty;
              const d2 = dx*dx + dy*dy;
              if(d2 < bestD){ bestD = d2; best = c2; }
            }
            if(best){
              best.pulledBy = p.uid;
              best.vy = 0;
              best.targetY = best.y;
              p.magnetCoin = best;
              ring(tx, ty, "#D7A0FF", 8, 64, 0.25);
            }
          }

          // puxa moeda atual
          if(p.magnetCoin){
            const coin = p.magnetCoin;
            const spd = (p.def.pullSpeed!=null) ? p.def.pullSpeed : 150;
            const dx = tx - coin.x;
            const dy = ty - coin.y;
            const dist = Math.hypot(dx, dy);

            if(dist < 10){
              coin.x = tx; coin.y = ty;
              collectCoin(coin);
              if(coin.pulledBy===p.uid) coin.pulledBy = null;
              p.magnetCoin = null;
              p.magnetCd = (p.def.pullCooldown!=null) ? p.def.pullCooldown : 5.0;
              puff(tx, ty, "#D7A0FF", 14);
            }else{
              const step = spd * dt;
              const nx = dx / (dist||1);
              const ny = dy / (dist||1);
              coin.x += nx * step;
              coin.y += ny * step;

              // VFX leve
              if(Math.random() < 0.15){
                particles.push({ x:coin.x, y:coin.y, vx:rand(-30,30), vy:rand(-40,10), r:2.2, a:0.8, tint:"#D7A0FF", life:0.22 });
              }
            }
          }
        }




        // trap
        if(p.def.kind==="trap"){
          const cc = cellCenter(r,c);

          // Coffee Armadilha: demora para armar (fica inativa antes disso)
          if((p.def.armTime||0) > 0 && !p.armed){
            p.armT = (p.armT||0) + dt;
            if(p.armT >= p.def.armTime){
              p.armed = true;
              ring(cc.x, cc.y, "#FFD36A", 8, 60, 0.22);
              puff(cc.x, cc.y, "#FFD36A", 8);
              SFX.play("trapArm");
            }
          }

          // s√≥ ativa quando estiver armada
          if(p.armed){
            // ativa quando um inimigo encosta na c√©lula
            const victim = enemies.find(e => e.alive && e.row===r && Math.abs(e.x - cc.x) < 26);
            if(victim){
              SFX.play("trapBoom");
              victim.stunT = Math.max(victim.stunT, p.def.stun);
              // p√≥s-stun: aplica lento (como Egeo Mint)
              if(p.def.postSlowTime){
                const total = p.def.stun + p.def.postSlowTime;
                victim.slowT = Math.max(victim.slowT, total);
                victim.slowMult = Math.min(victim.slowMult, (p.def.postSlowMult||0.55));
                victim.frostT = Math.max(victim.frostT||0, total);
                ring(cc.x, cc.y, "#A9B6FF", 8, 62, 0.22);
                puff(cc.x, cc.y, "#A9B6FF", 12);
              }
              damageEnemy(victim, p.def.triggerDmg * plantUpMul(p), {type:"trap"});
              // splash
              for(const e of enemies){
                if(!e.alive || e.row!==r) continue;
                if(Math.abs(e.x - cc.x) < 110){
                  damageEnemy(e, p.def.splashDmg * plantUpMul(p), {type:"trap"});
                }
              }
              ring(cc.x, cc.y, "#D7A0FF", 12, 110, 0.55);
              puff(cc.x, cc.y, "#D7A0FF", 30);
              plants[r][c] = null;
              continue;
            }
          }
        }


        // bomb
        if(p.def.kind==="bomb"){
          p.tFuse += dt;
          if(p.tFuse >= p.def.fuse){
            const cc = cellCenter(r,c);
            SFX.play("boom");
            const dmg = p.def.dmg * plantUpMul(p);
            if(p.def.doom){
              const rad = (p.def.blastRadius!=null ? p.def.blastRadius : 240);
              boomCircle(cc.x, cc.y, dmg, rad, p.def.tint);
              ring(cc.x, cc.y, p.def.tint, 16, rad*1.05, 0.70);
              puff(cc.x, cc.y, p.def.tint, 72);
              cellLocks[r][c] = Math.max(cellLocks[r][c], (p.def.lockTime!=null ? p.def.lockTime : 60));
            }else{
              boomRow(r, cc.x, dmg);
              ring(cc.x, cc.y, "#FF9A6A", 10, 90, 0.45);
              puff(cc.x, cc.y, "#FF9A6A", 26);
            }
            plants[r][c] = null;
            continue;
          }
        }

        if(p.hp <= 0){
          const cc = cellCenter(r,c);
          ring(cc.x, cc.y, "#FF6A6A", 10, 78, 0.45);
          puff(cc.x, cc.y, "#FF6A6A", 22);
          plants[r][c] = null;
        }
      }
    }

    // aroma orbs fall/bob
    for(const s of aromas){
      if(s.collected) continue;
      if(s.y < s.targetY){
        s.y += s.vy * dt;
        if(s.y >= s.targetY) s.y = s.targetY;
      }else{
        s.y += Math.sin(gameTime*2 + s.bob) * 0.14;
      }
      s.life -= dt;
      if(s.life <= 0) s.collected = true;
    }

    // coins (meta currency)
    for(const c of coins){
      if(c.collected) continue;

      // Botik Magnet puxando a moeda => n√£o aplica bob/fall padr√£o
      if(c.pulledBy==null){
        if(c.y < c.targetY){
          c.y += c.vy * dt;
          if(c.y >= c.targetY) c.y = c.targetY;
        }else{
          c.y += Math.sin(gameTime*2 + c.bob) * 0.10;
        }
      }

      c.life -= dt;
      if(c.life <= 0) c.collected = true;
    }

    // projectiles
    for(let i=projectiles.length-1; i>=0; i--){
      const pr = projectiles[i];

      // Homing (teleguiado): ajusta a dire√ß√£o aos poucos em dire√ß√£o ao alvo
      if(pr.homing){
        pr.seekT = (pr.seekT||0) + dt;
        const seekEvery = (pr.seekEvery!=null ? pr.seekEvery : 0.08);

        if(!pr.target || !pr.target.alive || pr.seekT >= seekEvery){
          pr.seekT = 0;
          let best = null;
          let bestDx = 1e9;

          // 1) prioriza a lane de origem (mais est√°vel)
          for(const e of enemies){
            if(!e.alive) continue;
            const dx = e.x - pr.x;
            if(dx < -20) continue;
            if(e.row===pr.originRow && dx < bestDx){
              bestDx = dx;
              best = e;
            }
          }

          // 2) fallback: qualquer lane
          if(!best){
            bestDx = 1e9;
            for(const e of enemies){
              if(!e.alive) continue;
              const dx = e.x - pr.x;
              if(dx < -20) continue;
              if(dx < bestDx){
                bestDx = dx;
                best = e;
              }
            }
          }

          pr.target = best;
        }

        const t = pr.target;
        if(t && t.alive){
          const speed = (pr.speed!=null ? pr.speed : (Math.hypot(pr.vx||0, pr.vy||0) || (pr.vx||320)));
          pr.speed = speed;

          const curAng = Math.atan2((pr.vy||0), (pr.vx||speed));
          const desAng = Math.atan2((t.y - pr.y), (t.x - pr.x));
          let diff = desAng - curAng;
          diff = ((diff + Math.PI) % (2*Math.PI)) - Math.PI;

          const maxTurn = (pr.turnRate || 5.0) * dt;
          diff = clamp(diff, -maxTurn, maxTurn);

          const ang = curAng + diff;
          pr.vx = Math.cos(ang) * speed;
          pr.vy = Math.sin(ang) * speed;
        }
      }

      pr.x += pr.vx * dt;
      pr.y += (pr.vy||0) * dt;

      // mant√©m dentro do grid (evita sair da tela)
      if(pr.homing){
        const minY = GRID_Y + 8;
        const maxY = GRID_Y + GRID_H - 8;
        if(pr.y < minY) pr.y = minY;
        if(pr.y > maxY) pr.y = maxY;
      }

      pr.life -= dt;

      if(pr.life<=0 || pr.x > GRID_X+GRID_W+140){
        projectiles.splice(i,1);
        continue;
      }

      let hit = null;
      for(const e of enemies){
        if(!e.alive) continue;
        if(!pr.homing && e.row!==pr.row) continue;
        if(pr.hitList && pr.hitList.indexOf(e)>=0) continue;
        const dx=e.x-pr.x, dy=e.y-pr.y;
        if(dx*dx + dy*dy < 24*24){
          hit = e; break;
        }
      }

      if(hit){
        // Bruma Reflexa nega proj√©teis comuns antes de purificar
        if(hit.def.reflectProjectiles && hit.purifiedT<=0){
          puff(pr.x, pr.y, "#A9B6FF", 12);
          ring(pr.x, pr.y, "#A9B6FF", 8, 56, 0.28);
          projectiles.splice(i,1);
          continue;
        }


if(pr.hitList) pr.hitList.push(hit);

damageEnemy(hit, pr.dmg * (pr.fromBuff ? 1.15 : 1.0), {type:"proj", fromBuff:pr.fromBuff});
puff(pr.x, pr.y, pr.tint, 10);

// splash (perfumes especiais)
if(pr.splash){
  const R = pr.splash.radius || 80;
  const mult = pr.splash.mult || 0.45;
  ring(pr.x, pr.y, pr.tint, 8, 86, 0.22);
  for(const e2 of enemies){
    if(!e2.alive || e2===hit) continue;

    if(pr.homing){
      const dx = e2.x - pr.x;
      const dy = e2.y - pr.y;
      if(dx*dx + dy*dy <= R*R){
        damageEnemy(e2, pr.dmg * mult * (pr.fromBuff ? 1.15 : 1.0), {type:"proj", fromBuff:pr.fromBuff});
        puff(e2.x, e2.y, pr.tint, 6);
      }
    }else{
      if(e2.row!==pr.row) continue;
      if(Math.abs(e2.x - pr.x) < R){
        damageEnemy(e2, pr.dmg * mult * (pr.fromBuff ? 1.15 : 1.0), {type:"proj", fromBuff:pr.fromBuff});
        puff(e2.x, e2.y, pr.tint, 6);
      }
    }
  }
}

// aoe circle (custom)
if(pr.aoe){
  const R = pr.aoe.radius || 90;
  const mult = pr.aoe.mult || 0.45;
  ring(pr.x, pr.y, pr.tint, 10, Math.min(220, R*1.05), 0.18);
  for(const e2 of enemies){
    if(!e2.alive || e2===hit) continue;
    if(pr.hitList && pr.hitList.indexOf(e2)>=0) continue;
    const dx = e2.x - pr.x;
    const dy = e2.y - pr.y;
    if(dx*dx + dy*dy <= R*R){
      damageEnemy(e2, pr.dmg * mult * (pr.fromBuff ? 1.15 : 1.0), {type:"proj", fromBuff:pr.fromBuff});
      puff(e2.x, e2.y, pr.tint, 6);
    }
  }
}

        if(pr.slow){
          hit.slowT = Math.max(hit.slowT, pr.slow.time);
          hit.slowMult = Math.min(hit.slowMult, pr.slow.mult);
          hit.frostT = Math.max(hit.frostT||0, pr.slow.time);
          // efeito visual de gelo (Egeo Mint)
          ring(pr.x, pr.y, "#A9B6FF", 8, 58, 0.30);
          puff(pr.x, pr.y, "#A9B6FF", 12);
        }

if(pr.salt){
  hit.saltT = Math.max(hit.saltT||0, pr.salt.time);
  ring(pr.x, pr.y, "#B7F2FF", 7, 54, 0.26);
  puff(pr.x, pr.y, "#B7F2FF", 10);
}
if(pr.resin){
  hit.resinT = Math.max(hit.resinT||0, pr.resin.time);
  hit.resinMult = Math.min(hit.resinMult||1, pr.resin.mult || 0.86);
  ring(pr.x, pr.y, "#FFB36A", 7, 54, 0.26);
  puff(pr.x, pr.y, "#FFB36A", 10);
}
if(pr.burn){
  hit.burnT = Math.max(hit.burnT||0, pr.burn.time);
  hit.burnDps = Math.max(hit.burnDps||0, pr.burn.dps);
  ring(pr.x, pr.y, "#FF6A3D", 7, 54, 0.26);
  puff(pr.x, pr.y, "#FF6A3D", 12);
}
if(pr.poison){
  hit.poisonT = Math.max(hit.poisonT||0, pr.poison.time);
  hit.poisonDps = Math.max(hit.poisonDps||0, pr.poison.dps);
  ring(pr.x, pr.y, "#6BFF7A", 7, 54, 0.26);
  puff(pr.x, pr.y, "#6BFF7A", 12);
}
if(pr.stun){
  hit.stunT = Math.max(hit.stunT||0, pr.stun.time);
  ring(pr.x, pr.y, "#EEF2FF", 7, 54, 0.22);
  puff(pr.x, pr.y, "#EEF2FF", 10);
}
        if(pr.pierce && pr.pierce>1){
          pr.pierce -= 1;
          if(pr.pierce<=0) projectiles.splice(i,1);
        }else{
          projectiles.splice(i,1);
        }
      }
    }

    // enemies
    for(const e of enemies){
      if(!e.alive) continue;

      // boss minions
      if(e.def.key==="boss1" || e.def.key==="boss2"){
        e.abilityT += dt;
        const rate = e.def.spawnMinionsRate * (e.hp < e.maxHp*0.5 ? 0.75 : 1.0);
        if(e.abilityT >= rate){
          e.abilityT = 0;
          if(e.def.key==="boss1"){
            spawnEnemy(irand(0,ROWS-1), "fast");
            spawnEnemy(irand(0,ROWS-1), "toxic");
          }else{
            const pool = ["reflect","sticky","cloak","armored","fast","toxic"];
            spawnEnemy(irand(0,ROWS-1), pool[irand(0,pool.length-1)]);
            spawnEnemy(irand(0,ROWS-1), pool[irand(0,pool.length-1)]);
          }
          ring(e.x, e.y, "#FF6A6A", 10, 70, 0.45);
          puff(e.x, e.y, "#FF6A6A", 18);
        }
      }
// aura: Bruma Autolimpante (limpa marca√ß√µes de aliados)
if(e.def.cleanseAura){
  e.cleanseT = (e.cleanseT||0) + dt;
  const rate = e.def.cleanseAura.rate || 3.0;
  if(e.cleanseT >= rate){
    e.cleanseT = 0;
    const R = e.def.cleanseAura.range || 170;
    const R2 = R*R;
    let did = false;
    for(const e2 of enemies){
      if(!e2.alive) continue;
      const dx = e2.x - e.x;
      const dy = e2.y - e.y;
      if(dx*dx + dy*dy <= R2){
        if((e2.saltT||0)>0 || (e2.resinT||0)>0){
          e2.saltT = 0;
          e2.resinT = 0;
          e2.resinMult = 1;
          did = true;
          puff(e2.x, e2.y, "#FFD36A", 6);
        }
      }
    }
    if(did){
      ring(e.x, e.y, "#FFD36A", 8, 70, 0.20);
    }
  }
}


      // slow and purified and stun
      if(e.slowT > 0){
        e.slowT -= dt;
        if(e.slowT<=0){ e.slowT=0; e.slowMult=1; }
      }
      if(e.frostT > 0){
        e.frostT -= dt;
        if(e.frostT<=0) e.frostT = 0;
      }
if((e.saltT||0) > 0){
  e.saltT = Math.max(0, e.saltT - dt);
}
if((e.resinT||0) > 0){
  e.resinT = Math.max(0, e.resinT - dt);
  if(e.resinT<=0){ e.resinT = 0; e.resinMult = 1; }
}
if((e.burnT||0) > 0){
  e.burnT = Math.max(0, e.burnT - dt);
  e.hp -= (e.burnDps||0) * dt;
  if(e.burnT<=0){ e.burnT = 0; e.burnDps = 0; }
}
if((e.poisonT||0) > 0){
  e.poisonT = Math.max(0, e.poisonT - dt);
  e.hp -= (e.poisonDps||0) * dt;
  if(e.poisonT<=0){ e.poisonT = 0; e.poisonDps = 0; }
}
      e.purifiedT = Math.max(0, e.purifiedT - dt);
      e.stunT = Math.max(0, e.stunT - dt);

      // global slow aura
      const globalSlow = (globalBuffs.enemySlowAllT > 0) ? 0.72 : 1.0;

      const speed = e.baseSpeed
        * (e.slowT>0 ? e.slowMult : 1)
        * (e.resinT>0 ? (e.resinMult||1) : 1)
        * globalSlow
        * (e.stunT>0 ? 0 : 1);

      // mower trigger
      const mower = mowers.find(m => m.active && m.row===e.row);
      if(mower && mower.active && !mower.moving && e.x < GRID_X-10){
        mower.moving = true;
      }
      if(mower && mower.active && mower.moving && Math.abs(mower.x - e.x) < 28){
        mowerHitEnemy(e, false);
      }

      // find victim plant
      const rowPlants = plants[e.row];
      let victim = null;
      let victimX = 0;
      let victimCell = null;

      for(let c=0;c<COLS;c++){
        const p = rowPlants[c];
        if(!p) continue;
        const px = cellCenter(e.row, c).x;
        if(e.x <= px + 20 && e.x >= px - 20){
          victim = p;
          victimX = px;
          victimCell = {r:e.row, c};
          break;
        }
      }

      if(victim && e.stunT<=0){
        e.biteT += dt;
        if(e.biteT >= e.def.biteRate){
          e.biteT = 0;
          // dano com escudo de espuma
          let dmg = Math.round(e.def.damage * (e.dmgMult || 1));
          // Infuse Resist (12.3): reduz dano recebido
          if((victim.infuseResistMul||1) !== 1){ dmg = Math.max(0, Math.round(dmg * victim.infuseResistMul)); }
          // Infuse Shield (12.6): absorve dano antes do escudo de espuma
          if((victim.infuseT||0) > 0 && victim.infuseType==="shield" && (victim.infuseShieldHp||0) > 0){
            const beforeIS = victim.infuseShieldHp;
            const takeIS = Math.min(beforeIS, dmg);
            victim.infuseShieldHp = beforeIS - takeIS;
            dmg -= takeIS;
            SFX.play("shieldHit");
            const scol = victim.infuseCol || "#B9FFD9";
            ring(victimX, e.y-6, scol, 8, 56, 0.22);
            puff(victimX, e.y-6, scol, 10);
            if(beforeIS > 0 && victim.infuseShieldHp <= 0){
              SFX.play("shieldBreak");
              ring(victimX, e.y-6, "#FFFFFF", 10, 110, 0.26);
            }
          }
          if((victim.shieldHp||0) > 0){
            const beforeS = victim.shieldHp;
            const take = Math.min(beforeS, dmg);
            victim.shieldHp = beforeS - take;
            dmg -= take;
            SFX.play("shieldHit");
            ring(victimX, e.y-6, "#8DE1FF", 8, 56, 0.22);
            puff(victimX, e.y-6, "#8DE1FF", 10);
            if(beforeS > 0 && victim.shieldHp <= 0){
              // estoura: empurra levemente mal cheiros pr√≥ximos
              const kr = victim.shieldPopRange || 160;
              const kb = victim.shieldPopKnock || 26;
              for(const e2 of enemies){
                if(!e2.alive || e2.row!==e.row) continue;
                if(Math.abs(e2.x - victimX) < kr){
                  e2.x += kb;
                }
              }
              SFX.play("shieldBreak");
              ring(victimX, e.y-6, "#FFFFFF", 10, 110, 0.30);
            }
          }
          if(dmg > 0){
            victim.hp -= dmg;
            puff(victimX, e.y, "#FF6A6A", 6);
          }


          if(e.def.poison){
            victim.poisonT = Math.max(victim.poisonT, e.def.poison.time);
            victim.poisonDps = Math.max(victim.poisonDps, e.def.poison.dps);
            puff(victimX, e.y-10, "#FFD36A", 8);
          }
          if(e.def.stickyDebuff){
            victim.stickyT = Math.max(victim.stickyT, e.def.stickyDebuff.time);
            puff(victimX, e.y-10, "#D7A0FF", 8);
          }
        }
      }else{
        e.x -= speed * dt;
      }
      if(e.hp <= 0){
        tryDropCoin(e);
        // estilha√ßa em fragmentos (p√≥s-game)
        if(e.def.onDieSpawn){
          const os = e.def.onDieSpawn;
          const n = os.count || 2;
          const spread = os.spread || 24;
          const pool = os.pool || ["whiff"];
          for(let k=0;k<n;k++){
            const kk = pool[irand(0, pool.length-1)];
            spawnEnemyAt(e.row, kk, e.x + rand(-spread, spread));
          }
          ring(e.x, e.y, e.def.tint, 8, 70, 0.26);
          puff(e.x, e.y, e.def.tint, 14);
        }

        const isBoss = (e.def.key==="boss1" || e.def.key==="boss2");
        SFX.play(isBoss ? "bossDie" : "enemyDie");
        e.alive = false;
        ring(e.x, e.y, e.def.tint, 8, 70, 0.48);
        puff(e.x, e.y, e.def.tint, isBoss ? 44 : 20);
      }


      if(e.x < LEFT_FAIL_X){
        lost = true;
      }
    }

    // mowers
    for(const m of mowers){
      if(!m.active) continue;
      if(m.moving){
        m.x += m.speed * dt;
        for(const e of enemies){
          if(!e.alive || e.row!==m.row) continue;
          if(Math.abs(e.x - m.x) < 30){
            mowerHitEnemy(e, true);
          }
        }
        if(m.x > GRID_X + GRID_W + 220) m.active = false;
      }
    }

    // rings
    for(let i=rings.length-1;i>=0;i--){
      const r = rings[i];
      r.r += r.dr * dt;
      r.life -= dt;
      r.a = clamp(r.life / r.max, 0, 1);
      if(r.life <= 0) rings.splice(i,1);
    }

    // particles
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vy += 260*dt;
      p.life -= dt;
      p.a = clamp(p.life/0.85,0,1);
      if(p.life<=0) particles.splice(i,1);
    }

    // cleanup dead enemies
    for(let i=enemies.length-1;i>=0;i--){
      if(!enemies[i].alive) enemies.splice(i,1);
    }

    // victory
    if(!currentWorld.survival && spawnQueue.length===0 && enemies.length===0 && gameTime > lastPlannedT){
      won = true;
      onWorldWin();
    }
  }

  // ================= Win / Unlock =================
  function onWorldWin(){
    const campId = currentCampaign.id;
    const worlds = currentCampaign.worlds;
    const idx = worlds.findIndex(w=>w.id===currentWorld.id);

    // reward plant
    if(currentWorld.rewardPlant){
      progress.unlockedPlants.add(currentWorld.rewardPlant);
    }

    // unlock next world
    if(idx+1 < worlds.length){
      progress.worldUnlocked[campId][idx+1] = true;
    }

    // unlocking post-campaign after story ends
    if(campId==="story" && currentWorld.id===5){
      progress.postUnlocked = true;
      Campaigns.post.unlocked = true;
      // unlock first post world
      progress.worldUnlocked.post[0] = true;

      showOverlay("menu");
      overlayTitle.textContent = "P√≥s-Hist√≥ria desbloqueada! üåë‚ú®";
      overlayDesc.textContent = "O Eclipse do Miasma come√ßou. O Purificador agora √© pe√ßa-chave.";
      rebuildSeedBank();
      saveProgress();
      return;
    }

    // end of post campaign -> unlock Campanha 2
    if(campId==="post" && currentWorld.id===10){
      progress.c2Unlocked = true;
      Campaigns.c2.unlocked = true;
      if(Array.isArray(progress.worldUnlocked.c2) && progress.worldUnlocked.c2.length) progress.worldUnlocked.c2[0] = true;


      // presente de abertura da Campanha 2: Kaiak Sal (necess√°rio para lacres)
      progress.unlockedPlants.add("kaiakSal");

      // j√° deixa o mapa apontando pra Campanha 2 quando o jogador voltar
      progress.activeCampaignId = "c2";

      showOverlay("menu");
      overlayTitle.textContent = "P√≥s-Hist√≥ria conclu√≠da! üèÜ";
      overlayDesc.textContent = "Voc√™ derrubou o Imperador do Eclipse. A Campanha 2 (Contra-Lacre) foi desbloqueada! Presente inicial: üßÇ Kaiak Sal.";
      rebuildSeedBank();
      saveProgress();
      return;
    }

    // end of Campanha 2
    if(campId==="c2" && idx === worlds.length-1){
      showOverlay("menu");
      overlayTitle.textContent = "Campanha 2 conclu√≠da! üåü";
      overlayDesc.textContent = "Voc√™ dominou lacres, resinas e autolimpeza. Parab√©ns ‚Äî e obrigado por jogar!";
      rebuildSeedBank();
      saveProgress();
      return;
    }

    saveProgress();
    showOverlay("map");
    overlayTitle.textContent = "Vit√≥ria! üåø";
    if(currentWorld.rewardPlant){
      overlayDesc.textContent = `Voc√™ liberou: ${plantById.get(currentWorld.rewardPlant).icon} ${plantById.get(currentWorld.rewardPlant).name}.`;
    }else if(idx === worlds.length-1){
      overlayDesc.textContent = "Voc√™ venceu o mundo final desta campanha.";
    }else{
      overlayDesc.textContent = "Voc√™ venceu este mundo.";
    }
    rebuildSeedBank();
  }

  // ================= Start / Reset world =================
  function startWorld(campaignId, worldId){
    currentCampaign = Campaigns[campaignId];
    if(!currentCampaign || !currentCampaign.worlds){
      currentCampaign = Campaigns.story;
    }
    const wid = Number(worldId);
    const w = currentCampaign.worlds.find(x=>Number(x.id)===wid) || currentCampaign.worlds.find(x=>String(x.id)===String(worldId));
    if(!w){
      currentWorld = currentCampaign.worlds && currentCampaign.worlds[0] ? currentCampaign.worlds[0] : null;
      running = false;
      mode = "menu";
      showOverlay("menu");
      overlayTitle.textContent = "‚ö†Ô∏è Mundo n√£o encontrado";
      overlayDesc.textContent = "N√£o consegui iniciar a fase (ID inv√°lido). Abra o Mapa e selecione o mundo novamente.";
      return;
    }
    currentWorld = w;

    // snapshot do custom para esta fase
    try{
      const snapCfg = _sanitizeCustomPerfumeCfg(progress.customPerfume || defaultCustomPerfumeCfg());
      matchCustomPerfumeDef = makeCustomPerfumeDef(snapCfg);
    }catch(_e){
      matchCustomPerfumeDef = null;
    }

    // state
    mode = "playing";
    running = true;
    paused = false;
    won = false;
    lost = false;

    aroma = 150;
    selectedId = null;
    hoverCell = null;

    gameTime = 0;
    lastTs = 0;

    cooldowns.clear();
    enemies.length = 0;
    projectiles.length = 0;
    aromas.length = 0;
    coins.length = 0;
    particles.length = 0;
    rings.length = 0;
    beams.length = 0;
    alerts.length = 0;

    // perks (runtime)
    perkFreeCoffeeUsed = false;

    globalBuffs.enemySlowAllT = 0;
    globalBuffs.beamBoostT = 0;

    resetGrid();
    resetMowers();
    buildWorldPlan(w);

    rebuildSeedBank();
  }

  function restartWorld(){
    if(!currentWorld) return;
    startWorld(currentCampaign.id, currentWorld.id);
  }

  // ================= Status UI =================
  function setStatus(){
    worldText.textContent = currentWorld ? String(currentWorld.id) : "‚Äî";

    if(mode !== "playing"){
      statusText.textContent = "Menu";
      dotStatus.style.background = "var(--warn)";
      return;
    }

    if(won){
      statusText.textContent = "Vit√≥ria!";
      dotStatus.style.background = "var(--good)";
      return;
    }
    if(lost){
      statusText.textContent = "Derrota!";
      dotStatus.style.background = "var(--bad)";
      return;
    }
    if(paused){
      statusText.textContent = "Pausado";
      dotStatus.style.background = "var(--warn)";
      return;
    }
    if(isPreparation()){
      const left = Math.max(0, currentWorld.prepTime - gameTime);
      statusText.textContent = `Prepara√ß√£o: ${left.toFixed(0)}s`;
      dotStatus.style.background = "var(--warn)";
      return;
    }
    const introEnd = currentWorld.prepTime + (currentWorld.introDelay||0);
    if(gameTime < introEnd){
      const left = Math.max(0, introEnd - gameTime);
      statusText.textContent = `Cheiros chegando: ${left.toFixed(0)}s`;
      dotStatus.style.background = "var(--warn)";
      return;
    }

    statusText.textContent = "Em jogo";
    dotStatus.style.background = "var(--good)";
  }

  function syncWaveBar(){
    if(!currentWorld || lastPlannedT <= 0 || mode !== "playing"){
      barFill.style.width = "0%";
      waveText.textContent = "‚Äî/‚Äî";
      barNodes.innerHTML = "";
      return;
    }
    const frac = clamp(gameTime / lastPlannedT, 0, 1);
    barFill.style.width = (frac*100).toFixed(2) + "%";

    const nodes = barNodes.querySelectorAll(".node");
    nodes.forEach((n, i)=>{
      const wt = waveStartTimes[i] ?? Infinity;
      n.classList.toggle("active", gameTime >= wt);
    });

    const wi = getWaveIndex();
    waveText.textContent = `${wi}/${waveStartTimes.length}`;
  }

  // ================= Collect (drag) =================
  function orbUnderMouse(x,y){
    for(const s of aromas){
      if(s.collected) continue;
      const dx=x-s.x, dy=y-s.y;
      if(dx*dx + dy*dy <= ORB_CLICK_R2) return s;
    }
    return null;
  }

  function collectOrb(orb){
    if(!orb || orb.collected) return false;
    orb.collected = true;

    const def = AromaTypes[orb.typeId] || AromaTypes.gold;
    aroma += def.value;

    if(def.onCollect) def.onCollect();

    puff(orb.x, orb.y, def.tint, 14);
    ring(orb.x, orb.y, def.tint, 6, 44, 0.30);
    syncSeedUI();
    return true;
  }

  canvas.addEventListener("pointerdown", (ev)=>{
    ev.preventDefault();
    pointerDown = true;
    pointerMoved = false;

    const {x,y} = toBaseCoords(ev.clientX, ev.clientY);
    downX = x; downY = y;

    const coin = coinUnderMouse(x,y);
    if(coin){ collectCoin(coin); pointerConsumed = true; hoverCell = null; canvas.setPointerCapture(ev.pointerId); return; }

    const orb = orbUnderMouse(x,y);
    if(orb){ collectOrb(orb); pointerConsumed = true; hoverCell = null; }

    canvas.setPointerCapture(ev.pointerId);
  });

  canvas.addEventListener("pointermove", (ev)=>{
    const {x,y} = toBaseCoords(ev.clientX, ev.clientY);

    const coin = coinUnderMouse(x,y);
    const orb = coin ? null : orbUnderMouse(x,y);
    if(coin || orb){
      canvas.style.cursor = "pointer";
      hoverCell = null;
    }else{
      const cell = cellAt(x,y);
      hoverCell = cell;

      if((!selectedId) && mode==="playing" && !won && !lost && cell && plants[cell.row][cell.col] && plants[cell.row][cell.col].def && plants[cell.row][cell.col].def.kind==="charge" && plants[cell.row][cell.col].chargeReady){
        canvas.style.cursor = "pointer";
      }else if(!selectedId || mode!=="playing"){
        canvas.style.cursor = "default";
      }else{
        let def = plantById.get(selectedId);
    if(mode==="playing" && selectedId==="customPerfume" && matchCustomPerfumeDef) def = matchCustomPerfumeDef;
        if(!cell || !def){ canvas.style.cursor = "default"; }
        else if(def.kind==="tool"){ canvas.style.cursor = "default"; }
        else if(cellLocks[cell.row][cell.col] > 0){ canvas.style.cursor = "not-allowed"; }
        else if(def.kind==="refil" || def.kind==="infuse"){
          canvas.style.cursor = plants[cell.row][cell.col] ? "pointer" : "not-allowed";
        }else{
          canvas.style.cursor = plants[cell.row][cell.col] ? "not-allowed" : "cell";
        }
      }
    }

    if(pointerDown){
      const dx = x - downX, dy = y - downY;
      if(dx*dx + dy*dy > 30) pointerMoved = true;

      if(coin){ collectCoin(coin); pointerConsumed = true; }
      if(orb){ collectOrb(orb); pointerConsumed = true; }
    }
  });

  canvas.addEventListener("pointerup", (ev)=>{
    if(!pointerDown) return;
    pointerDown = false;

    if(mode!=="playing" || won || lost) return;

    if(pointerConsumed){ pointerConsumed = false; return; }

    const {x,y} = toBaseCoords(ev.clientX, ev.clientY);

    // arrastou => n√£o planta
    if(pointerMoved) return;

    const coin = coinUnderMouse(x,y);
    if(coin){ collectCoin(coin); return; }

    const orb = orbUnderMouse(x,y);
    if(orb) return;

    // click-to-fire: Charge Shot (clicar na planta quando estiver pronta)
    if(!selectedId){
      const cell = cellAt(x,y);
      if(cell && plants[cell.row][cell.col]){
        const p = plants[cell.row][cell.col];
        if(p && p.def && p.def.kind==="charge"){
          if(p.chargeReady){
            fireChargeShot(p);
          }else{
            const cc = cellCenter(cell.row, cell.col);
            ring(cc.x, cc.y, "rgba(255,211,106,.55)", 8, 54, 0.26);
            puff(cc.x, cc.y-6, "rgba(255,211,106,.55)", 6);
            SFX.play("ui");
          }
          return;
        }
      }
      return;
    }

    const cell = cellAt(x,y);
    if(!cell) return;

    let def = plantById.get(selectedId);
    if(mode==="playing" && selectedId==="customPerfume" && matchCustomPerfumeDef) def = matchCustomPerfumeDef;
    if(!def) return;

    // shovel
    if(def.kind==="tool"){
      if(plants[cell.row][cell.col]){
        const cc = cellCenter(cell.row, cell.col);
        ring(cc.x, cc.y, "#eef2ff", 8, 54, 0.32);
        puff(cc.x, cc.y, "#eef2ff", 12);
        SFX.play("shovel");
        plants[cell.row][cell.col] = null;
      }
      selectedId = null;
      syncSeedUI();
      return;
    }

    // tile bloqueado (cratera)
    if(cellLocks[cell.row][cell.col] > 0) return;

    // refil (upgrade: s√≥ em cima de outro perfume)
    if(def.kind==="refil"){
      const target = plants[cell.row][cell.col];
      if(!target) return;

      const rem = cooldowns.get(def.id) || 0;
      if(rem > 0) return;

      if(def.cost > aroma) return;

      // valida limite antes de ‚Äúpendurar‚Äù o refil
      const upMax = (def && def.upMax!=null) ? def.upMax : REFIL_UP_MAX;
      target.upLv = (target.upLv!=null) ? target.upLv : 0;
      if(target.upLv >= upMax){
        const cc = cellCenter(cell.row, cell.col);
        ring(cc.x, cc.y, "rgba(255,106,106,.55)", 8, 54, 0.30);
        puff(cc.x, cc.y, "#FF6A6A", 10);
        SFX.play("ui");
        selectedId = null;
        syncSeedUI();
        return;
      }

      // paga agora (o refil ‚Äúsome‚Äù), mas o buff aplica ap√≥s 2s
      aroma -= def.cost;
      if(def.cooldown > 0) cooldowns.set(def.id, def.cooldown);

      target.pendingRefilT = 2.0;
      target.pendingRefilDef = def;

      const cc = cellCenter(cell.row, cell.col);
      ring(cc.x, cc.y, def.tint, 10, 74, 0.40);
      puff(cc.x, cc.y-6, def.tint, 18);
      SFX.play("select");

      // unselect autom√°tico
      selectedId = null;
      syncSeedUI();
      return;
    }

    // infuse (buff: s√≥ em cima de outro perfume)
    if(def.kind==="infuse"){
      const target = plants[cell.row][cell.col];
      if(!target) return;

      // 12.8: anti-spam (por alvo)
      if((target.infuseApplyCd||0) > 0){
        flashOverlayToast(`‚è≥ Aguarde ${Math.ceil(target.infuseApplyCd*10)/10}s para re-infusar esse perfume.`, "warn");
        selectedId = null;
        syncSeedUI();
        return;
      }

      const rem = cooldowns.get(def.id) || 0;
      if(rem > 0) return;

      if(def.cost > aroma) return;

      aroma -= def.cost;
      if(def.cooldown > 0) cooldowns.set(def.id, def.cooldown);

      const cc = cellCenter(cell.row, cell.col);
      const col = def.projTint || def.tint;
      ring(cc.x, cc.y, col, 12, 88, 0.42);
      puff(cc.x, cc.y-6, col, 20);

      // aplica buff (12.2/12.3: power/resist)
      const had = ((target.infuseT||0) > 0);
      const prev = target.infuseType;
      const ok = applyInfuseToPlant(target, def);

      try{ SFX.play("buff"); }catch(_e){}

      if(ok){
        const inf = def.infuse || {};
        const label = (inf.type||"").toUpperCase();
        const durTxt = (inf.permanent ? "PERM (fase)" : ((inf.duration!=null?inf.duration:0) + "s"));
        let how = "aplicado";
        if(had){
          how = (prev===inf.type) ? "renovado" : "substitu√≠do";
        }
        const prevTxt = (had && prev && prev!==inf.type) ? ` (antes: ${String(prev).toUpperCase()})` : "";
        flashOverlayToast(`üß¨ Infuse ${how}: ${label} ‚Ä¢ ${durTxt}${prevTxt} ‚Ä¢ n√£o acumula`, "good");
      }else{

        flashOverlayToast("‚ö†Ô∏è Falha ao aplicar Infuse.", "bad");
      }

      // unselect autom√°tico
      selectedId = null;
      syncSeedUI();
      return;
    }



    if(plants[cell.row][cell.col]) return;

    const rem = cooldowns.get(def.id) || 0;
    if(rem > 0) return;

    if(def.cost > aroma) return;

    plants[cell.row][cell.col] = makePlant(def, cell.row, cell.col);
    aroma -= def.cost;
    if(def.cooldown > 0) cooldowns.set(def.id, def.cooldown);

    const cc = cellCenter(cell.row, cell.col);
    ring(cc.x, cc.y, def.tint, 8, 54, 0.34);
    puff(cc.x, cc.y+10, def.tint, 12);

    // SFX: plantar
    SFX.play("plant");

    // unselect autom√°tico
    selectedId = null;
    syncSeedUI();
  });

  canvas.addEventListener("contextmenu", (ev)=>{
    ev.preventDefault();
    selectedId = null;
    syncSeedUI();
  });

  // ================= Buttons/keys =================
  function togglePause(){ if(mode!=="playing" || won || lost) return; paused = !paused; }

  btnPause.addEventListener("click", togglePause);
  if(btnSound){
    btnSound.addEventListener("click", ()=>{
      const on = !SFX.isEnabled();
      SFX.setEnabled(on);
      btnSound.textContent = on ? "Som: ON" : "Som: OFF";
      if(on) SFX.play("ui");
    });
  }
  btnRestart.addEventListener("click", restartWorld);

  window.addEventListener("keydown",(ev)=>{
    const _t = ev.target;
    if(_t && (_t.tagName==="INPUT" || _t.tagName==="TEXTAREA" || _t.tagName==="SELECT" || _t.isContentEditable)) return;
    if(ev.code==="Space"){ ev.preventDefault(); togglePause(); }
    if(ev.key.toLowerCase()==="r"){ restartWorld(); }
    if(ev.key.toLowerCase()==="m"){ showOverlay("map"); }
    if(ev.key.toLowerCase()==="i"){ showOverlay("info"); }
    if(ev.key.toLowerCase()==="s" && btnSound){
      const on = !SFX.isEnabled();
      SFX.setEnabled(on);
      btnSound.textContent = on ? "Som: ON" : "Som: OFF";
      if(on) SFX.play("ui");
    }
    if(ev.key==="Escape"){ selectedId = null; syncSeedUI(); }
  });

  // ================= Loop =================
  function loop(ts){
    try{
      if(!lastTs) lastTs = ts;
      const dt = clamp((ts-lastTs)/1000, 0, 0.05);
      lastTs = ts;

      visualTime += dt;

      aromaText.textContent = String(aroma);
      coinText.textContent = String(progress.currency || 0);

      if(_currencyDirty){
        _currencySaveT += dt;
        if(_currencySaveT >= 1.2){
          saveProgress();
          _currencyDirty = false;
          _currencySaveT = 0;
        }
      }

      setStatus();
      syncSeedUI();
      syncWaveBar();

      if(running && mode === "playing" && currentWorld){
        update(dt);
      }
      draw();
    }catch(err){
      showFatalError(err);
    }

    requestAnimationFrame(loop);
  }

  // ================= Boot =================
  rebuildSeedBank();

  // come√ßa no MENU (corrige o bug de ‚Äúj√° venceu‚Äù)
  running = false;
  mode = "menu";
  currentCampaign = Campaigns.story;
  currentWorld = Campaigns.story.worlds[0]; // s√≥ pra renderizar tema, sem rodar update (running=false)
  showOverlay("menu");

  requestAnimationFrame(loop);
})();</script>

  <div id="rotateOverlay" aria-hidden="true">
    <div class="box">
      <div class="ttl">Vire o celular</div>
      <div class="sub">Este jogo foi pensado para jogar em modo <b>horizontal</b> (tela deitada).</div>
    </div>
  </div>
<script>
  // PWA: register service worker (works on HTTPS or localhost)
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw.js").catch(()=>{});
    });
  }

  // UX: show a rotate prompt when in portrait on mobile
  (function(){
    const el = document.getElementById("rotateOverlay");
    if(!el) return;
    function upd(){
      const isPortrait = window.matchMedia && window.matchMedia("(orientation: portrait)").matches;
      el.classList.toggle("show", !!isPortrait);
      el.setAttribute("aria-hidden", (!isPortrait).toString());
    }
    window.addEventListener("resize", upd);
    window.addEventListener("orientationchange", upd);
    upd();
  })();
</script>
</body>
</html>
